import{S as Do,i as Go,s as Ho,e as i,t as s,k as n,c as l,a as f,g as u,d as t,n as p,b as h,a5 as c,L as m,f as a,D as r,E as Lt}from"../../chunks/vendor-0fd8ff1a.js";function Wo(jo){let b,Re,D,Xe,Ye,de,G,Ze,ce,F,$e,be,v,Ut,we,L,et,ye,U,tt,ve,q,ot,_e,_,qt,ke,J,at,Ie,V,re,rt,xe,k,Jt,Ee,K,it,Te,H,lt,Ae,I,W,st,ut,C,ft,nt,Pe,N,pt,Me,d,ht,ie,mt,dt,le,ct,bt,se,wt,yt,ue,vt,Oe,w,_t,fe,kt,It,ne,xt,Et,ge,x,Vt,Se,Q,Tt,je,E,Kt,De,j,At,pe,Pt,Mt,Ge,T,Nt,He,R,Ot,We,A,Qt,Ce,X,gt,Be,P,Rt,ze,Y,St,Fe,M,Xt,Le,Z,jt,Ue,O,Yt,qe,$,Dt,Je,ee,he,Gt,Ve,g,Zt,Ke,te,Ht,Ne,y,Wt,B,Ct,Bt,z,zt,Ft;return{c(){b=i("p"),Re=s("I recently had to setup an experimental rig with an interface between Matlab and an Arduino. The goal of the interface was to read out the position of a treadmill using a rotary encoder. This must be a pretty common situation in neuroscience these days, but my first foray into setting it up (through the official "),D=i("a"),Xe=s("matlab arduino toolbox"),Ye=s(") was way too slow for any reasonable experiment. I figured I\u2019d write up my notes on the process here. If you know a better way to do this, please email or message me!"),de=n(),G=i("h3"),Ze=s("Approach 1: Matlab arduino toolbox"),ce=n(),F=i("p"),$e=s("The matlab toolbox is pretty easy to use. We need a rotary encoder to read out the turns of the treadmill, and that\u2019s already built in as toolbox (again, figure this is a pretty common task). The code to connect and setup the rotary encoder look like this:"),be=n(),v=i("img"),we=n(),L=i("p"),et=s("The encoder uses digital inputs 2 and 3."),ye=n(),U=i("p"),tt=s("Great. Simple enough. But is it fast enough? Our experiment code runs visual stimuli at 120 or 240Hz. That means we have to complete all analyses of behavior within ~7 or ~3.5 ms before we absolutely have to draw the stimuli. These numbers shrink if the stimuli are really complicated. All time matters (e.g., communicating with the syringe pump to send reward takes ~0.5 ms)."),ve=n(),q=i("p"),ot=s("To compute the arduino toolbox call time, I just ran the main call 1000 times in a for loop and measured the elapsed time. The code looks like this:"),_e=n(),_=i("img"),ke=n(),J=i("p"),at=s("Pretty straightforward. And the output?"),Ie=n(),V=i("p"),re=i("code"),rt=s("Median Duration Arduino Toolbox = 8.07 [7.89, 8.23] ms"),xe=n(),k=i("img"),Ee=n(),K=i("p"),it=s("This just won\u2019t work. Matlab hangs for ~8ms each time the toolbox calls. At that rate, we\u2019d drop every single frame of the experiment. This would be possible at a 60Hz refresh rate, but that\u2019s just too slow for reasonable motion stimuli. I searched the Mathworks forums and Arduino forums and there\u2019s a lot of chatter about how slow this is, but also a lot of insistance that \u201Cthis is just how fast you can run over USB\u201D. That can\u2019t be right. And it isn\u2019t. There\u2019s a faster way\u2026"),Te=n(),H=i("h3"),lt=s("Approach 2: IOPort serial connection"),Ae=n(),I=i("p"),W=i("a"),st=s("Psychtoolbox"),ut=s(" has a mex function called "),C=i("a"),ft=s("IOPort"),nt=s(" that supports connections over a serial port (which can work over USB, of course). This means we\u2019d need to run all rotary encoding on the Arduino as a sketch and only use Matlab to communicate to a serial buffer."),Pe=n(),N=i("p"),pt=s("Arduino sketches are easy enough to write and you can find plenty of code snippets online. Here\u2019s the steps of the code I\u2019m using. I based it off a snippet I got from Jack Liska in Huklab."),Me=n(),d=i("p"),ht=s("The code sketch has 4 parts: "),ie=i("code"),mt=s("variable declaration"),dt=s(", "),le=i("code"),ct=s("setup"),bt=s(", "),se=i("code"),wt=s("main loop"),yt=s(", and "),ue=i("code"),vt=s("rotary encoder function"),Oe=n(),w=i("p"),_t=s("We use the "),fe=i("code"),kt=s("digitalWriteFast"),It=s(" library which supposedly offers substantial speedup over the default "),ne=i("code"),xt=s("digitalWrite"),Et=s(" function in the default Arduino library. All variables are setup here:"),ge=n(),x=i("img"),Se=n(),Q=i("p"),Tt=s("Then we setup the serial buffer and initialize the encoder pins. The rotary encoder operates as an interrupt that responds to the rising edge of the digital inputs."),je=n(),E=i("img"),De=n(),j=i("p"),At=s("The main loop just dumps the current time and encoder count to the serial buffer. It also listens for a \u201Creset\u201D command to reset the counter, which is necessary so that our count doesn\u2019t exceed the bitdepth of the "),pe=i("code"),Pt=s("long"),Mt=s(" type we\u2019re storing them as."),Ge=n(),T=i("img"),He=n(),R=i("p"),Ot=s("The loop depends on the encoder to detect digital ins and count them."),We=n(),A=i("img"),Ce=n(),X=i("p"),gt=s("It\u2019s pretty straightforward. The output lools something like this. So these are the lines we need to read."),Be=n(),P=i("img"),ze=n(),Y=i("p"),St=s("Back in matlab, we can setup our serial connection to the arduino like this:"),Fe=n(),M=i("img"),Le=n(),Z=i("p"),jt=s("We need to parse the buffer to make sense of the encoded values. I used regexp to parse the \u201Ctime\u201D and \u201Ccount\u201D keywords. There must be a smarter way to read from the buffer, but I wanted to do it as fast as possible."),Ue=n(),O=i("img"),qe=n(),$=i("p"),Dt=s("After all this, we can see how fast the calls are."),Je=n(),ee=i("p"),he=i("code"),Gt=s("Median Duration IOPort = 0.59 [0.58, 0.59] ms"),Ve=n(),g=i("img"),Ke=n(),te=i("p"),Ht=s("This is a huge speed up! We went from 8ms to 0.5ms and we are getting the correct encoder values. However, useing this approach, we miss a fraction of the samples because the buffer is only partially full and the keywords can be missed. I haven\u2019t fully debugged how to improve this yet, but now we can read from the treadmill online without dropping frames."),Ne=n(),y=i("p"),Wt=s("The "),B=i("a"),Ct=s("treadmill code"),Bt=s(" I wrote is available on my github and the "),z=i("a"),zt=s("arduino sketch"),Ft=s(" is available as well."),this.h()},l(e){b=l(e,"P",{});var o=f(b);Re=u(o,"I recently had to setup an experimental rig with an interface between Matlab and an Arduino. The goal of the interface was to read out the position of a treadmill using a rotary encoder. This must be a pretty common situation in neuroscience these days, but my first foray into setting it up (through the official "),D=l(o,"A",{href:!0,rel:!0});var $t=f(D);Xe=u($t,"matlab arduino toolbox"),$t.forEach(t),Ye=u(o,") was way too slow for any reasonable experiment. I figured I\u2019d write up my notes on the process here. If you know a better way to do this, please email or message me!"),o.forEach(t),de=p(e),G=l(e,"H3",{id:!0});var eo=f(G);Ze=u(eo,"Approach 1: Matlab arduino toolbox"),eo.forEach(t),ce=p(e),F=l(e,"P",{});var to=f(F);$e=u(to,"The matlab toolbox is pretty easy to use. We need a rotary encoder to read out the turns of the treadmill, and that\u2019s already built in as toolbox (again, figure this is a pretty common task). The code to connect and setup the rotary encoder look like this:"),to.forEach(t),be=p(e),v=l(e,"IMG",{src:!0,alt:!0,style:!0}),we=p(e),L=l(e,"P",{});var oo=f(L);et=u(oo,"The encoder uses digital inputs 2 and 3."),oo.forEach(t),ye=p(e),U=l(e,"P",{});var ao=f(U);tt=u(ao,"Great. Simple enough. But is it fast enough? Our experiment code runs visual stimuli at 120 or 240Hz. That means we have to complete all analyses of behavior within ~7 or ~3.5 ms before we absolutely have to draw the stimuli. These numbers shrink if the stimuli are really complicated. All time matters (e.g., communicating with the syringe pump to send reward takes ~0.5 ms)."),ao.forEach(t),ve=p(e),q=l(e,"P",{});var ro=f(q);ot=u(ro,"To compute the arduino toolbox call time, I just ran the main call 1000 times in a for loop and measured the elapsed time. The code looks like this:"),ro.forEach(t),_e=p(e),_=l(e,"IMG",{src:!0,alt:!0,style:!0}),ke=p(e),J=l(e,"P",{});var io=f(J);at=u(io,"Pretty straightforward. And the output?"),io.forEach(t),Ie=p(e),V=l(e,"P",{});var lo=f(V);re=l(lo,"CODE",{});var so=f(re);rt=u(so,"Median Duration Arduino Toolbox = 8.07 [7.89, 8.23] ms"),so.forEach(t),lo.forEach(t),xe=p(e),k=l(e,"IMG",{src:!0,alt:!0,style:!0}),Ee=p(e),K=l(e,"P",{});var uo=f(K);it=u(uo,"This just won\u2019t work. Matlab hangs for ~8ms each time the toolbox calls. At that rate, we\u2019d drop every single frame of the experiment. This would be possible at a 60Hz refresh rate, but that\u2019s just too slow for reasonable motion stimuli. I searched the Mathworks forums and Arduino forums and there\u2019s a lot of chatter about how slow this is, but also a lot of insistance that \u201Cthis is just how fast you can run over USB\u201D. That can\u2019t be right. And it isn\u2019t. There\u2019s a faster way\u2026"),uo.forEach(t),Te=p(e),H=l(e,"H3",{id:!0});var fo=f(H);lt=u(fo,"Approach 2: IOPort serial connection"),fo.forEach(t),Ae=p(e),I=l(e,"P",{});var me=f(I);W=l(me,"A",{href:!0,rel:!0});var no=f(W);st=u(no,"Psychtoolbox"),no.forEach(t),ut=u(me," has a mex function called "),C=l(me,"A",{href:!0,rel:!0});var po=f(C);ft=u(po,"IOPort"),po.forEach(t),nt=u(me," that supports connections over a serial port (which can work over USB, of course). This means we\u2019d need to run all rotary encoding on the Arduino as a sketch and only use Matlab to communicate to a serial buffer."),me.forEach(t),Pe=p(e),N=l(e,"P",{});var ho=f(N);pt=u(ho,"Arduino sketches are easy enough to write and you can find plenty of code snippets online. Here\u2019s the steps of the code I\u2019m using. I based it off a snippet I got from Jack Liska in Huklab."),ho.forEach(t),Me=p(e),d=l(e,"P",{});var S=f(d);ht=u(S,"The code sketch has 4 parts: "),ie=l(S,"CODE",{});var mo=f(ie);mt=u(mo,"variable declaration"),mo.forEach(t),dt=u(S,", "),le=l(S,"CODE",{});var co=f(le);ct=u(co,"setup"),co.forEach(t),bt=u(S,", "),se=l(S,"CODE",{});var bo=f(se);wt=u(bo,"main loop"),bo.forEach(t),yt=u(S,", and "),ue=l(S,"CODE",{});var wo=f(ue);vt=u(wo,"rotary encoder function"),wo.forEach(t),S.forEach(t),Oe=p(e),w=l(e,"P",{});var oe=f(w);_t=u(oe,"We use the "),fe=l(oe,"CODE",{});var yo=f(fe);kt=u(yo,"digitalWriteFast"),yo.forEach(t),It=u(oe," library which supposedly offers substantial speedup over the default "),ne=l(oe,"CODE",{});var vo=f(ne);xt=u(vo,"digitalWrite"),vo.forEach(t),Et=u(oe," function in the default Arduino library. All variables are setup here:"),oe.forEach(t),ge=p(e),x=l(e,"IMG",{src:!0,alt:!0,style:!0}),Se=p(e),Q=l(e,"P",{});var _o=f(Q);Tt=u(_o,"Then we setup the serial buffer and initialize the encoder pins. The rotary encoder operates as an interrupt that responds to the rising edge of the digital inputs."),_o.forEach(t),je=p(e),E=l(e,"IMG",{src:!0,alt:!0,style:!0}),De=p(e),j=l(e,"P",{});var Qe=f(j);At=u(Qe,"The main loop just dumps the current time and encoder count to the serial buffer. It also listens for a \u201Creset\u201D command to reset the counter, which is necessary so that our count doesn\u2019t exceed the bitdepth of the "),pe=l(Qe,"CODE",{});var ko=f(pe);Pt=u(ko,"long"),ko.forEach(t),Mt=u(Qe," type we\u2019re storing them as."),Qe.forEach(t),Ge=p(e),T=l(e,"IMG",{src:!0,alt:!0,style:!0}),He=p(e),R=l(e,"P",{});var Io=f(R);Ot=u(Io,"The loop depends on the encoder to detect digital ins and count them."),Io.forEach(t),We=p(e),A=l(e,"IMG",{src:!0,alt:!0,style:!0}),Ce=p(e),X=l(e,"P",{});var xo=f(X);gt=u(xo,"It\u2019s pretty straightforward. The output lools something like this. So these are the lines we need to read."),xo.forEach(t),Be=p(e),P=l(e,"IMG",{src:!0,alt:!0,style:!0}),ze=p(e),Y=l(e,"P",{});var Eo=f(Y);St=u(Eo,"Back in matlab, we can setup our serial connection to the arduino like this:"),Eo.forEach(t),Fe=p(e),M=l(e,"IMG",{src:!0,alt:!0,style:!0}),Le=p(e),Z=l(e,"P",{});var To=f(Z);jt=u(To,"We need to parse the buffer to make sense of the encoded values. I used regexp to parse the \u201Ctime\u201D and \u201Ccount\u201D keywords. There must be a smarter way to read from the buffer, but I wanted to do it as fast as possible."),To.forEach(t),Ue=p(e),O=l(e,"IMG",{src:!0,alt:!0,style:!0}),qe=p(e),$=l(e,"P",{});var Ao=f($);Dt=u(Ao,"After all this, we can see how fast the calls are."),Ao.forEach(t),Je=p(e),ee=l(e,"P",{});var Po=f(ee);he=l(Po,"CODE",{});var Mo=f(he);Gt=u(Mo,"Median Duration IOPort = 0.59 [0.58, 0.59] ms"),Mo.forEach(t),Po.forEach(t),Ve=p(e),g=l(e,"IMG",{src:!0,alt:!0,style:!0}),Ke=p(e),te=l(e,"P",{});var Oo=f(te);Ht=u(Oo,"This is a huge speed up! We went from 8ms to 0.5ms and we are getting the correct encoder values. However, useing this approach, we miss a fraction of the samples because the buffer is only partially full and the keywords can be missed. I haven\u2019t fully debugged how to improve this yet, but now we can read from the treadmill online without dropping frames."),Oo.forEach(t),Ne=p(e),y=l(e,"P",{});var ae=f(y);Wt=u(ae,"The "),B=l(ae,"A",{href:!0,rel:!0});var go=f(B);Ct=u(go,"treadmill code"),go.forEach(t),Bt=u(ae," I wrote is available on my github and the "),z=l(ae,"A",{href:!0,rel:!0});var So=f(z);zt=u(So,"arduino sketch"),So.forEach(t),Ft=u(ae," is available as well."),ae.forEach(t),this.h()},h(){h(D,"href","https://www.mathworks.com/hardware-support/arduino-matlab.html"),h(D,"rel","nofollow"),h(G,"id","approach-1-matlab-arduino-toolbox"),c(v.src,Ut="/arduinoblog/fig02_open.png")||h(v,"src",Ut),h(v,"alt","Connect to the Arduino"),m(v,"max-width","40em"),m(v,"width","100%"),c(_.src,qt="/arduinoblog/fig03_loop.png")||h(_,"src",qt),h(_,"alt","Loop calls to rotary encoder"),m(_,"max-width","40em"),m(_,"width","100%"),c(k.src,Jt="/arduinoblog/fig04_summary.png")||h(k,"src",Jt),h(k,"alt","Arduino toolbox call time"),m(k,"max-width","30em"),m(k,"width","100%"),h(H,"id","approach-2-ioport-serial-connection"),h(W,"href","http://psychtoolbox.org"),h(W,"rel","nofollow"),h(C,"href","http://psychtoolbox.org/docs/IOPort"),h(C,"rel","nofollow"),c(x.src,Vt="/arduinoblog/fig05_libvar.png")||h(x,"src",Vt),h(x,"alt","Sketch libraries and variables"),m(x,"max-width","40em"),m(x,"width","100%"),c(E.src,Kt="/arduinoblog/fig06_setup.png")||h(E,"src",Kt),h(E,"alt","Sketch setup"),m(E,"max-width","40em"),m(E,"width","100%"),c(T.src,Nt="/arduinoblog/fig07_loop.png")||h(T,"src",Nt),h(T,"alt","Sketch main loop"),m(T,"max-width","40em"),m(T,"width","100%"),c(A.src,Qt="/arduinoblog/fig08_encoder.png")||h(A,"src",Qt),h(A,"alt","Sketch encoder"),m(A,"max-width","40em"),m(A,"width","100%"),c(P.src,Rt="/arduinoblog/fig09_outpu.png")||h(P,"src",Rt),h(P,"alt","Sketch serial buffer output"),m(P,"max-width","20em"),m(P,"width","100%"),c(M.src,Xt="/arduinoblog/fig11_approach2mat.png")||h(M,"src",Xt),h(M,"alt","IOPort connection"),m(M,"max-width","40em"),m(M,"width","100%"),c(O.src,Yt="/arduinoblog/fig12_approach2matloop.png")||h(O,"src",Yt),h(O,"alt","IOPort read and loop"),m(O,"max-width","40em"),m(O,"width","100%"),c(g.src,Zt="/arduinoblog/fig10_summary.png")||h(g,"src",Zt),h(g,"alt","IOPort read speed"),m(g,"max-width","30em"),m(g,"width","100%"),h(B,"href","https://github.com/jcbyts/MarmoV5/blob/master/%2Bmarmoview/treadmill_arduino.m"),h(B,"rel","nofollow"),h(z,"href","https://github.com/jcbyts/MarmoV5/blob/master/SupportFunctions/sketch_rotary_serial.ino"),h(z,"rel","nofollow")},m(e,o){a(e,b,o),r(b,Re),r(b,D),r(D,Xe),r(b,Ye),a(e,de,o),a(e,G,o),r(G,Ze),a(e,ce,o),a(e,F,o),r(F,$e),a(e,be,o),a(e,v,o),a(e,we,o),a(e,L,o),r(L,et),a(e,ye,o),a(e,U,o),r(U,tt),a(e,ve,o),a(e,q,o),r(q,ot),a(e,_e,o),a(e,_,o),a(e,ke,o),a(e,J,o),r(J,at),a(e,Ie,o),a(e,V,o),r(V,re),r(re,rt),a(e,xe,o),a(e,k,o),a(e,Ee,o),a(e,K,o),r(K,it),a(e,Te,o),a(e,H,o),r(H,lt),a(e,Ae,o),a(e,I,o),r(I,W),r(W,st),r(I,ut),r(I,C),r(C,ft),r(I,nt),a(e,Pe,o),a(e,N,o),r(N,pt),a(e,Me,o),a(e,d,o),r(d,ht),r(d,ie),r(ie,mt),r(d,dt),r(d,le),r(le,ct),r(d,bt),r(d,se),r(se,wt),r(d,yt),r(d,ue),r(ue,vt),a(e,Oe,o),a(e,w,o),r(w,_t),r(w,fe),r(fe,kt),r(w,It),r(w,ne),r(ne,xt),r(w,Et),a(e,ge,o),a(e,x,o),a(e,Se,o),a(e,Q,o),r(Q,Tt),a(e,je,o),a(e,E,o),a(e,De,o),a(e,j,o),r(j,At),r(j,pe),r(pe,Pt),r(j,Mt),a(e,Ge,o),a(e,T,o),a(e,He,o),a(e,R,o),r(R,Ot),a(e,We,o),a(e,A,o),a(e,Ce,o),a(e,X,o),r(X,gt),a(e,Be,o),a(e,P,o),a(e,ze,o),a(e,Y,o),r(Y,St),a(e,Fe,o),a(e,M,o),a(e,Le,o),a(e,Z,o),r(Z,jt),a(e,Ue,o),a(e,O,o),a(e,qe,o),a(e,$,o),r($,Dt),a(e,Je,o),a(e,ee,o),r(ee,he),r(he,Gt),a(e,Ve,o),a(e,g,o),a(e,Ke,o),a(e,te,o),r(te,Ht),a(e,Ne,o),a(e,y,o),r(y,Wt),r(y,B),r(B,Ct),r(y,Bt),r(y,z),r(z,zt),r(y,Ft)},p:Lt,i:Lt,o:Lt,d(e){e&&t(b),e&&t(de),e&&t(G),e&&t(ce),e&&t(F),e&&t(be),e&&t(v),e&&t(we),e&&t(L),e&&t(ye),e&&t(U),e&&t(ve),e&&t(q),e&&t(_e),e&&t(_),e&&t(ke),e&&t(J),e&&t(Ie),e&&t(V),e&&t(xe),e&&t(k),e&&t(Ee),e&&t(K),e&&t(Te),e&&t(H),e&&t(Ae),e&&t(I),e&&t(Pe),e&&t(N),e&&t(Me),e&&t(d),e&&t(Oe),e&&t(w),e&&t(ge),e&&t(x),e&&t(Se),e&&t(Q),e&&t(je),e&&t(E),e&&t(De),e&&t(j),e&&t(Ge),e&&t(T),e&&t(He),e&&t(R),e&&t(We),e&&t(A),e&&t(Ce),e&&t(X),e&&t(Be),e&&t(P),e&&t(ze),e&&t(Y),e&&t(Fe),e&&t(M),e&&t(Le),e&&t(Z),e&&t(Ue),e&&t(O),e&&t(qe),e&&t($),e&&t(Je),e&&t(ee),e&&t(Ve),e&&t(g),e&&t(Ke),e&&t(te),e&&t(Ne),e&&t(y)}}}const Bo={title:"A Fast(er) interface for Arduino from Matlab",date:"2021-5-10",description:"Major speedup for Arduino through serial buffer and IOPort"};class zo extends Do{constructor(b){super();Go(this,b,null,Wo,Ho,{})}}export{zo as default,Bo as metadata};
