var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m3 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m3) {
    return;
  }
  const match = m3[2] || m3[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m4, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m3 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m3) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser2 = new MultipartParser(m3[1] || m3[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser2.onPartBegin = function() {
    parser2.onPartData = onPartData;
    parser2.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser2.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser2.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser2.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m4 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m4) {
        entryName = m4[2] || m4[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser2.onPartData = appendToFile;
        parser2.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser2.write(chunk);
  }
  parser2.end();
  return formData;
}
var import_node_fs, import_node_path, import_node_worker_threads, import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    init_shims();
    import_node_fs = __toModule(require("node:fs"));
    import_node_path = __toModule(require("node:path"));
    import_node_worker_threads = __toModule(require("node:worker_threads"));
    init_install_fetch();
    import_node_http = __toModule(require("node:http"));
    import_node_https = __toModule(require("node:https"));
    import_node_zlib = __toModule(require("node:zlib"));
    import_node_stream = __toModule(require("node:stream"));
    import_node_util = __toModule(require("node:util"));
    import_node_url = __toModule(require("node:url"));
    import_net = __toModule(require("net"));
    globalThis.DOMException || (() => {
      const port = new import_node_worker_threads.MessageChannel().port1;
      const ab4 = new ArrayBuffer(0);
      try {
        port.postMessage(ab4, [ab4, ab4]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c5) => c5 | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index: index3, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c5;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start2, end, ui8a) => {
          if (start2 === void 0 || start2 !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start2, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c5 = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index3 === boundary.length - 2) {
                if (c5 === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c5 !== CR) {
                  return;
                }
                index3++;
                break;
              } else if (index3 - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c5 === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c5 === LF) {
                  index3 = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c5 !== boundary[index3 + 2]) {
                index3 = -2;
              }
              if (c5 === boundary[index3 + 2]) {
                index3++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index3 = 0;
            case S.HEADER_FIELD:
              if (c5 === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index3++;
              if (c5 === HYPHEN) {
                break;
              }
              if (c5 === COLON) {
                if (index3 === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c5);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c5 === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c5 === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c5 !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c5 !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index3;
              if (index3 === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c5 = data[i2];
              }
              if (index3 < boundary.length) {
                if (boundary[index3] === c5) {
                  if (index3 === 0) {
                    dataCallback("onPartData", true);
                  }
                  index3++;
                } else {
                  index3 = 0;
                }
              } else if (index3 === boundary.length) {
                index3++;
                if (c5 === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c5 === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index3 = 0;
                }
              } else if (index3 - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index3 = 0;
                  if (c5 === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c5 === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index3 = 0;
                  }
                } else {
                  index3 = 0;
                }
              }
              if (index3 > 0) {
                lookbehind[index3 - 1] = c5;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index3;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type2 = meta[0] || "text/plain";
  let typeFull = type2;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type2;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B3 = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c5 = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v2, n) => typeof v2 == "string" ? c5.push(p + e(n) + `"\r
\r
${v2.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c5.push(p + e(n) + `"; filename="${e(v2.name, 1)}"\r
Content-Type: ${v2.type || "application/octet-stream"}\r
\r
`, v2, "\r\n"));
  c5.push(`--${b}--`);
  return new B3(c5, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream2.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c5) => typeof c5 === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index3, array4) => {
    if (index3 % 2 === 0) {
      result.push(array4.slice(index3, index3 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net2.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options: options2 } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https2.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s4) => {
        let endedWithEventsCount;
        s4.prependListener("end", () => {
          endedWithEventsCount = s4._eventsCount;
        });
        s4.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s4._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib2.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib2.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflate(), reject) : (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_node_http2, import_node_https2, import_node_zlib2, import_node_stream2, import_node_util2, import_node_url2, import_net2, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob2, Blob$1, _File, File, t, i, h, r, m, f2, e, x, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_node_http2 = __toModule(require("node:http"));
    import_node_https2 = __toModule(require("node:https"));
    import_node_zlib2 = __toModule(require("node:zlib"));
    import_node_stream2 = __toModule(require("node:stream"));
    import_node_util2 = __toModule(require("node:util"));
    import_node_url2 = __toModule(require("node:url"));
    import_net2 = __toModule(require("net"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop6() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x5) {
          return typeof x5 === "object" && x5 !== null || typeof x5 === "function";
        }
        const rethrowAssertionErrorRejection = noop6;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x5) {
          return typeof x5 === "number" && isFinite(x5);
        };
        const MathTrunc = Math.trunc || function(v2) {
          return v2 < 0 ? Math.ceil(v2) : Math.floor(v2);
        };
        function isDictionary(x5) {
          return typeof x5 === "object" || typeof x5 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x5, context) {
          if (typeof x5 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x5) {
          return typeof x5 === "object" && x5 !== null || typeof x5 === "function";
        }
        function assertObject(x5, context) {
          if (!isObject(x5)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x5, position, context) {
          if (x5 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x5, field, context) {
          if (x5 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x5) {
          return x5 === 0 ? 0 : x5;
        }
        function integerPart(x5) {
          return censorNegativeZero(MathTrunc(x5));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x5 = Number(value);
          x5 = censorNegativeZero(x5);
          if (!NumberIsFinite(x5)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x5 = integerPart(x5);
          if (x5 < lowerBound || x5 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x5) || x5 === 0) {
            return 0;
          }
          return x5;
        }
        function assertReadableStream(x5, context) {
          if (!IsReadableStream(x5)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e3) => rejectPromise(e3)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_readRequests")) {
            return false;
          }
          return x5 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x5._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x5) {
          return x5 !== x5;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length3 = end - begin;
          const slice5 = new ArrayBuffer(length3);
          CopyDataBlockBytes(slice5, 0, buffer, begin, length3);
          return slice5;
        }
        function IsNonNegativeNumber(v2) {
          if (typeof v2 !== "number") {
            return false;
          }
          if (NumberIsNaN(v2)) {
            return false;
          }
          if (v2 < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair2 = container._queue.shift();
          container._queueTotalSize -= pair2.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair2.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair2 = container._queue.peek();
          return pair2.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e3 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e3);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_controlledReadableByteStream")) {
            return false;
          }
          return x5 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x5 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e3) => {
            ReadableByteStreamControllerError(controller, e3);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e3);
              readIntoRequest._errorSteps(e3);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e3);
              throw e3;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e3) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e3);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e3) => rejectPromise(e3)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_readIntoRequests")) {
            return false;
          }
          return x5 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          const size = init3 === null || init3 === void 0 ? void 0 : init3.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type2 = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start2, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type: type2
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x5, context) {
          if (!IsWritableStream(x5)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type2 = underlyingSink.type;
            if (type2 !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_writableStreamController")) {
            return false;
          }
          return x5 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_ownerWritableStream")) {
            return false;
          }
          return x5 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e3 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e3);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_controlledWritableStream")) {
            return false;
          }
          return x5 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop6);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e3 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e3);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_controlledReadableStream")) {
            return false;
          }
          return x5 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e3) => {
            ReadableStreamDefaultControllerError(controller, e3);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e3) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e3);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type2 = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start2, original, `${context} has member 'start' that`),
            type: type2 === void 0 ? void 0 : convertReadableStreamType(type2, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type2, context) {
          type2 = `${type2}`;
          if (type2 !== "bytes") {
            throw new TypeError(`${context} '${type2}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type2;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode2 = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode2 === void 0 ? void 0 : convertReadableStreamReaderMode(mode2, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode2, context) {
          mode2 = `${mode2}`;
          if (mode2 !== "byob") {
            throw new TypeError(`${context} '${mode2}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode2;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair2, context) {
          assertDictionary(pair2, context);
          const readable = pair2 === null || pair2 === void 0 ? void 0 : pair2.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable3 = pair2 === null || pair2 === void 0 ? void 0 : pair2.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform2 = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform2.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform2.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform2.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e3) {
              return promiseRejectedWith(e3);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_readableStreamController")) {
            return false;
          }
          return x5 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop6);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e3) {
          stream._state = "errored";
          stream._storedError = e3;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e3);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e3);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e3);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x5 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x5 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const transform2 = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start2 === void 0 ? void 0 : convertTransformerStartCallback(start2, original, `${context} has member 'start' that`),
            transform: transform2 === void 0 ? void 0 : convertTransformerTransformCallback(transform2, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream2 {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer5 = convertTransformer(rawTransformer, "First parameter");
            if (transformer5.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer5.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer5);
            if (transformer5.start !== void 0) {
              startPromise_resolve(transformer5.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream2.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_transformStreamController")) {
            return false;
          }
          return x5 instanceof TransformStream2;
        }
        function TransformStreamError(stream, e3) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e3);
          TransformStreamErrorWritableAndUnblockWrite(stream, e3);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e3) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e3);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x5) {
          if (!typeIsObject(x5)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x5, "_controlledTransformStream")) {
            return false;
          }
          return x5 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer5) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer5.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer5.transform(chunk, controller);
          }
          if (transformer5.flush !== void 0) {
            flushAlgorithm = () => transformer5.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e3) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e3);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e3) {
          TransformStreamError(controller._controlledTransformStream, e3);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream2;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && typeof options2 !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options2 === null)
          options2 = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = encoder.encode(element);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        const type2 = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /^[\x20-\x7E]*$/.test(type2) ? type2 : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start2 = 0, end = this.size, type2 = "") {
        const { size } = this;
        let relativeStart = start2 < 0 ? Math.max(size + start2, 0) : Math.min(start2, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type2).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object2) {
        return object2 && typeof object2 === "object" && typeof object2.constructor === "function" && (typeof object2.stream === "function" || typeof object2.arrayBuffer === "function") && /^(Blob|File)$/.test(object2[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    _File = class File2 extends Blob$1 {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options2 = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options2);
        if (options2 === null)
          options2 = {};
        const lastModified = options2.lastModified === void 0 ? Date.now() : Number(options2.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a3, b, c5) => (a3 += "", /^(Blob|File)$/.test(b && b[t]) ? [(c5 = c5 !== void 0 ? c5 + "" : b[t] == "File" ? b.name : "blob", a3), b.name !== c5 || b[t] == "blob" ? new File([b], c5, b) : b] : [a3, b + ""]);
    e = (c5, f3) => (f3 ? c5 : c5.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a3, e3) => {
      if (a3.length < e3) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e3} arguments required, but only ${a3.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a3) {
        if (a3.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m3) => typeof o[m3] != "function");
      }
      append(...a3) {
        x("append", arguments, 2);
        this.#d.push(f2(...a3));
      }
      delete(a3) {
        x("delete", arguments, 1);
        a3 += "";
        this.#d = this.#d.filter(([b]) => b !== a3);
      }
      get(a3) {
        x("get", arguments, 1);
        a3 += "";
        for (var b = this.#d, l = b.length, c5 = 0; c5 < l; c5++)
          if (b[c5][0] === a3)
            return b[c5][1];
        return null;
      }
      getAll(a3, b) {
        x("getAll", arguments, 1);
        b = [];
        a3 += "";
        this.#d.forEach((c5) => c5[0] === a3 && b.push(c5[1]));
        return b;
      }
      has(a3) {
        x("has", arguments, 1);
        a3 += "";
        return this.#d.some((b) => b[0] === a3);
      }
      forEach(a3, b) {
        x("forEach", arguments, 1);
        for (var [c5, d] of this)
          a3.call(b, d, c5, this);
      }
      set(...a3) {
        x("set", arguments, 2);
        var b = [], c5 = true;
        a3 = f2(...a3);
        this.#d.forEach((d) => {
          d[0] === a3[0] ? c5 && (c5 = !b.push(a3)) : b.push(d);
        });
        c5 && b.push(a3);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a3] of this)
          yield a3;
      }
      *values() {
        for (var [, a3] of this)
          yield a3;
      }
    };
    FetchBaseError = class extends Error {
      constructor(message, type2) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type2;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type2, systemError) {
        super(message, type2);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object2) => {
      return typeof object2 === "object" && typeof object2.append === "function" && typeof object2.delete === "function" && typeof object2.get === "function" && typeof object2.getAll === "function" && typeof object2.has === "function" && typeof object2.set === "function" && typeof object2.sort === "function" && object2[NAME] === "URLSearchParams";
    };
    isBlob = (object2) => {
      return object2 && typeof object2 === "object" && typeof object2.arrayBuffer === "function" && typeof object2.type === "string" && typeof object2.stream === "function" && typeof object2.constructor === "function" && /^(Blob|File)$/.test(object2[NAME]);
    };
    isAbortSignal = (object2) => {
      return typeof object2 === "object" && (object2[NAME] === "AbortSignal" || object2[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util2.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream2.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream2.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream2.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream2.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util2.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream2.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream2.PassThrough({ highWaterMark });
        p2 = new import_node_stream2.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util2.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util2.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream2.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http2.default.validateHeaderName === "function" ? import_node_http2.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http2.default.validateHeaderValue === "function" ? import_node_http2.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init3) {
        let result = [];
        if (init3 instanceof Headers) {
          const raw = init3.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init3 == null)
          ;
        else if (typeof init3 === "object" && !import_node_util2.types.isBoxedPrimitive(init3)) {
          const method = init3[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init3));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init3].map((pair2) => {
              if (typeof pair2 !== "object" || import_node_util2.types.isBoxedPrimitive(pair2)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair2];
            }).map((pair2) => {
              if (pair2.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair2];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object2) => {
      return typeof object2 === "object" && typeof object2[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init3 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init3.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init3.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init3.body ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init3.size || input.size || 0
        });
        const headers = new Headers(init3.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init3) {
          signal = init3.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init3.referrer == null ? input.referrer : init3.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init3.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init3.follow;
        this.compress = init3.compress === void 0 ? input.compress === void 0 ? true : input.compress : init3.compress;
        this.counter = init3.counter || input.counter || 0;
        this.agent = init3.agent || input.agent;
        this.highWaterMark = init3.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init3.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init3.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url2.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options2 = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options: options2
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type2 = "aborted") {
        super(message, type2);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/@sveltejs/kit/dist/chunks/url.js
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function resolve(base2, path2) {
  if (scheme.test(path2))
    return path2;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path2);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path2.slice(path_match[0].length).split("/") : path2.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path2) {
  return path2[0] === "/" && path2[1] !== "/";
}
var absolute, scheme;
var init_url = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/url.js"() {
    init_shims();
    absolute = /^([a-z]+:)?\/?\//;
    scheme = /^[a-z]+:/;
  }
});

// node_modules/@sveltejs/kit/dist/chunks/error.js
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var init_error = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/error.js"() {
    init_shims();
  }
});

// node_modules/@sveltejs/kit/dist/ssr.js
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s4) {
  return typeof s4 === "string" || s4 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type2] = content_type.split(";");
  return type2 === "text/plain" || type2 === "application/json" || type2 === "application/x-www-form-urlencoded" || type2 === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type2 = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type2);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type2 || type2.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type2 = getType(thing);
      switch (type2) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a3, b) {
    return b[1] - a3[1];
  }).forEach(function(entry, i2) {
    names.set(entry[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type2 = getType(thing);
    switch (type2) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v2, i2) {
          return i2 in thing ? stringify(v2) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type2 + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type2 = getType(thing);
      switch (type2) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v2, i2) {
            statements_1.push(name + "[" + i2 + "]=" + stringify(v2));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v2) {
            return "add(" + stringify(v2) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k2 = _a[0], v2 = _a[1];
            return "set(" + stringify(k2) + ", " + stringify(v2) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c5) {
  return escaped[c5] || c5;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop2() {
}
function safe_not_equal(a3, b) {
  return a3 != a3 ? b == b : a3 !== b || (a3 && typeof a3 === "object" || typeof a3 === "function");
}
function writable(value, start2 = noop2) {
  let stop;
  const subscribers = new Set();
  function set4(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set4(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set4) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set4, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i2 = value.length;
  if (typeof value === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function escape_json_string_in_html(str) {
  return escape(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
function escape_html_attr(str) {
  return '"' + escape(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape(str, dict, unicode_encoder) {
  let result = "";
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    const char = str.charAt(i2);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i2];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page
}) {
  const css5 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css5.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css5).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init3 = "";
  if (options2.amp) {
    init3 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
    init3 += options2.service_worker ? '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>' : "";
  } else if (include_js) {
    init3 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${page && page.path ? try_serialize(page.path, (error3) => {
      throw new Error(`Failed to serialize page.path: ${error3.message}`);
    }) : null},
						query: new URLSearchParams(${page && page.query ? s$1(page.query.toString()) : ""}),
						params: ${page && page.params ? try_serialize(page.params, (error3) => {
      throw new Error(`Failed to serialize page.params: ${error3.message}`);
    }) : null}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init3 += options2.amp ? `<amp-install-serviceworker src="${options2.service_worker}" layout="nodisplay"></amp-install-serviceworker>` : `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init3
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const prefix = options2.paths.assets || options2.paths.base;
        const filename = (resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (is_root_relative(resolved)) {
          const relative = resolved;
          const headers = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, _receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s2(response2.statusText)},"headers":${s2(headers)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id2) => id2 ? options2.load_component(id2) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {}
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i2 === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e3 = coalesce_to_error(err);
            options2.handle_error(e3, request);
            status = 500;
            error2 = e3;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const error_node = await options2.load_component(route.b[i2]);
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e3 = coalesce_to_error(err);
                  options2.handle_error(e3, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map4 = new Map();
  return {
    append(key, value) {
      if (map4.has(key)) {
        (map4.get(key) || []).push(value);
      } else {
        map4.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map4)
  };
}
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type2, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type2) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path2 = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path2 + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                let if_none_match_value = request2.headers["if-none-match"];
                if (if_none_match_value?.startsWith('W/"')) {
                  if_none_match_value = if_none_match_value.substring(2);
                }
                const etag = `"${hash(response.body || "")}"`;
                if (if_none_match_value === etag) {
                  return {
                    status: 304,
                    headers: {}
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e3 = coalesce_to_error(err);
    options2.handle_error(e3, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e3.stack : e3.message
    };
  }
}
var chars, unsafeChars, reserved, escaped, objectProtoOwnPropertyNames, subscriber_queue, escape_json_string_in_html_dict, escape_html_attr_dict, s$1, s2, ReadOnlyFormData;
var init_ssr = __esm({
  "node_modules/@sveltejs/kit/dist/ssr.js"() {
    init_shims();
    init_url();
    init_error();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    escaped = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    Promise.resolve();
    subscriber_queue = [];
    escape_json_string_in_html_dict = {
      '"': '\\"',
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    escape_html_attr_dict = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    s$1 = JSON.stringify;
    s2 = JSON.stringify;
    ReadOnlyFormData = class {
      #map;
      constructor(map4) {
        this.#map = map4;
      }
      get(key) {
        const value = this.#map.get(key);
        return value && value[0];
      }
      getAll(key) {
        return this.#map.get(key);
      }
      has(key) {
        return this.#map.has(key);
      }
      *[Symbol.iterator]() {
        for (const [key, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield [key, value[i2]];
          }
        }
      }
      *entries() {
        for (const [key, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield [key, value[i2]];
          }
        }
      }
      *keys() {
        for (const [key] of this.#map)
          yield key;
      }
      *values() {
        for (const [, value] of this.#map) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            yield value[i2];
          }
        }
      }
    };
  }
});

// .svelte-kit/output/server/chunks/sitemap.xml-0197c0cd.js
var sitemap_xml_0197c0cd_exports = {};
__markAsModule(sitemap_xml_0197c0cd_exports);
var init_sitemap_xml_0197c0cd = __esm({
  ".svelte-kit/output/server/chunks/sitemap.xml-0197c0cd.js"() {
    init_shims();
  }
});

// .svelte-kit/output/server/chunks/foodservice-academia-299db3c9.js
var foodservice_academia_299db3c9_exports = {};
__export(foodservice_academia_299db3c9_exports, {
  default: () => Foodservice_academia,
  metadata: () => metadata
});
var metadata, Foodservice_academia;
var init_foodservice_academia_299db3c9 = __esm({
  ".svelte-kit/output/server/chunks/foodservice-academia-299db3c9.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    metadata = {
      "title": "Moving from food service to academia",
      "date": "2021-5-5",
      "description": "Thoughts on what academia can learn from food service to improve its culture",
      "draft": true
    };
    Foodservice_academia = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<p>Before I went to graduate school to study Neuroscience, I was a bartender in a pub for two years. This is definitely not the most typical route to graduate school, and now, over 10 years later, it seems like a good time to reflect on the culture shock I felt when I entered graduate school and started working in labs.</p>
<p>Disclaimer: These thoughts are not meant to diminish the many problems with the food service culture. But I am not going to focus on them at all. They have been detailed here, here, and here, if you are so inclined to get that perspective. These are my own thoughts and are by no means a definiteive take on anything. Just one person\u2019s exprience.</p>
<p>I remember noting once when stocking kegs \u2013 essentially a manual game of tetris with 40lb barrels \u2013 that if future me ever missed the kegroom, I\u2019d have made some poor life choices. I think I was being hyperbolic with myself then, but sure enough, at several points since I started in academia, I\u2019ve missed even that part of bar life. But most of all, I miss the people. I miss the sense of belonging and acceptance. In a strange way, I miss a feeling of security that I haven\u2019t had since. My time in food service was the last time I experienced any real diversity. My coworkers were from all walks of life, all colors, creeds, and had goals and aspirations that were as diverse as their backgrounds. This last bit is really the part that is the most striking contrast. Regardless of what they looked like, they were all individuals. In contrast, for the most part everyone I know in academia is some form of the same: wants to be a PI some day (or doesn\u2019t but can\u2019t come up with a good alternative), insecure (about their futures, their status, whether they\u2019re smart enough), struggles to navigate a culture where an extreme imbalance of power gives their mentors (who may only be 5 years older than them) the reigns of their careers. People in academia (again, for the most part) know nothing else. They\u2019ve been in school their whole lives. They have worked hard their whole lives. They are burnt out in a way no one I met in food service ever was. So, is there something academia can learn from food service? Maybe. That\u2019s what this blog post is about: Me reflecting on some of the positive aspects of food service in the hopes it can help me find ways to improve the culture in academia.</p>
<p>Positive things about food service:</p>
<ol><li><p>Work-life balance
This is an easy one. Almost no one I met in food service wanted a lifelong career in food service. They were writers, musicians, artists, actors, \u2026 creatives. They had passions outside of work that were in no way connected to service. They worked in food service</p></li>
<li><p>Tolerance - Everyone is welcome.
There\u2019s an age old argument about who is the best or worst tippers. This is often a racist argument, but the true answer is really simple: The best tippers (by far) are people who worked in food service. Okay, but how can you tell who worked in food service? Well, one common giveaway is tattoos. If you see someone with a full sleeve, chances they have at some point worked in food service.</p></li>
<li><p>Forgiveness - a culture where you can call out other people.</p></li>
<li><p>Extreme support of a work-life balance</p></li>
<li><p>Focus on the present - in the moment. This shift. Make it work. Strategi</p></li>
<li><p>Security - you\u2019re not going to get kicked out if you don\u2019t become the manager</p></li>
<li></li>
<li><p>Tolerance
It\u2019s true that food service is</p></li></ol>`;
    });
  }
});

// .svelte-kit/output/server/chunks/lurz-paper-8ed14628.js
var lurz_paper_8ed14628_exports = {};
__export(lurz_paper_8ed14628_exports, {
  default: () => Lurz_paper,
  metadata: () => metadata2
});
var metadata2, Lurz_paper;
var init_lurz_paper_8ed14628 = __esm({
  ".svelte-kit/output/server/chunks/lurz-paper-8ed14628.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    metadata2 = {
      "title": "Generalization in data-driven models of primary visual cortex",
      "date": "2020-12-4",
      "description": "Discussion of Lurz et al., 2020 and tricks for learning deep stimulus models from neural data"
    };
    Lurz_paper = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<blockquote><p>This is entry is the first in a <strong>journal club</strong> series, where I do a deep dive into a paper I\u2019ve recently gone over in a journal club or lab meeting.</p></blockquote>
<p>Today we\u2019re discussing <a href="${"https://www.biorxiv.org/content/10.1101/2020.10.05.326256v1"}" rel="${"nofollow"}">Lurz et al., 2020</a> from Fabian Sinz and colleagues. In it, they introduce a few new tricks for fitting CNNs end-to-end to neural data. <em>Then they show their data-driven model generalizes to predict the responses of neurons that it wasn\u2019t trained on (in animals that were not part of the training set!)</em></p>
<p>The main points of interest for me were:</p>
<ul><li>General conceptualization of \u201Creadout\u201D and \u201Ccore\u201D</li>
<li>\u201CTricks\u201D for learning the readout</li>
<li>Generalization performance</li></ul>
<h2 id="${"readout-and-core"}">\u201CReadout\u201D and \u201CCore\u201D</h2>
<p>Many groups have now presented advantages to thinking of neural population activity as resulting from shared computations with neuron-specific weights. Rather than optimize a model that predicts the responses of each neuron, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8879999999999999em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">r</span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8879999999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">i</span><span class="${"mclose mtight"}">)</span></span></span></span></span></span></span></span></span></span></span></span></span>, given the stimulus, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">x</span></span></span></span></span>, assume that each neuron operates with an affine transformation (\u201Creadout\u201D) of a core stimulus processing model that is shared by all neurons.</p>
<p>The simplest versions of this have a single linear filter as the core. For example, <a href="${"https://openreview.net/pdf?id=HkEI22jeg"}" rel="${"nofollow"}">Batty et al., 2017</a> used knowledge of the cell class to group retinal ganglion cells and learn a single space-time linear filter for all neurons of the same class. Their \u201Cmultitask LN\u201D model has a single filter for all On-RGCs and each neuron simply scales that filter\u2019s response with a neuron specific gain and offset term and then passes that through a sigmoid nonlinearity.</p>
<img src="${"/labmeetinglurz/battymultitaskln.png"}" style="${"max-width: 50em"}" alt="${"diagram"}">
<p>I really like the terms <strong>\u201Ccore\u201D</strong> and <strong>\u201Creadout\u201D</strong> and think they should be adopted as the standard nomenclature for such a model. In the figure above, the <span style="${"color:blue"}">blue parameters</span> (<span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.83333em;vertical-align:-0.15em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.13889em;"}">W</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.2805559999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">t</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.83333em;vertical-align:-0.15em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.13889em;"}">W</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.151392em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">s</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span>) are shared by all On-RGCs and form the <strong>\u201Ccore\u201D</strong>. The <span style="${"color:green"}">green parameters</span> form the <strong>\u201Creadout\u201D</strong>.</p>
<p>In this case, the core is simple and interpretable (it\u2019s a single space-time separable linear filter). The readout is also simple. It\u2019s a gain and offset term per neuron. But this conceptual framing scales nicely to talking about much more complicated neural network models and nicely delineates their distinctions. But, every model consists of a \u201Ccore\u201D and a \u201Creadout\u201D.</p>
<h3 id="${"two-basic-types-of-cores"}">Two basic types of cores</h3>
<p>Once you accept the \u201Ccore\u201D and \u201Creadout\u201D distinction, cores have two basic distinctions in neuroscience research. They can either be <strong>\u201Cdata-driven\u201D</strong> or <strong>\u201Cgoal-directed\u201D</strong>.</p>
<p><strong>Goal-directed</strong> cores consist of a model that was trained to do <strong>some task</strong> given a stimulus (e.g., object classification). We\u2019ve seen this successfully applied in neuroscience to a number cases, particularly in the ventral stream of primates (e.g., Yamins et al., ).</p>
<p><strong>Data-driven</strong> cores learn the core directly from the <strong>neural activity</strong>.</p>
<p>This idea is really just something that has been said by others already (e.g., <a href="${"http://neurotheory.umd.edu/Publications_files/ARVSpreprint.pdf"}" rel="${"nofollow"}">this paper from Dan Butts</a>), but I\u2019m converging on certain language for talking about it myself: \u201Cdata-driven core\u201D vs. \u201Cgoal-directed core\u201D.</p>
<p>The figure below demonstrates the logic of a data-driven core. It is trained end-to-end from stimulus to spikes. The core is shared by all neurons and the readout is neuron specific.</p>
<img src="${"/labmeetinglurz/buttsdatadriven.png"}" style="${"max-width: 50em"}" alt="${"diagram"}">
<p>In contrast, a goal-directed core comes pre-trained (on some other dataset) and and forms a nonlinear basis for a linearized model of the neural responses.</p>
<img src="${"/labmeetinglurz/buttstransfer.png"}" style="${"max-width: 50em"}" alt="${"diagram"}">
<p><strong>The advantages of a goal-directed core are:</strong></p>
<ol><li>they can use much more data than is typically available in a neural recording</li>
<li>they have an explicit task, so they provide convenient language for talking about what the core <em>does</em></li></ol>
<p><strong>The advantages (hopes) of data-driven cores are:</strong></p>
<ol><li>they nonlinearities that are brain specific (opposed to input-specific or task-specific)</li>
<li>can be constrained with brain-inspired architecture</li></ol>
<p>There are disadvantages to both approaches as well. The primary disadvantage of goal-directed cores in vision is that you\u2019re mostly stuck with whatever the ML community has been most excited about. I think this has had an unfortunate side effect of pushing more of visual neuroscience into studying the responses to images (because that\u2019s what the models can do). Of course, goal-directed cores can also be constrained with brain-like architecture and trained from scratch, and we\u2019ll probably see more of that happening, but then you\u2019re back dealing with data/computation limits. Another limitation of a goal-directed network is that you have to know what the neurons do <em>a priori</em> instead of just knowing what their inputs are. What does the retina do?</p>
<p>Okay. Now that we\u2019re all on the same page, a real test of a data-driven core is whether it can generalize like goal-directed cores do. Goal-directed cores are generalize from the task they were trained to perform to predict neural activity by training the readout. Lurz and colleagues do the same thing here. Train the core and readout on one set of neurons, then fix the core and train only the readout on another set of neurons.</p>
<h2 id="${"old-tricks-for-learning-the-readout"}">Old \u201CTricks\u201D for learning the readout</h2>
<p>For a typical convolutional neural network (CNN), the per-neuron readout scales with the size of the input and the number of channels. For example, the activations of the final layer of a CNN, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">a</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">F</span></span><span class="${"mopen"}">[</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">]</span></span></span></span></span>, where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">x</span></span></span></span></span> is an image of size <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.66666em;vertical-align:-0.08333em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">h</span></span></span></span></span>, is <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.5782em;vertical-align:-0.0391em;"}"></span><span class="${"mord mathnormal"}">a</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u2208</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8491079999999999em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">R</span></span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8491079999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mbin mtight"}">\xD7</span><span class="${"mord mathnormal mtight"}">h</span><span class="${"mbin mtight"}">\xD7</span><span class="${"mord mathnormal mtight"}">c</span></span></span></span></span></span></span></span></span></span></span></span></span> where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> is the number of channels in the network.</p>
<p>For the models the authors are considering here, the image size is <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">6</span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">3</span><span class="${"mord"}">6</span></span></span></span></span> so there are 2304 parameters per output channel per neuron! Even with structured regularization (smoothness, sparseness), this is a big problem to fit in a normal dataset.</p>
<p>There have been a series of \u201Ctricks\u201D for learning the readout that these authors have rolled out over the last few years.</p>
<h3 id="${"trick-1-factorized-readout-klindtecker-et-al-2016"}">Trick <a href="${"https://github.com/jcbyts/website/issues/1"}">#1</a>: Factorized readout (Klindt,Ecker et al., 2016)</h3>
<p>The first trick is to learn the same spatial readout for all channels in the model. This separates \u201Cwhat\u201D features the neuron integrates from \u201Cwhere\u201D the neurons are spatially selective.</p>
<p>The activations, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">a</span></span></span></span></span>, are size <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mopen"}">[</span><span class="${"mord mathnormal"}" style="${"margin-right:0.10903em;"}">N</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.66666em;vertical-align:-0.08333em;"}"></span><span class="${"mord mathnormal"}">c</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.66666em;vertical-align:-0.08333em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord mathnormal"}">h</span><span class="${"mclose"}">]</span></span></span></span></span>, where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.68333em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.10903em;"}">N</span></span></span></span></span> is the batch size, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> is the channels, and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.66666em;vertical-align:-0.08333em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">h</span></span></span></span></span> are the width and height of the input images. The activations are multiplied by a feature vector, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.9270999999999999em;vertical-align:-0.0391em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8879999999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">i</span><span class="${"mclose mtight"}">)</span></span></span></span></span></span></span></span></span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u2208</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.68889em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">R</span></span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.664392em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">c</span></span></span></span></span></span></span></span></span></span></span></span>, and a spatial weight vector, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.9270999999999999em;vertical-align:-0.0391em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">v</span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8879999999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">i</span><span class="${"mclose mtight"}">)</span></span></span></span></span></span></span></span></span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u2208</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8491079999999999em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">R</span></span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8491079999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mbin mtight"}">\xD7</span><span class="${"mord mathnormal mtight"}">h</span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.65952em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">i</span></span></span></span></span> is the neuron index.</p>
<p>Therefore the response of neuron <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.65952em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">i</span></span></span></span></span> will be</p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8879999999999999em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">r</span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8879999999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">i</span><span class="${"mclose mtight"}">)</span></span></span></span></span></span></span></span></span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.4822159999999998em;vertical-align:-0.4374159999999999em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.13889em;"}">F</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"delimsizing size1"}">[</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mop"}"><span class="${"mop op-symbol small-op"}" style="${"position:relative;top:-0.0000050000000000050004em;"}">\u2211</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.18639799999999984em;"}"><span style="${"top:-2.40029em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">h</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">c</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.43581800000000004em;"}"><span></span></span></span></span></span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:1.0448em;"}"><span style="${"top:-2.5834080000000004em;margin-left:-0.02691em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">c</span></span></span></span><span style="${"top:-3.2198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">i</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.11659199999999997em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">v</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:1.0448em;"}"><span style="${"top:-2.3986920000000005em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">h</span></span></span></span><span style="${"top:-3.2198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">i</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.4374159999999999em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"mord mathnormal"}">a</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">c</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02691em;"}">w</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">h</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"delimsizing size1"}">]</span></span></span></span></span></span></p>
<p>where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.83333em;vertical-align:-0.15em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.13889em;"}">F</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> is the activation function for neuron <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.65952em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">i</span></span></span></span></span>, which is an <a href="${"https://paperswithcode.com/method/elu"}" rel="${"nofollow"}">ELU</a> with an offset.</p>
<img src="${"/labmeetinglurz/elu.png"}" style="${"max-width: 20em"}" alt="${"diagram"}">
<p>This reduces the number of parameters from <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mord"}">3</span><span class="${"mord"}">0</span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> to <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mord"}">3</span><span class="${"mord"}">0</span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span></p>
<h3 id="${"trick-2-coordinate-readout-using-bilinear-interpolation-learned-with-pooling-steps-sinz-et-al-2018"}">Trick <a href="${"https://github.com/jcbyts/website/issues/2"}">#2</a>: coordinate readout using bilinear interpolation, learned with pooling steps (Sinz et al., 2018)</h3>
<p>This approach assumes that each neuron has a feature vector that reads out from a spatial position (a single point) in the spatial output of the network.</p>
<p>The spatial position for each neuron, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">x</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> are learned parameters. They are sampled at sub-pixel resolution using bilinear interpolation. The issue with learning <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">x</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> is that if the initialization is far away from the true retinotopic location of the neuron, then the gradients will be zero. To circumvent this, the authors represent the feature space of the core at multiple scales using <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">4</span></span></span></span></span> average pooling steps with <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">4</span></span></span></span></span> pooling with a stride of <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">4</span></span></span></span></span>, such that the final stage is a single pixel. They then learn a feature vector that combines across these scales. <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">x</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> can be any value within a <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">1</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">1</span></span></span></span></span> feature space and that way there are gradients to support the learning of the features and the position.</p>
<p>This readout idea comes from <a href="${"https://arxiv.org/abs/1506.02025"}" rel="${"nofollow"}">spatial transformer layers</a>. The basic transform operation is an affine transform of a grid of sampling points.</p>
<img src="${"/labmeetinglurz/spatialtransformer.png"}" style="${"max-width: 50em"}" alt="${"diagram"}">
<p>The difference here is that the sample is a single point for each neuron and it is sampling that point in a coordinate system that is the same regardless of the pooling size. That way the initialization always has something to start with.</p>
<img src="${"/labmeetinglurz/pointreadout.png"}" style="${"max-width: 50em"}" alt="${"diagram"}">
<p><strong>This has two cool benefits:</strong></p>
<ol><li><p>The number of parameters is reduced from <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mord"}">3</span><span class="${"mord"}">0</span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> to <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">m</span><span class="${"mord mathnormal"}">c</span></span></span></span></span>, where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">m</span></span></span></span></span> is the number of pooling steps, and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> is the number of channels.</p></li>
<li><p><strong>Eyetracking!</strong> Because the readout is parameterized as an x,y coordinate, they can shift the entire readout around with a \u201Cshifter network\u201D that operates on the pupil position in a video of the eye.</p></li></ol>
<p>The full model in the 2018 paper is schematized here:</p>
<img src="${"/labmeetinglurz/sinz2018.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<p>Okay, so now that we have a sense of the readout, we\u2019re ready for the new tricks introduced in Lurz et al., 2020.</p>
<h2 id="${"new-tricks-for-learning-the-readout"}">New Tricks for learning the readout</h2>
<p>Using the same bilinear interpolation readout from Sinz et al., 2018, the authors improve the learning of the <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">x</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> for each neuron. They do so by using the \u201Creparameterization trick\u201D (Kingma and Welling)</p>
<h3 id="${"quick-refresher-on-vaes"}">Quick refresher on VAEs</h3>
<p>We\u2019ve discussed VAEs in lab meeting in the past, so we already learned the tricks that we need here to learn this new readout. This section here is a really abridged reminder on variation autoencoders with emphasis on the \u201Creparameterization trick\u201D as it will be applied. If you care at all about details, read (<a href="${"https://arxiv.org/pdf/1906.02691.pdf"}" rel="${"nofollow"}">this</a>) nice tutorial.</p>
<p>Start with a generative model of data <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.5782em;vertical-align:-0.0391em;"}"></span><span class="${"mord mathnormal"}">x</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u2208</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8413309999999999em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">R</span></span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8413309999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">D</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.11112em;vertical-align:-0.30612em;"}"></span><span class="${"mop op-symbol small-op"}" style="${"margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;"}">\u222B</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}">x</span><span class="${"mord"}">\u2223</span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mclose"}">)</span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mclose"}">)</span><span class="${"mord mathnormal"}">d</span><span class="${"mord mathnormal"}">x</span></span></span></span></span></span></p>
<p>where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.5782em;vertical-align:-0.0391em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u2208</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8491079999999999em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">R</span></span><span class="${"msupsub"}"><span class="${"vlist-t"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8491079999999999em;"}"><span style="${"top:-3.063em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">d</span><span class="${"mrel mtight"}">\u226A</span><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">D</span></span></span></span></span></span></span></span></span></span></span></span></span> is a latent space and achieves some dimensionality reduction.</p>
<p>There are two tricks to learning the posterior <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mord"}">\u2223</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span></span></span></span></span>:</p>
<p>First, we approximated an intractable posterior with a variational distribution <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">q</span></span></span></span></span> and we showed that we only needed to maximize the ELBO to fit the parameters <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span> and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span>.</p>
<p>Second, we reparameterized the loss to take the sampling step outsize of the optimization. This reparameterization trick let us take the gradients with respect to the parameters we\u2019re interested in fitting. It\u2019s the same trick they use to do the sampling here.</p>
<p>One final reminder about VAEs is that this is a generative modeling approach with Bayesian inference for the latents, but it can also be referred to in coding theory terms like <em>Encoding</em> and <em>Decoding</em>.</p>
<p>The basic idea is pictured here</p>
<img src="${"/labmeetinglurz/kingmavaelearning.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<p>I\u2019m going to skip derivations and you can look at the link above if you want them. The key point is that by starting with the objective of maximizing the marginal likelihood <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span></span></span></span></span> you end up with two terms in the loss: one that is a KL divergence between the posterior approximation <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mord"}">\u2223</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span></span></span></span></span> and the true (intractable) posterior <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">p</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.33610799999999996em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mord"}">\u2223</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span></span></span></span></span> and another known as the Evidence Lower Bound (ELBO) that I\u2019m showing here:</p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathcal"}">L</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.2332799999999997em;vertical-align:-0.38327999999999984em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">E</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3448em;"}"><span style="${"top:-2.5198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3448em;"}"><span style="${"top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"}"><span class="${"pstrut"}" style="${"height:2.5em;"}"></span><span class="${"sizing reset-size3 size1 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.29011428571428566em;"}"><span></span></span></span></span></span></span><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mord mtight"}">\u2223</span><span class="${"mord mathnormal mtight"}">x</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.38327999999999984em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"delimsizing size1"}">[</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mop"}">lo<span style="${"margin-right:0.01389em;"}">g</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">p</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.33610799999999996em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\u2212</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.20001em;vertical-align:-0.35001em;"}"></span><span class="${"mop"}">lo<span style="${"margin-right:0.01389em;"}">g</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mord"}">\u2223</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span><span class="${"mord"}"><span class="${"delimsizing size1"}">]</span></span></span></span></span></span></p>
<p>I\u2019m not showing the KL term here because, due to the non-negativity of the KL divergence, the ELBO is a lower bound on the log-likelihood of the data.</p>
<p>We want to maximize the ELBO, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathcal"}">L</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span></span></span></span></span>, w.r.t. the parameters <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span> and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span>, because this approximately maximizes the marginal likelihood and minimizes the KL divergence of the approximation to the true posterior.</p>
<p>Maximizing the the ELBO w.r.t. <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span> is straightforward because the expectation is take w.r.t. the distribution <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mord"}">\u2223</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span></span></span></span></span> so we can move the gradient operator inside the expectation.</p>
<img src="${"/labmeetinglurz/wrttheta.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<p>Maximizing the the ELBO w.r.t. <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span> is tricky because the expectation is w.r.t. the distribution <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mord"}">\u2223</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span></span></span></span></span>, which is a function of <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span>.</p>
<img src="${"/labmeetinglurz/wrtphi.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<p>This is where the \u201Creparameterization trick\u201D comes in. <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathcal"}">L</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span></span></span></span></span> can be differentiated w.r.t. <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span> with a change of variables.</p>
<p>First, express the random variable <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u223C</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.036108em;vertical-align:-0.286108em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mord"}">\u2223</span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span></span></span></span></span> as a differentiable and invertible transformation of another random variable <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">\u03F5</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u223C</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord"}"><span class="${"mord mathcal"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen"}">(</span><span class="${"mord"}">0</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">I</span></span><span class="${"mclose"}">)</span></span></span></span></span>,<span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span>, and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span></span></span></span></span></p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">g</span></span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}">\u03F5</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mclose"}">)</span></span></span></span></span></p>
<p>With this change of variable, the expectation can be written w.r.t. the <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">\u03F5</span></span></span></span></span> and the gradient can move inside the expectation.</p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.1332799999999998em;vertical-align:-0.38327999999999984em;"}"></span><span class="${"mord"}"><span class="${"mord"}">\u2207</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">E</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3448em;"}"><span style="${"top:-2.5198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.03588em;"}">q</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3448em;"}"><span style="${"top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"}"><span class="${"pstrut"}" style="${"height:2.5em;"}"></span><span class="${"sizing reset-size3 size1 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.29011428571428566em;"}"><span></span></span></span></span></span></span><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mord mtight"}">\u2223</span><span class="${"mord mathnormal mtight"}">x</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.38327999999999984em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">[</span><span class="${"mord mathnormal"}" style="${"margin-right:0.10764em;"}">f</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.04398em;"}">z</span><span class="${"mclose"}">)</span><span class="${"mclose"}">]</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.1052em;vertical-align:-0.3551999999999999em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">E</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.34480000000000005em;"}"><span style="${"top:-2.5198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03F5</span><span class="${"mrel mtight"}">\u223C</span><span class="${"mord mtight"}"><span class="${"mord mathcal mtight"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen mtight"}">(</span><span class="${"mord mtight"}">0</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mtight"}">1</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3551999999999999em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">[</span><span class="${"mord"}"><span class="${"mord"}">\u2207</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3361079999999999em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03D5</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.286108em;"}"><span></span></span></span></span></span></span><span class="${"mord mathnormal"}" style="${"margin-right:0.10764em;"}">f</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">g</span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span><span class="${"mclose"}">)</span><span class="${"mclose"}">)</span><span class="${"mclose"}">]</span></span></span></span></span></p>
<p>This reparameterization means <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.10764em;"}">f</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">g</span><span class="${"mopen"}">(</span><span class="${"mord text"}"><span class="${"mord textrm"}">z</span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">x</span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span><span class="${"mclose"}">)</span><span class="${"mclose"}">)</span></span></span></span></span> can be automatically differentiated w.r.t. the parameters <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span> using whatever software is your current favorite (Tensorflow, Pytorch).</p>
<p>The schematic that illustrates this can be seen here:</p>
<img src="${"/labmeetinglurz/kingmavaereparameterization.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<h2 id="${"new-trick-1-reparameterization--sampling"}">New Trick <a href="${"https://github.com/jcbyts/website/issues/1"}">#1</a>: reparameterization + sampling</h2>
<p>The model still uses the poisson loss, but now it depends on random variables <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">x</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u223C</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord"}"><span class="${"mord mathcal"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen"}">(</span><span class="${"mord"}"><span class="${"mord mathnormal"}">\u03BC</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord"}">\u03A3</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mclose"}">)</span></span></span></span></span>, where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8777699999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">\u03BC</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord"}">\u03A3</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.31166399999999994em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mathnormal mtight"}">i</span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span></span></span></span></span> are learned parameters.</p>
<p>The new loss function involves an expectation over the distribution of <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">x</span></span></span></span></span> and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span></span></span></span></span>.</p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord"}"><span class="${"mord mathcal"}">L</span></span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mpunct"}">;</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">r</span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">x</span></span></span><span class="${"mclose"}">)</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.1052em;vertical-align:-0.3551999999999999em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">E</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.34480000000000005em;"}"><span style="${"top:-2.5198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">x</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"mrel mtight"}">\u223C</span><span class="${"mord mtight"}"><span class="${"mord mathcal mtight"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">\u03BC</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mtight"}">\u03A3</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3551999999999999em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">[</span><span class="${"mop"}">lo<span style="${"margin-right:0.01389em;"}">g</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">r</span></span></span><span class="${"mord"}">\u2223</span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">x</span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mclose"}">)</span><span class="${"mclose"}">]</span></span></span></span></span></p>
<p>where <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.44444em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">r</span></span></span></span></span></span></span> is the observed spike counts, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.44444em;vertical-align:0em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">x</span></span></span></span></span></span></span> is the stimulus, and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord"}"><span class="${"mord mathnormal"}">\u03D5</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">\u03BC</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord"}">\u03A3</span></span></span></span></span></span> are the parameters of the model. <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03BC</span></span></span></span></span> and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.68333em;vertical-align:0em;"}"></span><span class="${"mord"}">\u03A3</span></span></span></span></span> are the mean and variance of a multivariate Gaussian that generates the <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">x</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span></span></span></span></span> coordinates for the neuron readouts, and <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.8888799999999999em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03D5</span></span></span></span></span> is all other parameters in the CNN.</p>
<p>We can use the same reparameterization trick from above to make the gradients easy to compute. Make <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">x</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.03588em;"}">y</span></span></span></span></span> some function of a new random variable <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">\u03F5</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u223C</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord"}"><span class="${"mord mathcal"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen"}">(</span><span class="${"mord"}">0</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">I</span></span><span class="${"mclose"}">)</span></span></span></span></span>, then the expectation is over <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">\u03F5</span></span></span></span></span> and we can move the gradient operator inside the expectation.</p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.1052em;vertical-align:-0.3551999999999999em;"}"></span><span class="${"mord"}"><span class="${"mord"}">\u2207</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.33610799999999996em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">E</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.34480000000000005em;"}"><span style="${"top:-2.5198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">x</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.03588em;"}">y</span><span class="${"mrel mtight"}">\u223C</span><span class="${"mord mtight"}"><span class="${"mord mathcal mtight"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen mtight"}">(</span><span class="${"mord mathnormal mtight"}">\u03BC</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mtight"}">\u03A3</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3551999999999999em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">[</span><span class="${"mop"}">lo<span style="${"margin-right:0.01389em;"}">g</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">r</span></span></span><span class="${"mord"}">\u2223</span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">x</span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mclose"}">)</span><span class="${"mclose"}">]</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">=</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1.1052em;vertical-align:-0.3551999999999999em;"}"></span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbb"}">E</span></span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.34480000000000005em;"}"><span style="${"top:-2.5198em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}">\u03F5</span><span class="${"mrel mtight"}">\u223C</span><span class="${"mord mtight"}"><span class="${"mord mathcal mtight"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen mtight"}">(</span><span class="${"mord mtight"}">0</span><span class="${"mpunct mtight"}">,</span><span class="${"mord mtight"}">1</span><span class="${"mclose mtight"}">)</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.3551999999999999em;"}"><span></span></span></span></span></span></span><span class="${"mopen"}">[</span><span class="${"mord"}"><span class="${"mord"}">\u2207</span><span class="${"msupsub"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.33610799999999996em;"}"><span style="${"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"}"><span class="${"pstrut"}" style="${"height:2.7em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mathnormal mtight"}" style="${"margin-right:0.02778em;"}">\u03B8</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.15em;"}"><span></span></span></span></span></span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mop"}">lo<span style="${"margin-right:0.01389em;"}">g</span></span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">p</span><span class="${"mopen"}">(</span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">r</span></span></span><span class="${"mord"}">\u2223</span><span class="${"mord"}"><span class="${"mord"}"><span class="${"mord mathbf"}">x</span></span></span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.02778em;"}">\u03B8</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord mathnormal"}">\u03F5</span><span class="${"mclose"}">)</span><span class="${"mclose"}">]</span></span></span></span></span></p>
<p>In practice, all you have to do is sample 1 draw from <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">\u03F5</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span><span class="${"mrel"}">\u223C</span><span class="${"mspace"}" style="${"margin-right:0.2777777777777778em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord"}"><span class="${"mord mathcal"}" style="${"margin-right:0.14736em;"}">N</span></span><span class="${"mopen"}">(</span><span class="${"mord"}">0</span><span class="${"mpunct"}">,</span><span class="${"mspace"}" style="${"margin-right:0.16666666666666666em;"}"></span><span class="${"mord text"}"><span class="${"mord textrm"}">I</span></span><span class="${"mclose"}">)</span></span></span></span></span> for each sample in a batch during regular old SGD.</p>
<p>This has a huge reduction in the number of parameters in the readout. We went from <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mord"}">3</span><span class="${"mord"}">0</span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">\xD7</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> in the full space to <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mord"}">3</span><span class="${"mord"}">0</span><span class="${"mord"}">4</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">c</span></span></span></span></span> in the <em>factorized</em> case. Then we made it down to <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.72777em;vertical-align:-0.08333em;"}"></span><span class="${"mord"}">2</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">m</span><span class="${"mord mathnormal"}">c</span></span></span></span></span> in the <em>coordinate + pooling</em> case. With this final innovation, we\u2019re down to <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.66666em;vertical-align:-0.08333em;"}"></span><span class="${"mord mathnormal"}">c</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">6</span></span></span></span></span> parameters per neuron (not including the bias \u2013 which I didn\u2019t include in any of the other parameter counts)!!</p>
<p><span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.66666em;vertical-align:-0.08333em;"}"></span><span class="${"mord mathnormal"}">c</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span><span class="${"mbin"}">+</span><span class="${"mspace"}" style="${"margin-right:0.2222222222222222em;"}"></span></span><span class="${"base"}"><span class="${"strut"}" style="${"height:0.64444em;vertical-align:0em;"}"></span><span class="${"mord"}">7</span></span></span></span></span> total parameters per neuron to learn for the readout should not be hard, but they don\u2019t stop there. They use one more trick.</p>
<h3 id="${"new-trick-2-retinotopy"}">New Trick <a href="${"https://github.com/jcbyts/website/issues/2"}">#2</a>: retinotopy</h3>
<p>Neurons in V1 are organized spatially such that cortical space maps onto visual space. This is known as retinotopy because cortical space forms a map that is in retinal (and therefore visual) coordinates.</p>
<p>Using this additional information, the authors learn a mapping from cortical space (where they measured the location of the neurons) to the <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03BC</span></span></span></span></span> parameter. This reduced the total number of parameters per neuron by 2 and makes shifts in <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.625em;vertical-align:-0.19444em;"}"></span><span class="${"mord mathnormal"}">\u03BC</span></span></span></span></span> shared.</p>
<p>Figure 2 in the paper illustrates this conceptually.</p>
<img src="${"/labmeetinglurz/lurzfig2.png"}" style="${"max-width: 40em"}" alt="${"diagram"}">
<p>Now they\u2019re really showing off! With all of these new tricks in place, they are ready to train cores and test them on withheld datasets\u2026 yea, withheld <em>datasets</em>, not just withheld <em>data</em>.</p>
<h3 id="${"generalization-and-performance"}">Generalization and Performance</h3>
<p>The rest of the paper just shows how well these different readouts work for different sets of training and test data. I don\u2019t have much to say except the new readout easily beats the state-of-the-art. And it generalizes better than VGG-16 as a core model.</p>
<img src="${"/labmeetinglurz/lurzfig3.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<p><strong>Figure 3:</strong> Performance of end-to-end trained networks. Performance for different subsets of neurons (linestyle) and number of training examples (x-axis). The same core architecture was trained for two different readouts with and without feature sharing (color) on the matched neurons of the 4-S:matched core set (Fig. 1, green). Both networks show increasing performance with number of images However, the network with the Gaussian readout achieves a higher final performance (light blue vs. orange). While the Gaussian readout profits from feature sharing (light vs. dark blue), the factorized readout is hurt by it (yellow vs. orange). Shaded areas depict 95% confidence intervals across random picks of the neuron subsets</p>
<img src="${"/labmeetinglurz/lurzfig4.png"}" style="${"max-width: 60em"}" alt="${"diagram"}">
<p><strong>Figure 4:</strong> Generalization to other neurons in the same animal. A core trained on 3597 neurons and up to 17.5k images generalizes to new neurons (pink and yellow line). A fully trained core yields very good predictive performance even when the readout is trained on far less data (yellow). If the readout is trained with all data, even a sub-optimal core can yield a good performance (pink). Both transfer conditions outperform a network directly trained end-to-end on the transfer dataset (brown). For the full dataset, all training conditions converge to the same performance. Except in the best-core/diff-readout condition for very few training data, the Gaussian readout (B) outperforms the factorized readout (A). The data for both the training and transfer comes from the 4-S:matched dataset (Fig 1, green). Not that the different number of images can be from the core or transfer set, depending on the transfer condition.</p>
<img src="${"/labmeetinglurz/lurzfig5.png"}" style="${"max-width: 30em"}" alt="${"diagram"}">
<p><strong>Figure 5:</strong> Generalization across animals. Prediction performance in fraction oracle correlation as a function of
training examples in the transfer set for
a Gaussian readout (x-axis) and different ways to obtain the core (colors).
The transfer training was performed
on the evaluation dataset (blue, Fig 1).
Cores trained on several scans used
in transfer learning outperform direct
training on the transfer dataset (blue
line; direct condition).</p>
<h3 id="${"discussion-and-thoughts"}">Discussion and thoughts</h3>
<p>Overall, this is really impressive. But, I\u2019m still left wishing these guys would do some science! Haha. Joking aside, it is nice that the ML conference format means we\u2019re all up to date on what tricks they\u2019re learning to fit these models, but there haven\u2019t really been any real scientific insights from this series of papers, besides maybe the <a href="${"https://www.biorxiv.org/content/10.1101/767285v4"}" rel="${"nofollow"}">divisive normalization paper</a>. Even the <a href="${"https://xaqlab.com/wp-content/uploads/2019/11/Inception_Walker_plusSupp.pdf"}" rel="${"nofollow"}">\u201CInception\u201D</a> paper was really underwhelming. All of that effort to find things that look like gabors with surrounds and don\u2019t really drive V1 neurons much better. I\u2019d say we\u2019re still learning much more interesting things about mouse visual cortex <a href="${"https://nbdt.scholasticahq.com/article/5123-on-the-subspace-invariance-of-population-responses"}" rel="${"nofollow"}">using gratings</a>, which is a real disappointment for the \u201Cstate-of-the-art\u201D. Of course, this is a high bar for a subfield that is so new, but I would be really disappointed if the ML business of focusing on performance spreads into neuroscience more than <a href="${"http://www.brain-score.org/"}" rel="${"nofollow"}">it already has</a>. Yes, performance is important, but that alone is not the goal and performance obviously has to be mixed with insights (e.g., <a href="${"https://issalab.neuroscience.columbia.edu/sites/default/files/content/Kar%20et%20al.%20Evidence%20that%20recurrent%20circuits_Nat%20Neuro%202019.pdf"}" rel="${"nofollow"}">Kar et al., 2019</a>) <a href="${"https://www.biorxiv.org/content/10.1101/767285v4"}" rel="${"nofollow"}">Burg et al., 2020</a> is definitely a step in the right direction!</p>
<p>I\u2019d love to see anatomically constrained cores and attempts to explain nonlinear responses in V1 parsimoniously (<a href="${"https://arxiv.org/abs/1912.06207"}" rel="${"nofollow"}">like this</a>). There are other ways this type of model could be useful. Often neuroscientists do not care about the stimulus processing model, but simply care that they have a way to modulate and predict responses so they can test for attentional modulations or decision signals. I\u2019d like to see this framework applied to a a more natural task: the shifter and modulator networks in Sinz et al., 2018 provide a perfect vehicle to ask these types of questions.</p>
<p>Anyway, Lurz et al., 2020 is a very impressive method with a lot of clever tricks in it. Looking forward to the next in the series!</p>`;
    });
  }
});

// .svelte-kit/output/server/chunks/matlab-arduino-e4388c2a.js
var matlab_arduino_e4388c2a_exports = {};
__export(matlab_arduino_e4388c2a_exports, {
  default: () => Matlab_arduino,
  metadata: () => metadata3
});
var metadata3, Matlab_arduino;
var init_matlab_arduino_e4388c2a = __esm({
  ".svelte-kit/output/server/chunks/matlab-arduino-e4388c2a.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    metadata3 = {
      "title": "A Fast(er) interface for Arduino from Matlab",
      "date": "2021-5-10",
      "description": "Major speedup for Arduino through serial buffer and IOPort"
    };
    Matlab_arduino = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<p>I recently had to setup an experimental rig with an interface between Matlab and an Arduino. The goal of the interface was to read out the position of a treadmill using a rotary encoder. This must be a pretty common situation in neuroscience these days, but my first foray into setting it up (through the official <a href="${"https://www.mathworks.com/hardware-support/arduino-matlab.html"}" rel="${"nofollow"}">matlab arduino toolbox</a>) was way too slow for any reasonable experiment. I figured I\u2019d write up my notes on the process here. If you know a better way to do this, please email or message me!</p>
<h3 id="${"approach-1-matlab-arduino-toolbox"}">Approach 1: Matlab arduino toolbox</h3>
<p>The matlab toolbox is pretty easy to use. We need a rotary encoder to read out the turns of the treadmill, and that\u2019s already built in as toolbox (again, figure this is a pretty common task). The code to connect and setup the rotary encoder look like this:</p>
<img src="${"/arduinoblog/fig02_open.png"}" alt="${"Connect to the Arduino"}" style="${"max-width: 40em; width: 100%"}">
<p>The encoder uses digital inputs 2 and 3.</p>
<p>Great. Simple enough. But is it fast enough? Our experiment code runs visual stimuli at 120 or 240Hz. That means we have to complete all analyses of behavior within ~7 or ~3.5 ms before we absolutely have to draw the stimuli. These numbers shrink if the stimuli are really complicated. All time matters (e.g., communicating with the syringe pump to send reward takes ~0.5 ms).</p>
<p>To compute the arduino toolbox call time, I just ran the main call 1000 times in a for loop and measured the elapsed time. The code looks like this:</p>
<img src="${"/arduinoblog/fig03_loop.png"}" alt="${"Loop calls to rotary encoder"}" style="${"max-width: 40em; width: 100%"}">
<p>Pretty straightforward. And the output?</p>
<p><code>Median Duration Arduino Toolbox = 8.07 [7.89, 8.23] ms</code></p>
<img src="${"/arduinoblog/fig04_summary.png"}" alt="${"Arduino toolbox call time"}" style="${"max-width: 30em; width: 100%"}">
<p>This just won\u2019t work. Matlab hangs for ~8ms each time the toolbox calls. At that rate, we\u2019d drop every single frame of the experiment. This would be possible at a 60Hz refresh rate, but that\u2019s just too slow for reasonable motion stimuli. I searched the Mathworks forums and Arduino forums and there\u2019s a lot of chatter about how slow this is, but also a lot of insistance that \u201Cthis is just how fast you can run over USB\u201D. That can\u2019t be right. And it isn\u2019t. There\u2019s a faster way\u2026</p>
<h3 id="${"approach-2-ioport-serial-connection"}">Approach 2: IOPort serial connection</h3>
<p><a href="${"http://psychtoolbox.org"}" rel="${"nofollow"}">Psychtoolbox</a> has a mex function called <a href="${"http://psychtoolbox.org/docs/IOPort"}" rel="${"nofollow"}">IOPort</a> that supports connections over a serial port (which can work over USB, of course). This means we\u2019d need to run all rotary encoding on the Arduino as a sketch and only use Matlab to communicate to a serial buffer.</p>
<p>Arduino sketches are easy enough to write and you can find plenty of code snippets online. Here\u2019s the steps of the code I\u2019m using. I based it off a snippet I got from Jack Liska in Huklab.</p>
<p>The code sketch has 4 parts: <code>variable declaration</code>, <code>setup</code>, <code>main loop</code>, and <code>rotary encoder function</code></p>
<p>We use the <code>digitalWriteFast</code> library which supposedly offers substantial speedup over the default <code>digitalWrite</code> function in the default Arduino library. All variables are setup here:</p>
<img src="${"/arduinoblog/fig05_libvar.png"}" alt="${"Sketch libraries and variables"}" style="${"max-width: 40em; width: 100%"}">
<p>Then we setup the serial buffer and initialize the encoder pins. The rotary encoder operates as an interrupt that responds to the rising edge of the digital inputs.</p>
<img src="${"/arduinoblog/fig06_setup.png"}" alt="${"Sketch setup"}" style="${"max-width: 40em; width: 100%"}">
<p>The main loop just dumps the current time and encoder count to the serial buffer. It also listens for a \u201Creset\u201D command to reset the counter, which is necessary so that our count doesn\u2019t exceed the bitdepth of the <code>long</code> type we\u2019re storing them as.</p>
<img src="${"/arduinoblog/fig07_loop.png"}" alt="${"Sketch main loop"}" style="${"max-width: 40em; width: 100%"}">
<p>The loop depends on the encoder to detect digital ins and count them.</p>
<img src="${"/arduinoblog/fig08_encoder.png"}" alt="${"Sketch encoder"}" style="${"max-width: 40em; width: 100%"}">
<p>It\u2019s pretty straightforward. The output lools something like this. So these are the lines we need to read.</p>
<img src="${"/arduinoblog/fig09_outpu.png"}" alt="${"Sketch serial buffer output"}" style="${"max-width: 20em; width: 100%"}">
<p>Back in matlab, we can setup our serial connection to the arduino like this:</p>
<img src="${"/arduinoblog/fig11_approach2mat.png"}" alt="${"IOPort connection"}" style="${"max-width: 40em; width: 100%"}">
<p>We need to parse the buffer to make sense of the encoded values. I used regexp to parse the \u201Ctime\u201D and \u201Ccount\u201D keywords. There must be a smarter way to read from the buffer, but I wanted to do it as fast as possible.</p>
<img src="${"/arduinoblog/fig12_approach2matloop.png"}" alt="${"IOPort read and loop"}" style="${"max-width: 40em; width: 100%"}">
<p>After all this, we can see how fast the calls are.</p>
<p><code>Median Duration IOPort = 0.59 [0.58, 0.59] ms</code></p>
<img src="${"/arduinoblog/fig10_summary.png"}" alt="${"IOPort read speed"}" style="${"max-width: 30em; width: 100%"}">
<p>This is a huge speed up! We went from 8ms to 0.5ms and we are getting the correct encoder values. However, useing this approach, we miss a fraction of the samples because the buffer is only partially full and the keywords can be missed. I haven\u2019t fully debugged how to improve this yet, but now we can read from the treadmill online without dropping frames.</p>
<p>The <a href="${"https://github.com/jcbyts/MarmoV5/blob/master/%2Bmarmoview/treadmill_arduino.m"}" rel="${"nofollow"}">treadmill code</a> I wrote is available on my github and the <a href="${"https://github.com/jcbyts/MarmoV5/blob/master/SupportFunctions/sketch_rotary_serial.ino"}" rel="${"nofollow"}">arduino sketch</a> is available as well.</p>`;
    });
  }
});

// node_modules/d3-array/src/ascending.js
function ascending(a3, b) {
  return a3 == null || b == null ? NaN : a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}
var init_ascending = __esm({
  "node_modules/d3-array/src/ascending.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/bisector.js
function bisector(f3) {
  let delta = f3;
  let compare1 = f3;
  let compare2 = f3;
  if (f3.length !== 2) {
    delta = (d, x5) => f3(d) - x5;
    compare1 = ascending;
    compare2 = (d, x5) => ascending(f3(d), x5);
  }
  function left2(a3, x5, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x5, x5) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x5) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a3, x5, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x5, x5) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x5) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a3, x5, lo = 0, hi = a3.length) {
    const i2 = left2(a3, x5, lo, hi - 1);
    return i2 > lo && delta(a3[i2 - 1], x5) > -delta(a3[i2], x5) ? i2 - 1 : i2;
  }
  return { left: left2, center: center2, right: right2 };
}
var init_bisector = __esm({
  "node_modules/d3-array/src/bisector.js"() {
    init_shims();
    init_ascending();
  }
});

// node_modules/d3-array/src/number.js
function number(x5) {
  return x5 === null ? NaN : +x5;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
var init_number = __esm({
  "node_modules/d3-array/src/number.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/bisect.js
var ascendingBisect, bisectRight, bisectLeft, bisectCenter, bisect_default;
var init_bisect = __esm({
  "node_modules/d3-array/src/bisect.js"() {
    init_shims();
    init_ascending();
    init_bisector();
    init_number();
    ascendingBisect = bisector(ascending);
    bisectRight = ascendingBisect.right;
    bisectLeft = ascendingBisect.left;
    bisectCenter = bisector(number).center;
    bisect_default = bisectRight;
  }
});

// node_modules/d3-array/src/count.js
function count(values, valueof) {
  let count3 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count3;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        ++count3;
      }
    }
  }
  return count3;
}
var init_count = __esm({
  "node_modules/d3-array/src/count.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/cross.js
function length(array4) {
  return array4.length | 0;
}
function empty(length3) {
  return !(length3 > 0);
}
function arrayify(values) {
  return typeof values !== "object" || "length" in values ? values : Array.from(values);
}
function reducer(reduce2) {
  return (values) => reduce2(...values);
}
function cross(...values) {
  const reduce2 = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  const lengths = values.map(length);
  const j = values.length - 1;
  const index3 = new Array(j + 1).fill(0);
  const product = [];
  if (j < 0 || lengths.some(empty))
    return product;
  while (true) {
    product.push(index3.map((j2, i3) => values[i3][j2]));
    let i2 = j;
    while (++index3[i2] === lengths[i2]) {
      if (i2 === 0)
        return reduce2 ? product.map(reduce2) : product;
      index3[i2--] = 0;
    }
  }
}
var init_cross = __esm({
  "node_modules/d3-array/src/cross.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/cumsum.js
function cumsum(values, valueof) {
  var sum4 = 0, index3 = 0;
  return Float64Array.from(values, valueof === void 0 ? (v2) => sum4 += +v2 || 0 : (v2) => sum4 += +valueof(v2, index3++, values) || 0);
}
var init_cumsum = __esm({
  "node_modules/d3-array/src/cumsum.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/descending.js
function descending(a3, b) {
  return a3 == null || b == null ? NaN : b < a3 ? -1 : b > a3 ? 1 : b >= a3 ? 0 : NaN;
}
var init_descending = __esm({
  "node_modules/d3-array/src/descending.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/variance.js
function variance(values, valueof) {
  let count3 = 0;
  let delta;
  let mean2 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count3;
        sum4 += delta * (value - mean2);
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count3;
        sum4 += delta * (value - mean2);
      }
    }
  }
  if (count3 > 1)
    return sum4 / (count3 - 1);
}
var init_variance = __esm({
  "node_modules/d3-array/src/variance.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/deviation.js
function deviation(values, valueof) {
  const v2 = variance(values, valueof);
  return v2 ? Math.sqrt(v2) : v2;
}
var init_deviation = __esm({
  "node_modules/d3-array/src/deviation.js"() {
    init_shims();
    init_variance();
  }
});

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min4;
  let max5;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max5 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max5 < value)
            max5 = value;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max5 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max5 < value)
            max5 = value;
        }
      }
    }
  }
  return [min4, max5];
}
var init_extent = __esm({
  "node_modules/d3-array/src/extent.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/fsum.js
function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index3, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}
function fcumsum(values, valueof) {
  const adder = new Adder();
  let index3 = -1;
  return Float64Array.from(values, valueof === void 0 ? (v2) => adder.add(+v2 || 0) : (v2) => adder.add(+valueof(v2, ++index3, values) || 0));
}
var Adder;
var init_fsum = __esm({
  "node_modules/d3-array/src/fsum.js"() {
    init_shims();
    Adder = class {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x5) {
        const p = this._partials;
        let i2 = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y4 = p[j], hi = x5 + y4, lo = Math.abs(x5) < Math.abs(y4) ? x5 - (hi - y4) : y4 - (hi - x5);
          if (lo)
            p[i2++] = lo;
          x5 = hi;
        }
        p[i2] = x5;
        this._n = i2 + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x5, y4, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x5 = hi;
            y4 = p[--n];
            hi = x5 + y4;
            lo = y4 - (hi - x5);
            if (lo)
              break;
          }
          if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
            y4 = lo * 2;
            x5 = hi + y4;
            if (y4 == x5 - hi)
              hi = x5;
          }
        }
        return hi;
      }
    };
  }
});

// node_modules/internmap/src/index.js
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
var InternMap, InternSet;
var init_src = __esm({
  "node_modules/internmap/src/index.js"() {
    init_shims();
    InternMap = class extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: key } });
        if (entries != null)
          for (const [key2, value] of entries)
            this.set(key2, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    };
    InternSet = class extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: key } });
        if (values != null)
          for (const value of values)
            this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    };
  }
});

// node_modules/d3-array/src/identity.js
function identity(x5) {
  return x5;
}
var init_identity = __esm({
  "node_modules/d3-array/src/identity.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/group.js
function group(values, ...keys) {
  return nest(values, identity, identity, keys);
}
function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}
function flatten(groups2, keys) {
  for (let i2 = 1, n = keys.length; i2 < n; ++i2) {
    groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
  }
  return groups2;
}
function flatGroup(values, ...keys) {
  return flatten(groups(values, ...keys), keys);
}
function flatRollup(values, reduce2, ...keys) {
  return flatten(rollups(values, reduce2, ...keys), keys);
}
function rollup(values, reduce2, ...keys) {
  return nest(values, identity, reduce2, keys);
}
function rollups(values, reduce2, ...keys) {
  return nest(values, Array.from, reduce2, keys);
}
function index(values, ...keys) {
  return nest(values, identity, unique, keys);
}
function indexes(values, ...keys) {
  return nest(values, Array.from, unique, keys);
}
function unique(values) {
  if (values.length !== 1)
    throw new Error("duplicate key");
  return values[0];
}
function nest(values, map4, reduce2, keys) {
  return function regroup(values2, i2) {
    if (i2 >= keys.length)
      return reduce2(values2);
    const groups2 = new InternMap();
    const keyof2 = keys[i2++];
    let index3 = -1;
    for (const value of values2) {
      const key = keyof2(value, ++index3, values2);
      const group2 = groups2.get(key);
      if (group2)
        group2.push(value);
      else
        groups2.set(key, [value]);
    }
    for (const [key, values3] of groups2) {
      groups2.set(key, regroup(values3, i2));
    }
    return map4(groups2);
  }(values, 0);
}
var init_group = __esm({
  "node_modules/d3-array/src/group.js"() {
    init_shims();
    init_src();
    init_identity();
  }
});

// node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}
var init_permute = __esm({
  "node_modules/d3-array/src/permute.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/sort.js
function sort(values, ...F2) {
  if (typeof values[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f3] = F2;
  if (f3 && f3.length !== 2 || F2.length > 1) {
    const index3 = Uint32Array.from(values, (d, i2) => i2);
    if (F2.length > 1) {
      F2 = F2.map((f4) => values.map(f4));
      index3.sort((i2, j) => {
        for (const f4 of F2) {
          const c5 = ascendingDefined(f4[i2], f4[j]);
          if (c5)
            return c5;
        }
      });
    } else {
      f3 = values.map(f3);
      index3.sort((i2, j) => ascendingDefined(f3[i2], f3[j]));
    }
    return permute(values, index3);
  }
  return values.sort(compareDefined(f3));
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a3, b) => {
    const x5 = compare(a3, b);
    if (x5 || x5 === 0)
      return x5;
    return (compare(b, b) === 0) - (compare(a3, a3) === 0);
  };
}
function ascendingDefined(a3, b) {
  return (a3 == null || !(a3 >= a3)) - (b == null || !(b >= b)) || (a3 < b ? -1 : a3 > b ? 1 : 0);
}
var init_sort = __esm({
  "node_modules/d3-array/src/sort.js"() {
    init_shims();
    init_ascending();
    init_permute();
  }
});

// node_modules/d3-array/src/groupSort.js
function groupSort(values, reduce2, key) {
  return (reduce2.length !== 2 ? sort(rollup(values, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}
var init_groupSort = __esm({
  "node_modules/d3-array/src/groupSort.js"() {
    init_shims();
    init_ascending();
    init_group();
    init_sort();
  }
});

// node_modules/d3-array/src/array.js
var array, slice, map;
var init_array = __esm({
  "node_modules/d3-array/src/array.js"() {
    init_shims();
    array = Array.prototype;
    slice = array.slice;
    map = array.map;
  }
});

// node_modules/d3-array/src/constant.js
function constant(x5) {
  return () => x5;
}
var init_constant = __esm({
  "node_modules/d3-array/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/ticks.js
function ticks(start2, stop, count3) {
  var reverse2, i2 = -1, n, ticks2, step;
  stop = +stop, start2 = +start2, count3 = +count3;
  if (start2 === stop && count3 > 0)
    return [start2];
  if (reverse2 = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step = tickIncrement(start2, stop, count3)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
    if (r0 * step < start2)
      ++r0;
    if (r1 * step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i2 < n)
      ticks2[i2] = (r0 + i2) * step;
  } else {
    step = -step;
    let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
    if (r0 / step < start2)
      ++r0;
    if (r1 / step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i2 < n)
      ticks2[i2] = (r0 + i2) / step;
  }
  if (reverse2)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start2, stop, count3) {
  var step = (stop - start2) / Math.max(0, count3), power = Math.floor(Math.log(step) / Math.LN10), error2 = step / Math.pow(10, power);
  return power >= 0 ? (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count3) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count3), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error2 = step0 / step1;
  if (error2 >= e10)
    step1 *= 10;
  else if (error2 >= e5)
    step1 *= 5;
  else if (error2 >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
var e10, e5, e2;
var init_ticks = __esm({
  "node_modules/d3-array/src/ticks.js"() {
    init_shims();
    e10 = Math.sqrt(50);
    e5 = Math.sqrt(10);
    e2 = Math.sqrt(2);
  }
});

// node_modules/d3-array/src/nice.js
function nice(start2, stop, count3) {
  let prestep;
  while (true) {
    const step = tickIncrement(start2, stop, count3);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start2, stop];
    } else if (step > 0) {
      start2 = Math.floor(start2 / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start2 = Math.ceil(start2 * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
var init_nice = __esm({
  "node_modules/d3-array/src/nice.js"() {
    init_shims();
    init_ticks();
  }
});

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values) {
  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
}
var init_sturges = __esm({
  "node_modules/d3-array/src/threshold/sturges.js"() {
    init_shims();
    init_count();
  }
});

// node_modules/d3-array/src/bin.js
function bin() {
  var value = identity, domain = extent, threshold2 = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data))
      data = Array.from(data);
    var i2, n = data.length, x5, values = new Array(n);
    for (i2 = 0; i2 < n; ++i2) {
      values[i2] = value(data[i2], i2, data);
    }
    var xz = domain(values), x06 = xz[0], x12 = xz[1], tz = threshold2(values, x06, x12);
    if (!Array.isArray(tz)) {
      const max5 = x12, tn = +tz;
      if (domain === extent)
        [x06, x12] = nice(x06, x12, tn);
      tz = ticks(x06, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max5 >= x12 && domain === extent) {
          const step = tickIncrement(x06, x12, tn);
          if (isFinite(step)) {
            if (step > 0) {
              x12 = (Math.floor(x12 / step) + 1) * step;
            } else if (step < 0) {
              x12 = (Math.ceil(x12 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m3 = tz.length;
    while (tz[0] <= x06)
      tz.shift(), --m3;
    while (tz[m3 - 1] > x12)
      tz.pop(), --m3;
    var bins = new Array(m3 + 1), bin2;
    for (i2 = 0; i2 <= m3; ++i2) {
      bin2 = bins[i2] = [];
      bin2.x0 = i2 > 0 ? tz[i2 - 1] : x06;
      bin2.x1 = i2 < m3 ? tz[i2] : x12;
    }
    for (i2 = 0; i2 < n; ++i2) {
      x5 = values[i2];
      if (x5 != null && x06 <= x5 && x5 <= x12) {
        bins[bisect_default(tz, x5, 0, m3)].push(data[i2]);
      }
    }
    return bins;
  }
  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };
  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold2;
  };
  return histogram;
}
var init_bin = __esm({
  "node_modules/d3-array/src/bin.js"() {
    init_shims();
    init_array();
    init_bisect();
    init_constant();
    init_extent();
    init_identity();
    init_nice();
    init_ticks();
    init_sturges();
  }
});

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max5;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value;
      }
    }
  }
  return max5;
}
var init_max = __esm({
  "node_modules/d3-array/src/max.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min4;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  }
  return min4;
}
var init_min = __esm({
  "node_modules/d3-array/src/min.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/quickselect.js
function quickselect(array4, k2, left2 = 0, right2 = array4.length - 1, compare) {
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m3 = k2 - left2 + 1;
      const z = Math.log(n);
      const s4 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s4 * (n - s4) / n) * (m3 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s4 / n + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s4 / n + sd));
      quickselect(array4, k2, newLeft, newRight, compare);
    }
    const t4 = array4[k2];
    let i2 = left2;
    let j = right2;
    swap(array4, left2, k2);
    if (compare(array4[right2], t4) > 0)
      swap(array4, left2, right2);
    while (i2 < j) {
      swap(array4, i2, j), ++i2, --j;
      while (compare(array4[i2], t4) < 0)
        ++i2;
      while (compare(array4[j], t4) > 0)
        --j;
    }
    if (compare(array4[left2], t4) === 0)
      swap(array4, left2, j);
    else
      ++j, swap(array4, j, right2);
    if (j <= k2)
      left2 = j + 1;
    if (k2 <= j)
      right2 = j - 1;
  }
  return array4;
}
function swap(array4, i2, j) {
  const t4 = array4[i2];
  array4[i2] = array4[j];
  array4[j] = t4;
}
var init_quickselect = __esm({
  "node_modules/d3-array/src/quickselect.js"() {
    init_shims();
    init_sort();
  }
});

// node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return min(values);
  if (p >= 1)
    return max(values);
  var n, i2 = (n - 1) * p, i0 = Math.floor(i2), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i2 - i0);
}
function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values[0], 0, values);
  if (p >= 1)
    return +valueof(values[n - 1], n - 1, values);
  var n, i2 = (n - 1) * p, i0 = Math.floor(i2), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i2 - i0);
}
var init_quantile = __esm({
  "node_modules/d3-array/src/quantile.js"() {
    init_shims();
    init_max();
    init_min();
    init_quickselect();
    init_number();
  }
});

// node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values, min4, max5) {
  return Math.ceil((max5 - min4) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));
}
var init_freedmanDiaconis = __esm({
  "node_modules/d3-array/src/threshold/freedmanDiaconis.js"() {
    init_shims();
    init_count();
    init_quantile();
  }
});

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values, min4, max5) {
  return Math.ceil((max5 - min4) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
}
var init_scott = __esm({
  "node_modules/d3-array/src/threshold/scott.js"() {
    init_shims();
    init_count();
    init_deviation();
  }
});

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values, valueof) {
  let max5;
  let maxIndex2 = -1;
  let index3 = -1;
  if (valueof === void 0) {
    for (const value of values) {
      ++index3;
      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value, maxIndex2 = index3;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value, maxIndex2 = index3;
      }
    }
  }
  return maxIndex2;
}
var init_maxIndex = __esm({
  "node_modules/d3-array/src/maxIndex.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/mean.js
function mean(values, valueof) {
  let count3 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count3, sum4 += value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        ++count3, sum4 += value;
      }
    }
  }
  if (count3)
    return sum4 / count3;
}
var init_mean = __esm({
  "node_modules/d3-array/src/mean.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/median.js
function median(values, valueof) {
  return quantile(values, 0.5, valueof);
}
var init_median = __esm({
  "node_modules/d3-array/src/median.js"() {
    init_shims();
    init_quantile();
  }
});

// node_modules/d3-array/src/merge.js
function* flatten2(arrays) {
  for (const array4 of arrays) {
    yield* array4;
  }
}
function merge(arrays) {
  return Array.from(flatten2(arrays));
}
var init_merge = __esm({
  "node_modules/d3-array/src/merge.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/minIndex.js
function minIndex(values, valueof) {
  let min4;
  let minIndex2 = -1;
  let index3 = -1;
  if (valueof === void 0) {
    for (const value of values) {
      ++index3;
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index3;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index3;
      }
    }
  }
  return minIndex2;
}
var init_minIndex = __esm({
  "node_modules/d3-array/src/minIndex.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/mode.js
function mode(values, valueof) {
  const counts = new InternMap();
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count3] of counts) {
    if (count3 > modeCount) {
      modeCount = count3;
      modeValue = value;
    }
  }
  return modeValue;
}
var init_mode = __esm({
  "node_modules/d3-array/src/mode.js"() {
    init_shims();
    init_src();
  }
});

// node_modules/d3-array/src/pairs.js
function pairs(values, pairof = pair) {
  const pairs2 = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first)
      pairs2.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs2;
}
function pair(a3, b) {
  return [a3, b];
}
var init_pairs = __esm({
  "node_modules/d3-array/src/pairs.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i2 = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range4 = new Array(n);
  while (++i2 < n) {
    range4[i2] = start2 + i2 * step;
  }
  return range4;
}
var init_range = __esm({
  "node_modules/d3-array/src/range.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/rank.js
function rank(values, valueof = ascending) {
  if (typeof values[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  let V = Array.from(values);
  const R = new Float64Array(V.length);
  if (valueof.length !== 2)
    V = V.map(valueof), valueof = ascending;
  const compareIndex = (i2, j) => valueof(V[i2], V[j]);
  let k2, r2;
  Uint32Array.from(V, (_, i2) => i2).sort(valueof === ascending ? (i2, j) => ascendingDefined(V[i2], V[j]) : compareDefined(compareIndex)).forEach((j, i2) => {
    const c5 = compareIndex(j, k2 === void 0 ? j : k2);
    if (c5 >= 0) {
      if (k2 === void 0 || c5 > 0)
        k2 = j, r2 = i2;
      R[j] = r2;
    } else {
      R[j] = NaN;
    }
  });
  return R;
}
var init_rank = __esm({
  "node_modules/d3-array/src/rank.js"() {
    init_shims();
    init_ascending();
    init_sort();
  }
});

// node_modules/d3-array/src/least.js
function least(values, compare = ascending) {
  let min4;
  let defined = false;
  if (compare.length === 1) {
    let minValue;
    for (const element of values) {
      const value = compare(element);
      if (defined ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
        min4 = element;
        minValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined ? compare(value, min4) < 0 : compare(value, value) === 0) {
        min4 = value;
        defined = true;
      }
    }
  }
  return min4;
}
var init_least = __esm({
  "node_modules/d3-array/src/least.js"() {
    init_shims();
    init_ascending();
  }
});

// node_modules/d3-array/src/leastIndex.js
function leastIndex(values, compare = ascending) {
  if (compare.length === 1)
    return minIndex(values, compare);
  let minValue;
  let min4 = -1;
  let index3 = -1;
  for (const value of values) {
    ++index3;
    if (min4 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
      minValue = value;
      min4 = index3;
    }
  }
  return min4;
}
var init_leastIndex = __esm({
  "node_modules/d3-array/src/leastIndex.js"() {
    init_shims();
    init_ascending();
    init_minIndex();
  }
});

// node_modules/d3-array/src/greatest.js
function greatest(values, compare = ascending) {
  let max5;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
        max5 = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined ? compare(value, max5) > 0 : compare(value, value) === 0) {
        max5 = value;
        defined = true;
      }
    }
  }
  return max5;
}
var init_greatest = __esm({
  "node_modules/d3-array/src/greatest.js"() {
    init_shims();
    init_ascending();
  }
});

// node_modules/d3-array/src/greatestIndex.js
function greatestIndex(values, compare = ascending) {
  if (compare.length === 1)
    return maxIndex(values, compare);
  let maxValue;
  let max5 = -1;
  let index3 = -1;
  for (const value of values) {
    ++index3;
    if (max5 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
      maxValue = value;
      max5 = index3;
    }
  }
  return max5;
}
var init_greatestIndex = __esm({
  "node_modules/d3-array/src/greatestIndex.js"() {
    init_shims();
    init_ascending();
    init_maxIndex();
  }
});

// node_modules/d3-array/src/scan.js
function scan(values, compare) {
  const index3 = leastIndex(values, compare);
  return index3 < 0 ? void 0 : index3;
}
var init_scan = __esm({
  "node_modules/d3-array/src/scan.js"() {
    init_shims();
    init_leastIndex();
  }
});

// node_modules/d3-array/src/shuffle.js
function shuffler(random) {
  return function shuffle2(array4, i0 = 0, i1 = array4.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i2 = random() * m3-- | 0, t4 = array4[m3 + i0];
      array4[m3 + i0] = array4[i2 + i0];
      array4[i2 + i0] = t4;
    }
    return array4;
  };
}
var shuffle_default;
var init_shuffle = __esm({
  "node_modules/d3-array/src/shuffle.js"() {
    init_shims();
    shuffle_default = shuffler(Math.random);
  }
});

// node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        sum4 += value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index3, values)) {
        sum4 += value;
      }
    }
  }
  return sum4;
}
var init_sum = __esm({
  "node_modules/d3-array/src/sum.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/transpose.js
function transpose(matrix) {
  if (!(n = matrix.length))
    return [];
  for (var i2 = -1, m3 = min(matrix, length2), transpose2 = new Array(m3); ++i2 < m3; ) {
    for (var j = -1, n, row = transpose2[i2] = new Array(n); ++j < n; ) {
      row[j] = matrix[j][i2];
    }
  }
  return transpose2;
}
function length2(d) {
  return d.length;
}
var init_transpose = __esm({
  "node_modules/d3-array/src/transpose.js"() {
    init_shims();
    init_min();
  }
});

// node_modules/d3-array/src/zip.js
function zip() {
  return transpose(arguments);
}
var init_zip = __esm({
  "node_modules/d3-array/src/zip.js"() {
    init_shims();
    init_transpose();
  }
});

// node_modules/d3-array/src/every.js
function every(values, test) {
  if (typeof test !== "function")
    throw new TypeError("test is not a function");
  let index3 = -1;
  for (const value of values) {
    if (!test(value, ++index3, values)) {
      return false;
    }
  }
  return true;
}
var init_every = __esm({
  "node_modules/d3-array/src/every.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/some.js
function some(values, test) {
  if (typeof test !== "function")
    throw new TypeError("test is not a function");
  let index3 = -1;
  for (const value of values) {
    if (test(value, ++index3, values)) {
      return true;
    }
  }
  return false;
}
var init_some = __esm({
  "node_modules/d3-array/src/some.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/filter.js
function filter(values, test) {
  if (typeof test !== "function")
    throw new TypeError("test is not a function");
  const array4 = [];
  let index3 = -1;
  for (const value of values) {
    if (test(value, ++index3, values)) {
      array4.push(value);
    }
  }
  return array4;
}
var init_filter = __esm({
  "node_modules/d3-array/src/filter.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/map.js
function map2(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  if (typeof mapper !== "function")
    throw new TypeError("mapper is not a function");
  return Array.from(values, (value, index3) => mapper(value, index3, values));
}
var init_map = __esm({
  "node_modules/d3-array/src/map.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/reduce.js
function reduce(values, reducer2, value) {
  if (typeof reducer2 !== "function")
    throw new TypeError("reducer is not a function");
  const iterator = values[Symbol.iterator]();
  let done, next, index3 = -1;
  if (arguments.length < 3) {
    ({ done, value } = iterator.next());
    if (done)
      return;
    ++index3;
  }
  while ({ done, value: next } = iterator.next(), !done) {
    value = reducer2(value, next, ++index3, values);
  }
  return value;
}
var init_reduce = __esm({
  "node_modules/d3-array/src/reduce.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/reverse.js
function reverse(values) {
  if (typeof values[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  return Array.from(values).reverse();
}
var init_reverse = __esm({
  "node_modules/d3-array/src/reverse.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/difference.js
function difference(values, ...others) {
  values = new InternSet(values);
  for (const other of others) {
    for (const value of other) {
      values.delete(value);
    }
  }
  return values;
}
var init_difference = __esm({
  "node_modules/d3-array/src/difference.js"() {
    init_shims();
    init_src();
  }
});

// node_modules/d3-array/src/disjoint.js
function disjoint(values, other) {
  const iterator = other[Symbol.iterator](), set4 = new InternSet();
  for (const v2 of values) {
    if (set4.has(v2))
      return false;
    let value, done;
    while ({ value, done } = iterator.next()) {
      if (done)
        break;
      if (Object.is(v2, value))
        return false;
      set4.add(value);
    }
  }
  return true;
}
var init_disjoint = __esm({
  "node_modules/d3-array/src/disjoint.js"() {
    init_shims();
    init_src();
  }
});

// node_modules/d3-array/src/intersection.js
function intersection(values, ...others) {
  values = new InternSet(values);
  others = others.map(set);
  out:
    for (const value of values) {
      for (const other of others) {
        if (!other.has(value)) {
          values.delete(value);
          continue out;
        }
      }
    }
  return values;
}
function set(values) {
  return values instanceof InternSet ? values : new InternSet(values);
}
var init_intersection = __esm({
  "node_modules/d3-array/src/intersection.js"() {
    init_shims();
    init_src();
  }
});

// node_modules/d3-array/src/superset.js
function superset(values, other) {
  const iterator = values[Symbol.iterator](), set4 = new Set();
  for (const o of other) {
    const io = intern(o);
    if (set4.has(io))
      continue;
    let value, done;
    while ({ value, done } = iterator.next()) {
      if (done)
        return false;
      const ivalue = intern(value);
      set4.add(ivalue);
      if (Object.is(io, ivalue))
        break;
    }
  }
  return true;
}
function intern(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
var init_superset = __esm({
  "node_modules/d3-array/src/superset.js"() {
    init_shims();
  }
});

// node_modules/d3-array/src/subset.js
function subset(values, other) {
  return superset(other, values);
}
var init_subset = __esm({
  "node_modules/d3-array/src/subset.js"() {
    init_shims();
    init_superset();
  }
});

// node_modules/d3-array/src/union.js
function union(...others) {
  const set4 = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set4.add(o);
    }
  }
  return set4;
}
var init_union = __esm({
  "node_modules/d3-array/src/union.js"() {
    init_shims();
    init_src();
  }
});

// node_modules/d3-array/src/index.js
var init_src2 = __esm({
  "node_modules/d3-array/src/index.js"() {
    init_shims();
    init_bisect();
    init_ascending();
    init_bisector();
    init_count();
    init_cross();
    init_cumsum();
    init_descending();
    init_deviation();
    init_extent();
    init_fsum();
    init_group();
    init_groupSort();
    init_bin();
    init_freedmanDiaconis();
    init_scott();
    init_sturges();
    init_max();
    init_maxIndex();
    init_mean();
    init_median();
    init_merge();
    init_min();
    init_minIndex();
    init_mode();
    init_nice();
    init_pairs();
    init_permute();
    init_quantile();
    init_quickselect();
    init_range();
    init_rank();
    init_least();
    init_leastIndex();
    init_greatest();
    init_greatestIndex();
    init_scan();
    init_shuffle();
    init_sum();
    init_ticks();
    init_transpose();
    init_variance();
    init_zip();
    init_every();
    init_some();
    init_filter();
    init_map();
    init_reduce();
    init_reverse();
    init_sort();
    init_difference();
    init_disjoint();
    init_intersection();
    init_subset();
    init_superset();
    init_union();
    init_src();
  }
});

// node_modules/d3-axis/src/identity.js
function identity_default(x5) {
  return x5;
}
var init_identity2 = __esm({
  "node_modules/d3-axis/src/identity.js"() {
    init_shims();
  }
});

// node_modules/d3-axis/src/axis.js
function translateX(x5) {
  return "translate(" + x5 + ",0)";
}
function translateY(y4) {
  return "translate(0," + y4 + ")";
}
function number2(scale2) {
  return (d) => +scale2(d);
}
function center(scale2, offset) {
  offset = Math.max(0, scale2.bandwidth() - offset * 2) / 2;
  if (scale2.round())
    offset = Math.round(offset);
  return (d) => +scale2(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale2) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x5 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format3 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range4 = scale2.range(), range0 = +range4[0] + offset, range1 = +range4[range4.length - 1] + offset, position = (scale2.bandwidth ? center : number2)(scale2.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale2).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x5 + "2", k2 * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x5, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position(d) + offset);
    });
    line.attr(x5 + "2", k2 * tickSizeInner);
    text.attr(x5, k2 * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale2 = _, axis2) : scale2;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisTop(scale2) {
  return axis(top, scale2);
}
function axisRight(scale2) {
  return axis(right, scale2);
}
function axisBottom(scale2) {
  return axis(bottom, scale2);
}
function axisLeft(scale2) {
  return axis(left, scale2);
}
var top, right, bottom, left, epsilon;
var init_axis = __esm({
  "node_modules/d3-axis/src/axis.js"() {
    init_shims();
    init_identity2();
    top = 1;
    right = 2;
    bottom = 3;
    left = 4;
    epsilon = 1e-6;
  }
});

// node_modules/d3-axis/src/index.js
var init_src3 = __esm({
  "node_modules/d3-axis/src/index.js"() {
    init_shims();
    init_axis();
  }
});

// node_modules/d3-dispatch/src/dispatch.js
function dispatch() {
  for (var i2 = 0, n = arguments.length, _ = {}, t4; i2 < n; ++i2) {
    if (!(t4 = arguments[i2] + "") || t4 in _ || /[\s.]/.test(t4))
      throw new Error("illegal type: " + t4);
    _[t4] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i2 = t4.indexOf(".");
    if (i2 >= 0)
      name = t4.slice(i2 + 1), t4 = t4.slice(0, i2);
    if (t4 && !types2.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    return { type: t4, name };
  });
}
function get(type2, name) {
  for (var i2 = 0, n = type2.length, c5; i2 < n; ++i2) {
    if ((c5 = type2[i2]).name === name) {
      return c5.value;
    }
  }
}
function set2(type2, name, callback) {
  for (var i2 = 0, n = type2.length; i2 < n; ++i2) {
    if (type2[i2].name === name) {
      type2[i2] = noop3, type2 = type2.slice(0, i2).concat(type2.slice(i2 + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var noop3, dispatch_default;
var init_dispatch = __esm({
  "node_modules/d3-dispatch/src/dispatch.js"() {
    init_shims();
    noop3 = { value: () => {
    } };
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t4, i2 = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i2 < n)
            if ((t4 = (typename = T[i2]).type) && (t4 = get(_[t4], typename.name)))
              return t4;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i2 < n) {
          if (t4 = (typename = T[i2]).type)
            _[t4] = set2(_[t4], typename.name, callback);
          else if (callback == null)
            for (t4 in _)
              _[t4] = set2(_[t4], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy3 = {}, _ = this._;
        for (var t4 in _)
          copy3[t4] = _[t4].slice();
        return new Dispatch(copy3);
      },
      call: function(type2, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i2 = 0, n, t4; i2 < n; ++i2)
            args[i2] = arguments[i2 + 2];
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (t4 = this._[type2], i2 = 0, n = t4.length; i2 < n; ++i2)
          t4[i2].value.apply(that, args);
      },
      apply: function(type2, that, args) {
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (var t4 = this._[type2], i2 = 0, n = t4.length; i2 < n; ++i2)
          t4[i2].value.apply(that, args);
      }
    };
    dispatch_default = dispatch;
  }
});

// node_modules/d3-dispatch/src/index.js
var init_src4 = __esm({
  "node_modules/d3-dispatch/src/index.js"() {
    init_shims();
    init_dispatch();
  }
});

// node_modules/d3-selection/src/namespaces.js
var xhtml, namespaces_default;
var init_namespaces = __esm({
  "node_modules/d3-selection/src/namespaces.js"() {
    init_shims();
    xhtml = "http://www.w3.org/1999/xhtml";
    namespaces_default = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
  }
});

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns")
    name = name.slice(i2 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}
var init_namespace = __esm({
  "node_modules/d3-selection/src/namespace.js"() {
    init_shims();
    init_namespaces();
  }
});

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
var init_creator = __esm({
  "node_modules/d3-selection/src/creator.js"() {
    init_shims();
    init_namespace();
    init_namespaces();
  }
});

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}
var init_selector = __esm({
  "node_modules/d3-selection/src/selector.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
      if ((node = group2[i2]) && (subnode = select.call(node, node.__data__, i2, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_select = __esm({
  "node_modules/d3-selection/src/selection/select.js"() {
    init_shims();
    init_selection();
    init_selector();
  }
});

// node_modules/d3-selection/src/array.js
function array2(x5) {
  return x5 == null ? [] : Array.isArray(x5) ? x5 : Array.from(x5);
}
var init_array2 = __esm({
  "node_modules/d3-selection/src/array.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}
var init_selectorAll = __esm({
  "node_modules/d3-selection/src/selectorAll.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array2(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group2[i2]) {
        subgroups.push(select.call(node, node.__data__, i2, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
var init_selectAll = __esm({
  "node_modules/d3-selection/src/selection/selectAll.js"() {
    init_shims();
    init_selection();
    init_array2();
    init_selectorAll();
  }
});

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}
var init_matcher = __esm({
  "node_modules/d3-selection/src/matcher.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/selectChild.js
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var find;
var init_selectChild = __esm({
  "node_modules/d3-selection/src/selection/selectChild.js"() {
    init_shims();
    init_matcher();
    find = Array.prototype.find;
  }
});

// node_modules/d3-selection/src/selection/selectChildren.js
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter2.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
var filter2;
var init_selectChildren = __esm({
  "node_modules/d3-selection/src/selection/selectChildren.js"() {
    init_shims();
    init_matcher();
    filter2 = Array.prototype.filter;
  }
});

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
      if ((node = group2[i2]) && match.call(node, node.__data__, i2, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_filter2 = __esm({
  "node_modules/d3-selection/src/selection/filter.js"() {
    init_shims();
    init_selection();
    init_matcher();
  }
});

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}
var init_sparse = __esm({
  "node_modules/d3-selection/src/selection/sparse.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
var init_enter = __esm({
  "node_modules/d3-selection/src/selection/enter.js"() {
    init_shims();
    init_sparse();
    init_selection();
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function(selector) {
        return this._parent.querySelectorAll(selector);
      }
    };
  }
});

// node_modules/d3-selection/src/constant.js
function constant_default(x5) {
  return function() {
    return x5;
  };
}
var init_constant2 = __esm({
  "node_modules/d3-selection/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group2, enter, update, exit, data) {
  var i2 = 0, node, groupLength = group2.length, dataLength = data.length;
  for (; i2 < dataLength; ++i2) {
    if (node = group2[i2]) {
      node.__data__ = data[i2];
      update[i2] = node;
    } else {
      enter[i2] = new EnterNode(parent, data[i2]);
    }
  }
  for (; i2 < groupLength; ++i2) {
    if (node = group2[i2]) {
      exit[i2] = node;
    }
  }
}
function bindKey(parent, group2, enter, update, exit, data, key) {
  var i2, node, nodeByKeyValue = new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2) {
    if (node = group2[i2]) {
      keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group2) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i2] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i2 = 0; i2 < dataLength; ++i2) {
    keyValue = key.call(parent, data[i2], i2, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i2] = node;
      node.__data__ = data[i2];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i2] = new EnterNode(parent, data[i2]);
    }
  }
  for (i2 = 0; i2 < groupLength; ++i2) {
    if ((node = group2[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
      exit[i2] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {
    var parent = parents[j], group2 = groups2[j], groupLength = group2.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
var init_data = __esm({
  "node_modules/d3-selection/src/selection/data.js"() {
    init_shims();
    init_selection();
    init_enter();
    init_constant2();
  }
});

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}
var init_exit = __esm({
  "node_modules/d3-selection/src/selection/exit.js"() {
    init_shims();
    init_sparse();
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
var init_join = __esm({
  "node_modules/d3-selection/src/selection/join.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge2[i2] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
var init_merge2 = __esm({
  "node_modules/d3-selection/src/selection/merge.js"() {
    init_shims();
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3; ) {
    for (var group2 = groups2[j], i2 = group2.length - 1, next = group2[i2], node; --i2 >= 0; ) {
      if (node = group2[i2]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
var init_order = __esm({
  "node_modules/d3-selection/src/selection/order.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a3, b) {
    return a3 && b ? compare(a3.__data__, b.__data__) : !a3 - !b;
  }
  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
      if (node = group2[i2]) {
        sortgroup[i2] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a3, b) {
  return a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}
var init_sort2 = __esm({
  "node_modules/d3-selection/src/selection/sort.js"() {
    init_shims();
    init_selection();
  }
});

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
var init_call = __esm({
  "node_modules/d3-selection/src/selection/call.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}
var init_nodes = __esm({
  "node_modules/d3-selection/src/selection/nodes.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group2 = groups2[j], i2 = 0, n = group2.length; i2 < n; ++i2) {
      var node = group2[i2];
      if (node)
        return node;
    }
  }
  return null;
}
var init_node = __esm({
  "node_modules/d3-selection/src/selection/node.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}
var init_size = __esm({
  "node_modules/d3-selection/src/selection/size.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}
var init_empty = __esm({
  "node_modules/d3-selection/src/selection/empty.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group2 = groups2[j], i2 = 0, n = group2.length, node; i2 < n; ++i2) {
      if (node = group2[i2])
        callback.call(node, node.__data__, i2, group2);
    }
  }
  return this;
}
var init_each = __esm({
  "node_modules/d3-selection/src/selection/each.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v2);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
var init_attr = __esm({
  "node_modules/d3-selection/src/selection/attr.js"() {
    init_shims();
    init_namespace();
  }
});

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
var init_window = __esm({
  "node_modules/d3-selection/src/window.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v2, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}
var init_style = __esm({
  "node_modules/d3-selection/src/selection/style.js"() {
    init_shims();
    init_window();
  }
});

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      delete this[name];
    else
      this[name] = v2;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
var init_property = __esm({
  "node_modules/d3-selection/src/selection/property.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
function classedAdd(node, names) {
  var list = classList(node), i2 = -1, n = names.length;
  while (++i2 < n)
    list.add(names[i2]);
}
function classedRemove(node, names) {
  var list = classList(node), i2 = -1, n = names.length;
  while (++i2 < n)
    list.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i2 = -1, n = names.length;
    while (++i2 < n)
      if (!list.contains(names[i2]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
var init_classed = __esm({
  "node_modules/d3-selection/src/selection/classed.js"() {
    init_shims();
    ClassList.prototype = {
      add: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 >= 0) {
          this._names.splice(i2, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
  }
});

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
var init_text = __esm({
  "node_modules/d3-selection/src/selection/text.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
var init_html = __esm({
  "node_modules/d3-selection/src/selection/html.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}
var init_raise = __esm({
  "node_modules/d3-selection/src/selection/raise.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/lower.js
function lower2() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower2);
}
var init_lower = __esm({
  "node_modules/d3-selection/src/selection/lower.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
var init_append = __esm({
  "node_modules/d3-selection/src/selection/append.js"() {
    init_shims();
    init_creator();
  }
});

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}
var init_insert = __esm({
  "node_modules/d3-selection/src/selection/insert.js"() {
    init_shims();
    init_creator();
    init_selector();
  }
});

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}
var init_remove = __esm({
  "node_modules/d3-selection/src/selection/remove.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
var init_clone = __esm({
  "node_modules/d3-selection/src/selection/clone.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
var init_datum = __esm({
  "node_modules/d3-selection/src/selection/datum.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i2 = t4.indexOf(".");
    if (i2 >= 0)
      name = t4.slice(i2 + 1), t4 = t4.slice(0, i2);
    return { type: t4, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i2 = -1, m3 = on.length, o; j < m3; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i2] = o;
      }
    }
    if (++i2)
      on.length = i2;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options2) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m3 = on.length; j < m3; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options2);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options2);
    o = { type: typename.type, name: typename.name, value, listener, options: options2 };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options2) {
  var typenames = parseTypenames2(typename + ""), i2, n = typenames.length, t4;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m3 = on.length, o; j < m3; ++j) {
        for (i2 = 0, o = on[j]; i2 < n; ++i2) {
          if ((t4 = typenames[i2]).type === o.type && t4.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i2 = 0; i2 < n; ++i2)
    this.each(on(typenames[i2], value, options2));
  return this;
}
var init_on = __esm({
  "node_modules/d3-selection/src/selection/on.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
var init_dispatch2 = __esm({
  "node_modules/d3-selection/src/selection/dispatch.js"() {
    init_shims();
    init_window();
  }
});

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {
    for (var group2 = groups2[j], i2 = 0, n = group2.length, node; i2 < n; ++i2) {
      if (node = group2[i2])
        yield node;
    }
  }
}
var init_iterator = __esm({
  "node_modules/d3-selection/src/selection/iterator.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/selection/index.js
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
var root, selection_default;
var init_selection = __esm({
  "node_modules/d3-selection/src/selection/index.js"() {
    init_shims();
    init_select();
    init_selectAll();
    init_selectChild();
    init_selectChildren();
    init_filter2();
    init_data();
    init_enter();
    init_exit();
    init_join();
    init_merge2();
    init_order();
    init_sort2();
    init_call();
    init_nodes();
    init_node();
    init_size();
    init_empty();
    init_each();
    init_attr();
    init_style();
    init_property();
    init_classed();
    init_text();
    init_html();
    init_raise();
    init_lower();
    init_append();
    init_insert();
    init_remove();
    init_clone();
    init_datum();
    init_on();
    init_dispatch2();
    init_iterator();
    root = [null];
    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: select_default,
      selectAll: selectAll_default,
      selectChild: selectChild_default,
      selectChildren: selectChildren_default,
      filter: filter_default,
      data: data_default,
      enter: enter_default,
      exit: exit_default,
      join: join_default,
      merge: merge_default,
      selection: selection_selection,
      order: order_default,
      sort: sort_default,
      call: call_default,
      nodes: nodes_default,
      node: node_default,
      size: size_default,
      empty: empty_default,
      each: each_default,
      attr: attr_default,
      style: style_default,
      property: property_default,
      classed: classed_default,
      text: text_default,
      html: html_default,
      raise: raise_default,
      lower: lower_default,
      append: append_default,
      insert: insert_default,
      remove: remove_default,
      clone: clone_default,
      datum: datum_default,
      on: on_default,
      dispatch: dispatch_default2,
      [Symbol.iterator]: iterator_default
    };
    selection_default = selection;
  }
});

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}
var init_select2 = __esm({
  "node_modules/d3-selection/src/select.js"() {
    init_shims();
    init_selection();
  }
});

// node_modules/d3-selection/src/create.js
function create_default(name) {
  return select_default2(creator_default(name).call(document.documentElement));
}
var init_create = __esm({
  "node_modules/d3-selection/src/create.js"() {
    init_shims();
    init_creator();
    init_select2();
  }
});

// node_modules/d3-selection/src/local.js
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
var nextId;
var init_local = __esm({
  "node_modules/d3-selection/src/local.js"() {
    init_shims();
    nextId = 0;
    Local.prototype = local.prototype = {
      constructor: Local,
      get: function(node) {
        var id2 = this._;
        while (!(id2 in node))
          if (!(node = node.parentNode))
            return;
        return node[id2];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };
  }
});

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}
var init_sourceEvent = __esm({
  "node_modules/d3-selection/src/sourceEvent.js"() {
    init_shims();
  }
});

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg2 = node.ownerSVGElement || node;
    if (svg2.createSVGPoint) {
      var point6 = svg2.createSVGPoint();
      point6.x = event.clientX, point6.y = event.clientY;
      point6 = point6.matrixTransform(node.getScreenCTM().inverse());
      return [point6.x, point6.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var init_pointer = __esm({
  "node_modules/d3-selection/src/pointer.js"() {
    init_shims();
    init_sourceEvent();
  }
});

// node_modules/d3-selection/src/pointers.js
function pointers_default(events, node) {
  if (events.target) {
    events = sourceEvent_default(events);
    if (node === void 0)
      node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, (event) => pointer_default(event, node));
}
var init_pointers = __esm({
  "node_modules/d3-selection/src/pointers.js"() {
    init_shims();
    init_pointer();
    init_sourceEvent();
  }
});

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array2(selector)], root);
}
var init_selectAll2 = __esm({
  "node_modules/d3-selection/src/selectAll.js"() {
    init_shims();
    init_array2();
    init_selection();
  }
});

// node_modules/d3-selection/src/index.js
var init_src5 = __esm({
  "node_modules/d3-selection/src/index.js"() {
    init_shims();
    init_create();
    init_creator();
    init_local();
    init_matcher();
    init_namespace();
    init_namespaces();
    init_pointer();
    init_pointers();
    init_select2();
    init_selectAll2();
    init_selection();
    init_selector();
    init_selectorAll();
    init_style();
    init_window();
  }
});

// node_modules/d3-drag/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var nonpassive, nonpassivecapture;
var init_noevent = __esm({
  "node_modules/d3-drag/src/noevent.js"() {
    init_shims();
    nonpassive = { passive: false };
    nonpassivecapture = { capture: true, passive: false };
  }
});

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root3.__noselect = root3.style.MozUserSelect;
    root3.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", null);
  } else {
    root3.style.MozUserSelect = root3.__noselect;
    delete root3.__noselect;
  }
}
var init_nodrag = __esm({
  "node_modules/d3-drag/src/nodrag.js"() {
    init_shims();
    init_src5();
    init_noevent();
  }
});

// node_modules/d3-drag/src/constant.js
var constant_default2;
var init_constant3 = __esm({
  "node_modules/d3-drag/src/constant.js"() {
    init_shims();
    constant_default2 = (x5) => () => x5;
  }
});

// node_modules/d3-drag/src/event.js
function DragEvent(type2, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x5,
  y: y4,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x5, enumerable: true, configurable: true },
    y: { value: y4, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
var init_event = __esm({
  "node_modules/d3-drag/src/event.js"() {
    init_shims();
    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };
  }
});

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter3 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter3.call(this, event, d))
      return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture)
      return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter3.call(this, event, d))
      return;
    var touches = event.changedTouches, c5 = container.call(this, event, d), n = touches.length, i2, gesture;
    for (i2 = 0; i2 < n; ++i2) {
      if (gesture = beforestart(this, c5, event, d, touches[i2].identifier, touches[i2])) {
        nopropagation(event);
        gesture("start", event, touches[i2]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i2, gesture;
    for (i2 = 0; i2 < n; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i2]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i2, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i2 = 0; i2 < n; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i2]);
      }
    }
  }
  function beforestart(that, container2, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s4;
    if ((s4 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null)
      return;
    dx = s4.x - p[0] || 0;
    dy = s4.y - p[1] || 0;
    return function gesture(type2, event2, touch2) {
      var p02 = p, n;
      switch (type2) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer_default(touch2 || event2, container2), n = active;
          break;
      }
      dispatch2.call(type2, that, new DragEvent(type2, {
        sourceEvent: event2,
        subject: s4,
        target: drag,
        identifier,
        active: n,
        x: p[0] + dx,
        y: p[1] + dy,
        dx: p[0] - p02[0],
        dy: p[1] - p02[1],
        dispatch: dispatch2
      }), d);
    };
  }
  drag.filter = function(_) {
    return arguments.length ? (filter3 = typeof _ === "function" ? _ : constant_default2(!!_), drag) : filter3;
  };
  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag) : container;
  };
  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag) : subject;
  };
  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default2(!!_), drag) : touchable;
  };
  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}
var init_drag = __esm({
  "node_modules/d3-drag/src/drag.js"() {
    init_shims();
    init_src4();
    init_src5();
    init_nodrag();
    init_noevent();
    init_constant3();
    init_event();
  }
});

// node_modules/d3-drag/src/index.js
var init_src6 = __esm({
  "node_modules/d3-drag/src/index.js"() {
    init_shims();
    init_drag();
    init_nodrag();
  }
});

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
var init_define = __esm({
  "node_modules/d3-color/src/define.js"() {
    init_shims();
  }
});

// node_modules/d3-color/src/color.js
function Color() {
}
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b, a3) {
  if (a3 <= 0)
    r2 = g = b = NaN;
  return new Rgb(r2, g, b, a3);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a3 = this.opacity;
  a3 = isNaN(a3) ? 1 : Math.max(0, Math.min(1, a3));
  return (a3 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a3 === 1 ? ")" : ", " + a3 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s4, l, a3) {
  if (a3 <= 0)
    h2 = s4 = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s4 = NaN;
  else if (s4 <= 0)
    h2 = NaN;
  return new Hsl(h2, s4, l, a3);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r2, g, b), max5 = Math.max(r2, g, b), h2 = NaN, s4 = max5 - min4, l = (max5 + min4) / 2;
  if (s4) {
    if (r2 === max5)
      h2 = (g - b) / s4 + (g < b) * 6;
    else if (g === max5)
      h2 = (b - r2) / s4 + 2;
    else
      h2 = (r2 - g) / s4 + 4;
    s4 /= l < 0.5 ? max5 + min4 : 2 - max5 - min4;
    h2 *= 60;
  } else {
    s4 = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s4, l, o.opacity);
}
function hsl(h2, s4, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s4, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s4, l, opacity) {
  this.h = +h2;
  this.s = +s4;
  this.l = +l;
  this.opacity = +opacity;
}
function hsl2rgb(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}
var darker, brighter, reI, reN, reP, reHex, reRgbInteger, reRgbPercent, reRgbaInteger, reRgbaPercent, reHslPercent, reHslaPercent, named;
var init_color = __esm({
  "node_modules/d3-color/src/color.js"() {
    init_shims();
    init_define();
    darker = 0.7;
    brighter = 1 / darker;
    reI = "\\s*([+-]?\\d+)\\s*";
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
    reHex = /^#([0-9a-f]{3,8})$/;
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
    named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define_default(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    define_default(Rgb, rgb, extend(Color, {
      brighter: function(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      darker: function(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    define_default(Hsl, hsl, extend(Color, {
      brighter: function(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      darker: function(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb: function() {
        var h2 = this.h % 360 + (this.h < 0) * 360, s4 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s4, m1 = 2 * l - m22;
        return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22), hsl2rgb(h2, m1, m22), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22), this.opacity);
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a3 = this.opacity;
        a3 = isNaN(a3) ? 1 : Math.max(0, Math.min(1, a3));
        return (a3 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a3 === 1 ? ")" : ", " + a3 + ")");
      }
    }));
  }
});

// node_modules/d3-color/src/math.js
var radians, degrees;
var init_math = __esm({
  "node_modules/d3-color/src/math.js"() {
    init_shims();
    radians = Math.PI / 180;
    degrees = 180 / Math.PI;
  }
});

// node_modules/d3-color/src/lab.js
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r2 = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b) / Yn), x5, z;
  if (r2 === g && g === b)
    x5 = z = y4;
  else {
    x5 = xyz2lab((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x5 - y4), 200 * (y4 - z), o.opacity);
}
function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a3, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a3, b, opacity == null ? 1 : opacity);
}
function Lab(l, a3, b, opacity) {
  this.l = +l;
  this.a = +a3;
  this.b = +b;
  this.opacity = +opacity;
}
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
}
function lrgb2rgb(x5) {
  return 255 * (x5 <= 31308e-7 ? 12.92 * x5 : 1.055 * Math.pow(x5, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x5) {
  return (x5 /= 255) <= 0.04045 ? x5 / 12.92 : Math.pow((x5 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c5, h2, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h2, c5, l, opacity == null ? 1 : opacity);
}
function hcl(h2, c5, l, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c5, l, opacity == null ? 1 : opacity);
}
function Hcl(h2, c5, l, opacity) {
  this.h = +h2;
  this.c = +c5;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * radians;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
var K, Xn, Yn, Zn, t0, t1, t2, t3;
var init_lab = __esm({
  "node_modules/d3-color/src/lab.js"() {
    init_shims();
    init_define();
    init_color();
    init_math();
    K = 18;
    Xn = 0.96422;
    Yn = 1;
    Zn = 0.82521;
    t0 = 4 / 29;
    t1 = 6 / 29;
    t2 = 3 * t1 * t1;
    t3 = t1 * t1 * t1;
    define_default(Lab, lab, extend(Color, {
      brighter: function(k2) {
        return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      darker: function(k2) {
        return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y4 = (this.l + 16) / 116, x5 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;
        x5 = Xn * lab2xyz(x5);
        y4 = Yn * lab2xyz(y4);
        z = Zn * lab2xyz(z);
        return new Rgb(lrgb2rgb(3.1338561 * x5 - 1.6168667 * y4 - 0.4906146 * z), lrgb2rgb(-0.9787684 * x5 + 1.9161415 * y4 + 0.033454 * z), lrgb2rgb(0.0719453 * x5 - 0.2289914 * y4 + 1.4052427 * z), this.opacity);
      }
    }));
    define_default(Hcl, hcl, extend(Color, {
      brighter: function(k2) {
        return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
      },
      darker: function(k2) {
        return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));
  }
});

// node_modules/d3-color/src/cubehelix.js
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r2 - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s4 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h2 = s4 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s4, l, o.opacity);
}
function cubehelix(h2, s4, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s4, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s4, l, opacity) {
  this.h = +h2;
  this.s = +s4;
  this.l = +l;
  this.opacity = +opacity;
}
var A2, B, C, D, E, ED, EB, BC_DA;
var init_cubehelix = __esm({
  "node_modules/d3-color/src/cubehelix.js"() {
    init_shims();
    init_define();
    init_color();
    init_math();
    A2 = -0.14861;
    B = 1.78277;
    C = -0.29227;
    D = -0.90649;
    E = 1.97294;
    ED = E * D;
    EB = E * B;
    BC_DA = B * C - D * A2;
    define_default(Cubehelix, cubehelix, extend(Color, {
      brighter: function(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      darker: function(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb: function() {
        var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
        return new Rgb(255 * (l + a3 * (A2 * cosh2 + B * sinh2)), 255 * (l + a3 * (C * cosh2 + D * sinh2)), 255 * (l + a3 * (E * cosh2)), this.opacity);
      }
    }));
  }
});

// node_modules/d3-color/src/index.js
var init_src7 = __esm({
  "node_modules/d3-color/src/index.js"() {
    init_shims();
    init_color();
    init_lab();
    init_cubehelix();
  }
});

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t4) {
    var i2 = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n - 1) : Math.floor(t4 * n), v1 = values[i2], v2 = values[i2 + 1], v0 = i2 > 0 ? values[i2 - 1] : 2 * v1 - v2, v3 = i2 < n - 1 ? values[i2 + 2] : 2 * v2 - v1;
    return basis((t4 - i2 / n) * n, v0, v1, v2, v3);
  };
}
var init_basis = __esm({
  "node_modules/d3-interpolate/src/basis.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t4) {
    var i2 = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n), v0 = values[(i2 + n - 1) % n], v1 = values[i2 % n], v2 = values[(i2 + 1) % n], v3 = values[(i2 + 2) % n];
    return basis((t4 - i2 / n) * n, v0, v1, v2, v3);
  };
}
var init_basisClosed = __esm({
  "node_modules/d3-interpolate/src/basisClosed.js"() {
    init_shims();
    init_basis();
  }
});

// node_modules/d3-interpolate/src/constant.js
var constant_default3;
var init_constant4 = __esm({
  "node_modules/d3-interpolate/src/constant.js"() {
    init_shims();
    constant_default3 = (x5) => () => x5;
  }
});

// node_modules/d3-interpolate/src/color.js
function linear(a3, d) {
  return function(t4) {
    return a3 + t4 * d;
  };
}
function exponential(a3, b, y4) {
  return a3 = Math.pow(a3, y4), b = Math.pow(b, y4) - a3, y4 = 1 / y4, function(t4) {
    return Math.pow(a3 + t4 * b, y4);
  };
}
function hue(a3, b) {
  var d = b - a3;
  return d ? linear(a3, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a3) ? b : a3);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a3, b) {
    return b - a3 ? exponential(a3, b, y4) : constant_default3(isNaN(a3) ? b : a3);
  };
}
function nogamma(a3, b) {
  var d = b - a3;
  return d ? linear(a3, d) : constant_default3(isNaN(a3) ? b : a3);
}
var init_color2 = __esm({
  "node_modules/d3-interpolate/src/color.js"() {
    init_shims();
    init_constant4();
  }
});

// node_modules/d3-interpolate/src/rgb.js
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r2 = new Array(n), g = new Array(n), b = new Array(n), i2, color2;
    for (i2 = 0; i2 < n; ++i2) {
      color2 = rgb(colors[i2]);
      r2[i2] = color2.r || 0;
      g[i2] = color2.g || 0;
      b[i2] = color2.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t4) {
      color2.r = r2(t4);
      color2.g = g(t4);
      color2.b = b(t4);
      return color2 + "";
    };
  };
}
var rgb_default, rgbBasis, rgbBasisClosed;
var init_rgb = __esm({
  "node_modules/d3-interpolate/src/rgb.js"() {
    init_shims();
    init_src7();
    init_basis();
    init_basisClosed();
    init_color2();
    rgb_default = function rgbGamma(y4) {
      var color2 = gamma(y4);
      function rgb2(start2, end) {
        var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
        return function(t4) {
          start2.r = r2(t4);
          start2.g = g(t4);
          start2.b = b(t4);
          start2.opacity = opacity(t4);
          return start2 + "";
        };
      }
      rgb2.gamma = rgbGamma;
      return rgb2;
    }(1);
    rgbBasis = rgbSpline(basis_default);
    rgbBasisClosed = rgbSpline(basisClosed_default);
  }
});

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a3, b) {
  if (!b)
    b = [];
  var n = a3 ? Math.min(b.length, a3.length) : 0, c5 = b.slice(), i2;
  return function(t4) {
    for (i2 = 0; i2 < n; ++i2)
      c5[i2] = a3[i2] * (1 - t4) + b[i2] * t4;
    return c5;
  };
}
function isNumberArray(x5) {
  return ArrayBuffer.isView(x5) && !(x5 instanceof DataView);
}
var init_numberArray = __esm({
  "node_modules/d3-interpolate/src/numberArray.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/array.js
function array_default(a3, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a3, b);
}
function genericArray(a3, b) {
  var nb = b ? b.length : 0, na = a3 ? Math.min(nb, a3.length) : 0, x5 = new Array(na), c5 = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2)
    x5[i2] = value_default(a3[i2], b[i2]);
  for (; i2 < nb; ++i2)
    c5[i2] = b[i2];
  return function(t4) {
    for (i2 = 0; i2 < na; ++i2)
      c5[i2] = x5[i2](t4);
    return c5;
  };
}
var init_array3 = __esm({
  "node_modules/d3-interpolate/src/array.js"() {
    init_shims();
    init_value();
    init_numberArray();
  }
});

// node_modules/d3-interpolate/src/date.js
function date_default(a3, b) {
  var d = new Date();
  return a3 = +a3, b = +b, function(t4) {
    return d.setTime(a3 * (1 - t4) + b * t4), d;
  };
}
var init_date = __esm({
  "node_modules/d3-interpolate/src/date.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b) {
  return a3 = +a3, b = +b, function(t4) {
    return a3 * (1 - t4) + b * t4;
  };
}
var init_number2 = __esm({
  "node_modules/d3-interpolate/src/number.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/object.js
function object_default(a3, b) {
  var i2 = {}, c5 = {}, k2;
  if (a3 === null || typeof a3 !== "object")
    a3 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a3) {
      i2[k2] = value_default(a3[k2], b[k2]);
    } else {
      c5[k2] = b[k2];
    }
  }
  return function(t4) {
    for (k2 in i2)
      c5[k2] = i2[k2](t4);
    return c5;
  };
}
var init_object = __esm({
  "node_modules/d3-interpolate/src/object.js"() {
    init_shims();
    init_value();
  }
});

// node_modules/d3-interpolate/src/string.js
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t4) {
    return b(t4) + "";
  };
}
function string_default(a3, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s4 = [], q = [];
  a3 = a3 + "", b = b + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s4[i2])
        s4[i2] += bs;
      else
        s4[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s4[i2])
        s4[i2] += bm;
      else
        s4[++i2] = bm;
    } else {
      s4[++i2] = null;
      q.push({ i: i2, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s4[i2])
      s4[i2] += bs;
    else
      s4[++i2] = bs;
  }
  return s4.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t4) {
    for (var i3 = 0, o; i3 < b; ++i3)
      s4[(o = q[i3]).i] = o.x(t4);
    return s4.join("");
  });
}
var reA, reB;
var init_string = __esm({
  "node_modules/d3-interpolate/src/string.js"() {
    init_shims();
    init_number2();
    reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    reB = new RegExp(reA.source, "g");
  }
});

// node_modules/d3-interpolate/src/value.js
function value_default(a3, b) {
  var t4 = typeof b, c5;
  return b == null || t4 === "boolean" ? constant_default3(b) : (t4 === "number" ? number_default : t4 === "string" ? (c5 = color(b)) ? (b = c5, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a3, b);
}
var init_value = __esm({
  "node_modules/d3-interpolate/src/value.js"() {
    init_shims();
    init_src7();
    init_rgb();
    init_array3();
    init_date();
    init_number2();
    init_object();
    init_string();
    init_constant4();
    init_numberArray();
  }
});

// node_modules/d3-interpolate/src/discrete.js
function discrete_default(range4) {
  var n = range4.length;
  return function(t4) {
    return range4[Math.max(0, Math.min(n - 1, Math.floor(t4 * n)))];
  };
}
var init_discrete = __esm({
  "node_modules/d3-interpolate/src/discrete.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/hue.js
function hue_default(a3, b) {
  var i2 = hue(+a3, +b);
  return function(t4) {
    var x5 = i2(t4);
    return x5 - 360 * Math.floor(x5 / 360);
  };
}
var init_hue = __esm({
  "node_modules/d3-interpolate/src/hue.js"() {
    init_shims();
    init_color2();
  }
});

// node_modules/d3-interpolate/src/round.js
function round_default(a3, b) {
  return a3 = +a3, b = +b, function(t4) {
    return Math.round(a3 * (1 - t4) + b * t4);
  };
}
var init_round = __esm({
  "node_modules/d3-interpolate/src/round.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/transform/decompose.js
function decompose_default(a3, b, c5, d, e3, f3) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b * b))
    a3 /= scaleX, b /= scaleX;
  if (skewX = a3 * c5 + b * d)
    c5 -= a3 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c5 * c5 + d * d))
    c5 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a3 * d < b * c5)
    a3 = -a3, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f3,
    rotate: Math.atan2(b, a3) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}
var degrees2, identity2;
var init_decompose = __esm({
  "node_modules/d3-interpolate/src/transform/decompose.js"() {
    init_shims();
    degrees2 = 180 / Math.PI;
    identity2 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
  }
});

// node_modules/d3-interpolate/src/transform/parse.js
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null)
    return identity2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}
var svgNode;
var init_parse = __esm({
  "node_modules/d3-interpolate/src/transform/parse.js"() {
    init_shims();
    init_decompose();
  }
});

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s4) {
    return s4.length ? s4.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s4, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s4.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s4.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a3, b, s4, q) {
    if (a3 !== b) {
      if (a3 - b > 180)
        b += 360;
      else if (b - a3 > 180)
        a3 += 360;
      q.push({ i: s4.push(pop(s4) + "rotate(", null, degParen) - 2, x: number_default(a3, b) });
    } else if (b) {
      s4.push(pop(s4) + "rotate(" + b + degParen);
    }
  }
  function skewX(a3, b, s4, q) {
    if (a3 !== b) {
      q.push({ i: s4.push(pop(s4) + "skewX(", null, degParen) - 2, x: number_default(a3, b) });
    } else if (b) {
      s4.push(pop(s4) + "skewX(" + b + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s4, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s4.push(pop(s4) + "scale(", null, ",", null, ")");
      q.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s4.push(pop(s4) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b) {
    var s4 = [], q = [];
    a3 = parse(a3), b = parse(b);
    translate(a3.translateX, a3.translateY, b.translateX, b.translateY, s4, q);
    rotate(a3.rotate, b.rotate, s4, q);
    skewX(a3.skewX, b.skewX, s4, q);
    scale2(a3.scaleX, a3.scaleY, b.scaleX, b.scaleY, s4, q);
    a3 = b = null;
    return function(t4) {
      var i2 = -1, n = q.length, o;
      while (++i2 < n)
        s4[(o = q[i2]).i] = o.x(t4);
      return s4.join("");
    };
  };
}
var interpolateTransformCss, interpolateTransformSvg;
var init_transform = __esm({
  "node_modules/d3-interpolate/src/transform/index.js"() {
    init_shims();
    init_number2();
    init_parse();
    interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  }
});

// node_modules/d3-interpolate/src/zoom.js
function cosh(x5) {
  return ((x5 = Math.exp(x5)) + 1 / x5) / 2;
}
function sinh(x5) {
  return ((x5 = Math.exp(x5)) - 1 / x5) / 2;
}
function tanh(x5) {
  return ((x5 = Math.exp(2 * x5)) - 1) / (x5 + 1);
}
var epsilon2, zoom_default;
var init_zoom = __esm({
  "node_modules/d3-interpolate/src/zoom.js"() {
    init_shims();
    epsilon2 = 1e-12;
    zoom_default = function zoomRho(rho, rho2, rho4) {
      function zoom(p02, p1) {
        var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
        if (d2 < epsilon2) {
          S2 = Math.log(w1 / w0) / rho;
          i2 = function(t4) {
            return [
              ux0 + t4 * dx,
              uy0 + t4 * dy,
              w0 * Math.exp(rho * t4 * S2)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
          S2 = (r1 - r0) / rho;
          i2 = function(t4) {
            var s4 = t4 * S2, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s4 + r0) - sinh(r0));
            return [
              ux0 + u4 * dx,
              uy0 + u4 * dy,
              w0 * coshr0 / cosh(rho * s4 + r0)
            ];
          };
        }
        i2.duration = S2 * 1e3 * rho / Math.SQRT2;
        return i2;
      }
      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom;
    }(Math.SQRT2, 2, 4);
  }
});

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h2 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s4 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h2(t4);
      start2.s = s4(t4);
      start2.l = l(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
var hsl_default, hslLong;
var init_hsl = __esm({
  "node_modules/d3-interpolate/src/hsl.js"() {
    init_shims();
    init_src7();
    init_color2();
    hsl_default = hsl2(hue);
    hslLong = hsl2(nogamma);
  }
});

// node_modules/d3-interpolate/src/lab.js
function lab2(start2, end) {
  var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a3 = nogamma(start2.a, end.a), b = nogamma(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
  return function(t4) {
    start2.l = l(t4);
    start2.a = a3(t4);
    start2.b = b(t4);
    start2.opacity = opacity(t4);
    return start2 + "";
  };
}
var init_lab2 = __esm({
  "node_modules/d3-interpolate/src/lab.js"() {
    init_shims();
    init_src7();
    init_color2();
  }
});

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h2 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c5 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h2(t4);
      start2.c = c5(t4);
      start2.l = l(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
var hcl_default, hclLong;
var init_hcl = __esm({
  "node_modules/d3-interpolate/src/hcl.js"() {
    init_shims();
    init_src7();
    init_color2();
    hcl_default = hcl2(hue);
    hclLong = hcl2(nogamma);
  }
});

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start2, end) {
      var h2 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s4 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t4) {
        start2.h = h2(t4);
        start2.s = s4(t4);
        start2.l = l(Math.pow(t4, y4));
        start2.opacity = opacity(t4);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default, cubehelixLong;
var init_cubehelix2 = __esm({
  "node_modules/d3-interpolate/src/cubehelix.js"() {
    init_shims();
    init_src7();
    init_color2();
    cubehelix_default = cubehelix2(hue);
    cubehelixLong = cubehelix2(nogamma);
  }
});

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values) {
  if (values === void 0)
    values = interpolate, interpolate = value_default;
  var i2 = 0, n = values.length - 1, v2 = values[0], I = new Array(n < 0 ? 0 : n);
  while (i2 < n)
    I[i2] = interpolate(v2, v2 = values[++i2]);
  return function(t4) {
    var i3 = Math.max(0, Math.min(n - 1, Math.floor(t4 *= n)));
    return I[i3](t4 - i3);
  };
}
var init_piecewise = __esm({
  "node_modules/d3-interpolate/src/piecewise.js"() {
    init_shims();
    init_value();
  }
});

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n) {
  var samples = new Array(n);
  for (var i2 = 0; i2 < n; ++i2)
    samples[i2] = interpolator(i2 / (n - 1));
  return samples;
}
var init_quantize = __esm({
  "node_modules/d3-interpolate/src/quantize.js"() {
    init_shims();
  }
});

// node_modules/d3-interpolate/src/index.js
var init_src8 = __esm({
  "node_modules/d3-interpolate/src/index.js"() {
    init_shims();
    init_value();
    init_array3();
    init_basis();
    init_basisClosed();
    init_date();
    init_discrete();
    init_hue();
    init_number2();
    init_numberArray();
    init_object();
    init_round();
    init_string();
    init_transform();
    init_zoom();
    init_rgb();
    init_hsl();
    init_lab2();
    init_hcl();
    init_cubehelix2();
    init_piecewise();
    init_quantize();
  }
});

// node_modules/d3-timer/src/timer.js
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
function timer(callback, delay, time2) {
  var t4 = new Timer();
  t4.restart(callback, delay, time2);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e3;
  while (t4) {
    if ((e3 = clockNow - t4._time) >= 0)
      t4._call.call(void 0, e3);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay = now3 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now3;
}
function nap() {
  var t03, t13 = taskHead, t22, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time)
        time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
var frame, timeout, interval, pokeDelay, taskHead, taskTail, clockLast, clockNow, clockSkew, clock, setFrame;
var init_timer = __esm({
  "node_modules/d3-timer/src/timer.js"() {
    init_shims();
    frame = 0;
    timeout = 0;
    interval = 0;
    pokeDelay = 1e3;
    clockLast = 0;
    clockNow = 0;
    clockSkew = 0;
    clock = typeof performance === "object" && performance.now ? performance : Date;
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f3) {
      setTimeout(f3, 17);
    };
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time2) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time2;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
  }
});

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t4 = new Timer();
  delay = delay == null ? 0 : +delay;
  t4.restart((elapsed) => {
    t4.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t4;
}
var init_timeout = __esm({
  "node_modules/d3-timer/src/timeout.js"() {
    init_shims();
    init_timer();
  }
});

// node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time2) {
  var t4 = new Timer(), total = delay;
  if (delay == null)
    return t4.restart(callback, delay, time2), t4;
  t4._restart = t4.restart;
  t4.restart = function(callback2, delay2, time3) {
    delay2 = +delay2, time3 = time3 == null ? now() : +time3;
    t4._restart(function tick(elapsed) {
      elapsed += total;
      t4._restart(tick, total += delay2, time3);
      callback2(elapsed);
    }, delay2, time3);
  };
  t4.restart(callback, delay, time2);
  return t4;
}
var init_interval = __esm({
  "node_modules/d3-timer/src/interval.js"() {
    init_shims();
    init_timer();
  }
});

// node_modules/d3-timer/src/index.js
var init_src9 = __esm({
  "node_modules/d3-timer/src/index.js"() {
    init_shims();
    init_timer();
    init_timeout();
    init_interval();
  }
});

// node_modules/d3-transition/src/transition/schedule.js
function schedule_default(node, name, id2, index3, group2, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index3,
    group: group2,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set3(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i2 in schedules) {
      o = schedules[i2];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i2];
      } else if (+i2 < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i2];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i2 = 0, j = -1; i2 < n; ++i2) {
      if (o = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t4 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n = tween.length;
    while (++i2 < n) {
      tween[i2].call(node, t4);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i2 in schedules)
      return;
    delete node.__transition;
  }
}
var emptyOn, emptyTween, CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED;
var init_schedule = __esm({
  "node_modules/d3-transition/src/transition/schedule.js"() {
    init_shims();
    init_src4();
    init_src9();
    emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
    emptyTween = [];
    CREATED = 0;
    SCHEDULED = 1;
    STARTING = 2;
    STARTED = 3;
    RUNNING = 4;
    ENDING = 5;
    ENDED = 6;
  }
});

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty5 = true, i2;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i2 in schedules) {
    if ((schedule = schedules[i2]).name !== name) {
      empty5 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i2];
  }
  if (empty5)
    delete node.__transition;
}
var init_interrupt = __esm({
  "node_modules/d3-transition/src/interrupt.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}
var init_interrupt2 = __esm({
  "node_modules/d3-transition/src/selection/interrupt.js"() {
    init_shims();
    init_interrupt();
  }
});

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set3(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n = tween1.length; i2 < n; ++i2) {
        if (tween1[i2].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i2, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set3(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t4 = { name, value }, i2 = 0, n = tween1.length; i2 < n; ++i2) {
        if (tween1[i2].name === name) {
          tween1[i2] = t4;
          break;
        }
      }
      if (i2 === n)
        tween1.push(t4);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i2 = 0, n = tween.length, t4; i2 < n; ++i2) {
      if ((t4 = tween[i2]).name === name) {
        return t4.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set3(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}
var init_tween = __esm({
  "node_modules/d3-transition/src/transition/tween.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a3, b) {
  var c5;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c5 = color(b)) ? (b = c5, rgb_default) : string_default)(a3, b);
}
var init_interpolate = __esm({
  "node_modules/d3-transition/src/transition/interpolate.js"() {
    init_shims();
    init_src7();
    init_src8();
  }
});

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i2, value));
}
var init_attr2 = __esm({
  "node_modules/d3-transition/src/transition/attr.js"() {
    init_shims();
    init_src8();
    init_src5();
    init_tween();
    init_interpolate();
  }
});

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i2) {
  return function(t4) {
    this.setAttribute(name, i2.call(this, t4));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t4) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t4));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t03 = (i0 = i2) && attrInterpolateNS(fullname, i2);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t03, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t03 = (i0 = i2) && attrInterpolate(name, i2);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
var init_attrTween = __esm({
  "node_modules/d3-transition/src/transition/attrTween.js"() {
    init_shims();
    init_src5();
  }
});

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}
var init_delay = __esm({
  "node_modules/d3-transition/src/transition/delay.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set3(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set3(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}
var init_duration = __esm({
  "node_modules/d3-transition/src/transition/duration.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set3(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}
var init_ease = __esm({
  "node_modules/d3-transition/src/transition/ease.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function")
      throw new Error();
    set3(this, id2).ease = v2;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
var init_easeVarying = __esm({
  "node_modules/d3-transition/src/transition/easeVarying.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
      if ((node = group2[i2]) && match.call(node, node.__data__, i2, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
var init_filter3 = __esm({
  "node_modules/d3-transition/src/transition/filter.js"() {
    init_shims();
    init_src5();
    init_transition2();
  }
});

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge2[i2] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
var init_merge3 = __esm({
  "node_modules/d3-transition/src/transition/merge.js"() {
    init_shims();
    init_transition2();
  }
});

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t4) {
    var i2 = t4.indexOf(".");
    if (i2 >= 0)
      t4 = t4.slice(0, i2);
    return !t4 || t4 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set3;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
var init_on2 = __esm({
  "node_modules/d3-transition/src/transition/on.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition)
      if (+i2 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}
var init_remove2 = __esm({
  "node_modules/d3-transition/src/transition/remove.js"() {
    init_shims();
  }
});

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
      if ((node = group2[i2]) && (subnode = select.call(node, node.__data__, i2, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
        schedule_default(subgroup[i2], name, id2, i2, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
var init_select3 = __esm({
  "node_modules/d3-transition/src/transition/select.js"() {
    init_shims();
    init_src5();
    init_transition2();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group2[i2]) {
        for (var children2 = select.call(node, node.__data__, i2, group2), child, inherit2 = get2(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {
          if (child = children2[k2]) {
            schedule_default(child, name, id2, k2, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var init_selectAll3 = __esm({
  "node_modules/d3-transition/src/transition/selectAll.js"() {
    init_shims();
    init_src5();
    init_transition2();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/selection.js
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}
var Selection2;
var init_selection2 = __esm({
  "node_modules/d3-transition/src/transition/selection.js"() {
    init_shims();
    init_src5();
    Selection2 = selection_default.prototype.constructor;
  }
});

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set3(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i2, value), priority).on("end.style." + name, null);
}
var init_style2 = __esm({
  "node_modules/d3-transition/src/transition/style.js"() {
    init_shims();
    init_src8();
    init_src5();
    init_schedule();
    init_tween();
    init_interpolate();
  }
});

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i2, priority) {
  return function(t4) {
    this.style.setProperty(name, i2.call(this, t4), priority);
  };
}
function styleTween(name, value, priority) {
  var t4, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t4 = (i0 = i2) && styleInterpolate(name, i2, priority);
    return t4;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
var init_styleTween = __esm({
  "node_modules/d3-transition/src/transition/styleTween.js"() {
    init_shims();
  }
});

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}
var init_text2 = __esm({
  "node_modules/d3-transition/src/transition/text.js"() {
    init_shims();
    init_tween();
  }
});

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i2) {
  return function(t4) {
    this.textContent = i2.call(this, t4);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t03 = (i0 = i2) && textInterpolate(i2);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
var init_textTween = __esm({
  "node_modules/d3-transition/src/transition/textTween.js"() {
    init_shims();
  }
});

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group2[i2]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i2, group2, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}
var init_transition = __esm({
  "node_modules/d3-transition/src/transition/transition.js"() {
    init_shims();
    init_transition2();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve2, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve2();
    } };
    that.each(function() {
      var schedule = set3(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve2();
  });
}
var init_end = __esm({
  "node_modules/d3-transition/src/transition/end.js"() {
    init_shims();
    init_schedule();
  }
});

// node_modules/d3-transition/src/transition/index.js
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var id, selection_prototype;
var init_transition2 = __esm({
  "node_modules/d3-transition/src/transition/index.js"() {
    init_shims();
    init_src5();
    init_attr2();
    init_attrTween();
    init_delay();
    init_duration();
    init_ease();
    init_easeVarying();
    init_filter3();
    init_merge3();
    init_on2();
    init_remove2();
    init_select3();
    init_selectAll3();
    init_selection2();
    init_style2();
    init_styleTween();
    init_text2();
    init_textTween();
    init_transition();
    init_tween();
    init_end();
    id = 0;
    selection_prototype = selection_default.prototype;
    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: select_default3,
      selectAll: selectAll_default3,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: filter_default2,
      merge: merge_default2,
      selection: selection_default2,
      transition: transition_default,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: on_default2,
      attr: attr_default2,
      attrTween: attrTween_default,
      style: style_default2,
      styleTween: styleTween_default,
      text: text_default2,
      textTween: textTween_default,
      remove: remove_default2,
      tween: tween_default,
      delay: delay_default,
      duration: duration_default,
      ease: ease_default,
      easeVarying: easeVarying_default,
      end: end_default,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
  }
});

// node_modules/d3-ease/src/linear.js
var linear2;
var init_linear = __esm({
  "node_modules/d3-ease/src/linear.js"() {
    init_shims();
    linear2 = (t4) => +t4;
  }
});

// node_modules/d3-ease/src/quad.js
function quadIn(t4) {
  return t4 * t4;
}
function quadOut(t4) {
  return t4 * (2 - t4);
}
function quadInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 : --t4 * (2 - t4) + 1) / 2;
}
var init_quad = __esm({
  "node_modules/d3-ease/src/quad.js"() {
    init_shims();
  }
});

// node_modules/d3-ease/src/cubic.js
function cubicIn(t4) {
  return t4 * t4 * t4;
}
function cubicOut(t4) {
  return --t4 * t4 * t4 + 1;
}
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}
var init_cubic = __esm({
  "node_modules/d3-ease/src/cubic.js"() {
    init_shims();
  }
});

// node_modules/d3-ease/src/poly.js
var exponent, polyIn, polyOut, polyInOut;
var init_poly = __esm({
  "node_modules/d3-ease/src/poly.js"() {
    init_shims();
    exponent = 3;
    polyIn = function custom(e3) {
      e3 = +e3;
      function polyIn2(t4) {
        return Math.pow(t4, e3);
      }
      polyIn2.exponent = custom;
      return polyIn2;
    }(exponent);
    polyOut = function custom2(e3) {
      e3 = +e3;
      function polyOut2(t4) {
        return 1 - Math.pow(1 - t4, e3);
      }
      polyOut2.exponent = custom2;
      return polyOut2;
    }(exponent);
    polyInOut = function custom3(e3) {
      e3 = +e3;
      function polyInOut2(t4) {
        return ((t4 *= 2) <= 1 ? Math.pow(t4, e3) : 2 - Math.pow(2 - t4, e3)) / 2;
      }
      polyInOut2.exponent = custom3;
      return polyInOut2;
    }(exponent);
  }
});

// node_modules/d3-ease/src/sin.js
function sinIn(t4) {
  return +t4 === 1 ? 1 : 1 - Math.cos(t4 * halfPi);
}
function sinOut(t4) {
  return Math.sin(t4 * halfPi);
}
function sinInOut(t4) {
  return (1 - Math.cos(pi * t4)) / 2;
}
var pi, halfPi;
var init_sin = __esm({
  "node_modules/d3-ease/src/sin.js"() {
    init_shims();
    pi = Math.PI;
    halfPi = pi / 2;
  }
});

// node_modules/d3-ease/src/math.js
function tpmt(x5) {
  return (Math.pow(2, -10 * x5) - 9765625e-10) * 1.0009775171065494;
}
var init_math2 = __esm({
  "node_modules/d3-ease/src/math.js"() {
    init_shims();
  }
});

// node_modules/d3-ease/src/exp.js
function expIn(t4) {
  return tpmt(1 - +t4);
}
function expOut(t4) {
  return 1 - tpmt(t4);
}
function expInOut(t4) {
  return ((t4 *= 2) <= 1 ? tpmt(1 - t4) : 2 - tpmt(t4 - 1)) / 2;
}
var init_exp = __esm({
  "node_modules/d3-ease/src/exp.js"() {
    init_shims();
    init_math2();
  }
});

// node_modules/d3-ease/src/circle.js
function circleIn(t4) {
  return 1 - Math.sqrt(1 - t4 * t4);
}
function circleOut(t4) {
  return Math.sqrt(1 - --t4 * t4);
}
function circleInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - Math.sqrt(1 - t4 * t4) : Math.sqrt(1 - (t4 -= 2) * t4) + 1) / 2;
}
var init_circle = __esm({
  "node_modules/d3-ease/src/circle.js"() {
    init_shims();
  }
});

// node_modules/d3-ease/src/bounce.js
function bounceIn(t4) {
  return 1 - bounceOut(1 - t4);
}
function bounceOut(t4) {
  return (t4 = +t4) < b1 ? b0 * t4 * t4 : t4 < b3 ? b0 * (t4 -= b2) * t4 + b4 : t4 < b6 ? b0 * (t4 -= b5) * t4 + b7 : b0 * (t4 -= b8) * t4 + b9;
}
function bounceInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - bounceOut(1 - t4) : bounceOut(t4 - 1) + 1) / 2;
}
var b1, b2, b3, b4, b5, b6, b7, b8, b9, b0;
var init_bounce = __esm({
  "node_modules/d3-ease/src/bounce.js"() {
    init_shims();
    b1 = 4 / 11;
    b2 = 6 / 11;
    b3 = 8 / 11;
    b4 = 3 / 4;
    b5 = 9 / 11;
    b6 = 10 / 11;
    b7 = 15 / 16;
    b8 = 21 / 22;
    b9 = 63 / 64;
    b0 = 1 / b1 / b1;
  }
});

// node_modules/d3-ease/src/back.js
var overshoot, backIn, backOut, backInOut;
var init_back = __esm({
  "node_modules/d3-ease/src/back.js"() {
    init_shims();
    overshoot = 1.70158;
    backIn = function custom4(s4) {
      s4 = +s4;
      function backIn2(t4) {
        return (t4 = +t4) * t4 * (s4 * (t4 - 1) + t4);
      }
      backIn2.overshoot = custom4;
      return backIn2;
    }(overshoot);
    backOut = function custom5(s4) {
      s4 = +s4;
      function backOut2(t4) {
        return --t4 * t4 * ((t4 + 1) * s4 + t4) + 1;
      }
      backOut2.overshoot = custom5;
      return backOut2;
    }(overshoot);
    backInOut = function custom6(s4) {
      s4 = +s4;
      function backInOut2(t4) {
        return ((t4 *= 2) < 1 ? t4 * t4 * ((s4 + 1) * t4 - s4) : (t4 -= 2) * t4 * ((s4 + 1) * t4 + s4) + 2) / 2;
      }
      backInOut2.overshoot = custom6;
      return backInOut2;
    }(overshoot);
  }
});

// node_modules/d3-ease/src/elastic.js
var tau, amplitude, period, elasticIn, elasticOut, elasticInOut;
var init_elastic = __esm({
  "node_modules/d3-ease/src/elastic.js"() {
    init_shims();
    init_math2();
    tau = 2 * Math.PI;
    amplitude = 1;
    period = 0.3;
    elasticIn = function custom7(a3, p) {
      var s4 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p /= tau);
      function elasticIn2(t4) {
        return a3 * tpmt(- --t4) * Math.sin((s4 - t4) / p);
      }
      elasticIn2.amplitude = function(a4) {
        return custom7(a4, p * tau);
      };
      elasticIn2.period = function(p2) {
        return custom7(a3, p2);
      };
      return elasticIn2;
    }(amplitude, period);
    elasticOut = function custom8(a3, p) {
      var s4 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p /= tau);
      function elasticOut2(t4) {
        return 1 - a3 * tpmt(t4 = +t4) * Math.sin((t4 + s4) / p);
      }
      elasticOut2.amplitude = function(a4) {
        return custom8(a4, p * tau);
      };
      elasticOut2.period = function(p2) {
        return custom8(a3, p2);
      };
      return elasticOut2;
    }(amplitude, period);
    elasticInOut = function custom9(a3, p) {
      var s4 = Math.asin(1 / (a3 = Math.max(1, a3))) * (p /= tau);
      function elasticInOut2(t4) {
        return ((t4 = t4 * 2 - 1) < 0 ? a3 * tpmt(-t4) * Math.sin((s4 - t4) / p) : 2 - a3 * tpmt(t4) * Math.sin((s4 + t4) / p)) / 2;
      }
      elasticInOut2.amplitude = function(a4) {
        return custom9(a4, p * tau);
      };
      elasticInOut2.period = function(p2) {
        return custom9(a3, p2);
      };
      return elasticInOut2;
    }(amplitude, period);
  }
});

// node_modules/d3-ease/src/index.js
var init_src10 = __esm({
  "node_modules/d3-ease/src/index.js"() {
    init_shims();
    init_linear();
    init_quad();
    init_cubic();
    init_poly();
    init_sin();
    init_exp();
    init_circle();
    init_bounce();
    init_back();
    init_elastic();
  }
});

// node_modules/d3-transition/src/selection/transition.js
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {
    for (var group2 = groups2[j], n = group2.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group2[i2]) {
        schedule_default(node, name, id2, i2, group2, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}
var defaultTiming;
var init_transition3 = __esm({
  "node_modules/d3-transition/src/selection/transition.js"() {
    init_shims();
    init_transition2();
    init_schedule();
    init_src10();
    init_src9();
    defaultTiming = {
      time: null,
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
  }
});

// node_modules/d3-transition/src/selection/index.js
var init_selection3 = __esm({
  "node_modules/d3-transition/src/selection/index.js"() {
    init_shims();
    init_src5();
    init_interrupt2();
    init_transition3();
    selection_default.prototype.interrupt = interrupt_default2;
    selection_default.prototype.transition = transition_default2;
  }
});

// node_modules/d3-transition/src/active.js
function active_default(node, name) {
  var schedules = node.__transition, schedule, i2;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule = schedules[i2]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root2, name, +i2);
      }
    }
  }
  return null;
}
var root2;
var init_active = __esm({
  "node_modules/d3-transition/src/active.js"() {
    init_shims();
    init_transition2();
    init_schedule();
    root2 = [null];
  }
});

// node_modules/d3-transition/src/index.js
var init_src11 = __esm({
  "node_modules/d3-transition/src/index.js"() {
    init_shims();
    init_selection3();
    init_transition2();
    init_active();
    init_interrupt();
  }
});

// node_modules/d3-brush/src/constant.js
var constant_default4;
var init_constant5 = __esm({
  "node_modules/d3-brush/src/constant.js"() {
    init_shims();
    constant_default4 = (x5) => () => x5;
  }
});

// node_modules/d3-brush/src/event.js
function BrushEvent(type2, {
  sourceEvent,
  target,
  selection: selection2,
  mode: mode2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    selection: { value: selection2, enumerable: true, configurable: true },
    mode: { value: mode2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
var init_event2 = __esm({
  "node_modules/d3-brush/src/event.js"() {
    init_shims();
  }
});

// node_modules/d3-brush/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var init_noevent2 = __esm({
  "node_modules/d3-brush/src/noevent.js"() {
    init_shims();
  }
});

// node_modules/d3-brush/src/brush.js
function number1(e3) {
  return [+e3[0], +e3[1]];
}
function number22(e3) {
  return [number1(e3[0]), number1(e3[1])];
}
function type(t4) {
  return { type: t4 };
}
function defaultFilter2(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg2 = this.ownerSVGElement || this;
  if (svg2.hasAttribute("viewBox")) {
    svg2 = svg2.viewBox.baseVal;
    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];
  }
  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local2(node) {
  while (!node.__brush)
    if (!(node = node.parentNode))
      return;
  return node.__brush;
}
function empty3(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}
function brushX() {
  return brush(X);
}
function brushY() {
  return brush(Y);
}
function brush_default() {
  return brush(XY);
}
function brush(dim) {
  var extent2 = defaultExtent, filter3 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group2) {
    var overlay = group2.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local2(this).extent;
      select_default2(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group2.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group2.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group2.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group2, selection2, event) {
    if (group2.tween) {
      group2.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i2 = value_default(selection0, selection1);
        function tween(t4) {
          state.selection = t4 === 1 && selection1 === null ? null : i2(t4);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group2.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt_default(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush2.clear = function(group2, event) {
    brush2.move(group2, null, event);
  };
  function redraw() {
    var group2 = select_default2(this), selection2 = local2(this).selection;
    if (selection2) {
      group2.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group2.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group2.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1)
        this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode2) {
      if (this.starting)
        this.starting = false, this.emit("start", event, mode2);
      else
        this.emit("brush", event);
      return this;
    },
    brush: function(event, mode2) {
      this.emit("brush", event, mode2);
      return this;
    },
    end: function(event, mode2) {
      if (--this.active === 0)
        delete this.state.emitter, this.emit("end", event, mode2);
      return this;
    },
    emit: function(type2, event, mode2) {
      var d = select_default2(this.that).datum();
      listeners.call(type2, this.that, new BrushEvent(type2, {
        sourceEvent: event,
        target: brush2,
        selection: dim.output(this.state.selection),
        mode: mode2,
        dispatch: listeners
      }), d);
    }
  };
  function started(event) {
    if (touchending && !event.touches)
      return;
    if (!filter3.apply(this, arguments))
      return;
    var that = this, type2 = event.target.__data__.type, mode2 = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local2(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E2 = extent3[1][0], e0, e1, S2 = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t4) => {
      const i2 = t4.identifier;
      t4 = pointer_default(t4, that);
      t4.point0 = t4.slice();
      t4.identifier = i2;
      return t4;
    });
    interrupt_default(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2)
        moving = true;
      const pts = [points[0], points[1] || points[0]];
      state.selection = selection2 = [[
        w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]),
        n0 = dim === X ? N : min2(pts[0][1], pts[1][1])
      ], [
        e0 = dim === Y ? E2 : max2(pts[0][0], pts[1][0]),
        s0 = dim === X ? S2 : max2(pts[0][1], pts[1][1])
      ]];
      if (points.length > 1)
        move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group2 = select_default2(that).attr("pointer-events", "none");
    var overlay = group2.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select_default2(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys)
        view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      nodrag_default(event.view);
    }
    redraw.call(that);
    emit.start(event, mode2.name);
    function moved(event2) {
      for (const p of event2.changedTouches || [event2]) {
        for (const d of points)
          if (d.identifier === p.identifier)
            d.cur = pointer_default(p, that);
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        const point6 = points[0];
        if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))
          lockY = true;
        else
          lockX = true;
      }
      for (const point6 of points)
        if (point6.cur)
          point6[0] = point6.cur[0], point6[1] = point6.cur[1];
      moving = true;
      noevent_default2(event2);
      move(event2);
    }
    function move(event2) {
      const point6 = points[0], point0 = point6.point0;
      var t4;
      dx = point6[0] - point0[0];
      dy = point6[1] - point0[1];
      switch (mode2) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX)
            dx = max2(W - w0, min2(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY)
            dy = max2(N - n0, min2(S2 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points[1]) {
            if (signX)
              w1 = max2(W, min2(E2, points[0][0])), e1 = max2(W, min2(E2, points[1][0])), signX = 1;
            if (signY)
              n1 = max2(N, min2(S2, points[0][1])), s1 = max2(N, min2(S2, points[1][1])), signY = 1;
          } else {
            if (signX < 0)
              dx = max2(W - w0, min2(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0)
              dx = max2(W - e0, min2(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0)
              dy = max2(N - n0, min2(S2 - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0)
              dy = max2(N - s0, min2(S2 - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX)
            w1 = max2(W, min2(E2, w0 - dx * signX)), e1 = max2(W, min2(E2, e0 + dx * signX));
          if (signY)
            n1 = max2(N, min2(S2, n0 - dy * signY)), s1 = max2(N, min2(S2, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t4 = w0, w0 = e0, e0 = t4;
        t4 = w1, w1 = e1, e1 = t4;
        if (type2 in flipX)
          overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t4 = n0, n0 = s0, s0 = t4;
        t4 = n1, n1 = s1, s1 = t4;
        if (type2 in flipY)
          overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection)
        selection2 = state.selection;
      if (lockX)
        w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY)
        n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode2.name);
      }
    }
    function ended(event2) {
      nopropagation2(event2);
      if (event2.touches) {
        if (event2.touches.length)
          return;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group2.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection)
        selection2 = state.selection;
      if (empty3(selection2))
        state.selection = null, redraw.call(that);
      emit.end(event2, mode2.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode2 === MODE_HANDLE) {
            if (signX)
              e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY)
              s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode2 = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {
            if (signX < 0)
              e0 = e1 - dx;
            else if (signX > 0)
              w0 = w1 - dx;
            if (signY < 0)
              s0 = s1 - dy;
            else if (signY > 0)
              n0 = n1 - dy;
            mode2 = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode2 === MODE_CENTER) {
            if (signX < 0)
              e0 = e1;
            else if (signX > 0)
              w0 = w1;
            if (signY < 0)
              s0 = s1;
            else if (signY > 0)
              n0 = n1;
            mode2 = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode2 === MODE_SPACE) {
            if (event2.altKey) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode2 = MODE_CENTER;
            } else {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode2 = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = number22(extent2.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_) {
    return arguments.length ? (extent2 = typeof _ === "function" ? _ : constant_default4(number22(_)), brush2) : extent2;
  };
  brush2.filter = function(_) {
    return arguments.length ? (filter3 = typeof _ === "function" ? _ : constant_default4(!!_), brush2) : filter3;
  };
  brush2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), brush2) : touchable;
  };
  brush2.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush2) : keys;
  };
  brush2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush2 : value;
  };
  return brush2;
}
var MODE_DRAG, MODE_SPACE, MODE_HANDLE, MODE_CENTER, abs, max2, min2, X, Y, XY, cursors, flipX, flipY, signsX, signsY;
var init_brush = __esm({
  "node_modules/d3-brush/src/brush.js"() {
    init_shims();
    init_src4();
    init_src6();
    init_src8();
    init_src5();
    init_src11();
    init_constant5();
    init_event2();
    init_noevent2();
    MODE_DRAG = { name: "drag" };
    MODE_SPACE = { name: "space" };
    MODE_HANDLE = { name: "handle" };
    MODE_CENTER = { name: "center" };
    ({ abs, max: max2, min: min2 } = Math);
    X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x5, e3) {
        return x5 == null ? null : [[+x5[0], e3[0][1]], [+x5[1], e3[1][1]]];
      },
      output: function(xy) {
        return xy && [xy[0][0], xy[1][0]];
      }
    };
    Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y4, e3) {
        return y4 == null ? null : [[e3[0][0], +y4[0]], [e3[1][0], +y4[1]]];
      },
      output: function(xy) {
        return xy && [xy[0][1], xy[1][1]];
      }
    };
    XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) {
        return xy == null ? null : number22(xy);
      },
      output: function(xy) {
        return xy;
      }
    };
    cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };
    flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };
    flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };
    signsX = {
      overlay: 1,
      selection: 1,
      n: null,
      e: 1,
      s: null,
      w: -1,
      nw: -1,
      ne: 1,
      se: 1,
      sw: -1
    };
    signsY = {
      overlay: 1,
      selection: 1,
      n: -1,
      e: null,
      s: 1,
      w: null,
      nw: -1,
      ne: -1,
      se: 1,
      sw: 1
    };
  }
});

// node_modules/d3-brush/src/index.js
var init_src12 = __esm({
  "node_modules/d3-brush/src/index.js"() {
    init_shims();
    init_brush();
  }
});

// node_modules/d3-chord/src/math.js
var abs2, cos, sin, pi2, halfPi2, tau2, max3, epsilon3;
var init_math3 = __esm({
  "node_modules/d3-chord/src/math.js"() {
    init_shims();
    abs2 = Math.abs;
    cos = Math.cos;
    sin = Math.sin;
    pi2 = Math.PI;
    halfPi2 = pi2 / 2;
    tau2 = pi2 * 2;
    max3 = Math.max;
    epsilon3 = 1e-12;
  }
});

// node_modules/d3-chord/src/chord.js
function range2(i2, j) {
  return Array.from({ length: j - i2 }, (_, k2) => i2 + k2);
}
function compareValue(compare) {
  return function(a3, b) {
    return compare(a3.source.value + a3.target.value, b.source.value + b.target.value);
  };
}
function chord_default() {
  return chord(false, false);
}
function chordTranspose() {
  return chord(false, true);
}
function chordDirected() {
  return chord(true, false);
}
function chord(directed, transpose2) {
  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
  function chord2(matrix) {
    var n = matrix.length, groupSums = new Array(n), groupIndex = range2(0, n), chords = new Array(n * n), groups2 = new Array(n), k2 = 0, dx;
    matrix = Float64Array.from({ length: n * n }, transpose2 ? (_, i2) => matrix[i2 % n][i2 / n | 0] : (_, i2) => matrix[i2 / n | 0][i2 % n]);
    for (let i2 = 0; i2 < n; ++i2) {
      let x5 = 0;
      for (let j = 0; j < n; ++j)
        x5 += matrix[i2 * n + j] + directed * matrix[j * n + i2];
      k2 += groupSums[i2] = x5;
    }
    k2 = max3(0, tau2 - padAngle * n) / k2;
    dx = k2 ? padAngle : tau2 / n;
    {
      let x5 = 0;
      if (sortGroups)
        groupIndex.sort((a3, b) => sortGroups(groupSums[a3], groupSums[b]));
      for (const i2 of groupIndex) {
        const x06 = x5;
        if (directed) {
          const subgroupIndex = range2(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i2] : matrix[i2 * n + j]);
          if (sortSubgroups)
            subgroupIndex.sort((a3, b) => sortSubgroups(a3 < 0 ? -matrix[~a3 * n + i2] : matrix[i2 * n + a3], b < 0 ? -matrix[~b * n + i2] : matrix[i2 * n + b]));
          for (const j of subgroupIndex) {
            if (j < 0) {
              const chord3 = chords[~j * n + i2] || (chords[~j * n + i2] = { source: null, target: null });
              chord3.target = { index: i2, startAngle: x5, endAngle: x5 += matrix[~j * n + i2] * k2, value: matrix[~j * n + i2] };
            } else {
              const chord3 = chords[i2 * n + j] || (chords[i2 * n + j] = { source: null, target: null });
              chord3.source = { index: i2, startAngle: x5, endAngle: x5 += matrix[i2 * n + j] * k2, value: matrix[i2 * n + j] };
            }
          }
          groups2[i2] = { index: i2, startAngle: x06, endAngle: x5, value: groupSums[i2] };
        } else {
          const subgroupIndex = range2(0, n).filter((j) => matrix[i2 * n + j] || matrix[j * n + i2]);
          if (sortSubgroups)
            subgroupIndex.sort((a3, b) => sortSubgroups(matrix[i2 * n + a3], matrix[i2 * n + b]));
          for (const j of subgroupIndex) {
            let chord3;
            if (i2 < j) {
              chord3 = chords[i2 * n + j] || (chords[i2 * n + j] = { source: null, target: null });
              chord3.source = { index: i2, startAngle: x5, endAngle: x5 += matrix[i2 * n + j] * k2, value: matrix[i2 * n + j] };
            } else {
              chord3 = chords[j * n + i2] || (chords[j * n + i2] = { source: null, target: null });
              chord3.target = { index: i2, startAngle: x5, endAngle: x5 += matrix[i2 * n + j] * k2, value: matrix[i2 * n + j] };
              if (i2 === j)
                chord3.source = chord3.target;
            }
            if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {
              const source = chord3.source;
              chord3.source = chord3.target;
              chord3.target = source;
            }
          }
          groups2[i2] = { index: i2, startAngle: x06, endAngle: x5, value: groupSums[i2] };
        }
        x5 += dx;
      }
    }
    chords = Object.values(chords);
    chords.groups = groups2;
    return sortChords ? chords.sort(sortChords) : chords;
  }
  chord2.padAngle = function(_) {
    return arguments.length ? (padAngle = max3(0, _), chord2) : padAngle;
  };
  chord2.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord2) : sortGroups;
  };
  chord2.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord2) : sortSubgroups;
  };
  chord2.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord2) : sortChords && sortChords._;
  };
  return chord2;
}
var init_chord = __esm({
  "node_modules/d3-chord/src/chord.js"() {
    init_shims();
    init_math3();
  }
});

// node_modules/d3-path/src/path.js
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
var pi3, tau3, epsilon4, tauEpsilon, path_default;
var init_path = __esm({
  "node_modules/d3-path/src/path.js"() {
    init_shims();
    pi3 = Math.PI;
    tau3 = 2 * pi3;
    epsilon4 = 1e-6;
    tauEpsilon = tau3 - epsilon4;
    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x5, y4) {
        this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y4);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x5, y4) {
        this._ += "L" + (this._x1 = +x5) + "," + (this._y1 = +y4);
      },
      quadraticCurveTo: function(x12, y12, x5, y4) {
        this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x5) + "," + (this._y1 = +y4);
      },
      bezierCurveTo: function(x12, y12, x22, y22, x5, y4) {
        this._ += "C" + +x12 + "," + +y12 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x5) + "," + (this._y1 = +y4);
      },
      arcTo: function(x12, y12, x22, y22, r2) {
        x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r2 = +r2;
        var x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
        } else if (!(l01_2 > epsilon4))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r2) {
          this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
        } else {
          var x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon4) {
            this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
          }
          this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
        }
      },
      arc: function(x5, y4, r2, a0, a1, ccw) {
        x5 = +x5, y4 = +y4, r2 = +r2, ccw = !!ccw;
        var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x06 = x5 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + x06 + "," + y06;
        } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {
          this._ += "L" + x06 + "," + y06;
        }
        if (!r2)
          return;
        if (da2 < 0)
          da2 = da2 % tau3 + tau3;
        if (da2 > tauEpsilon) {
          this._ += "A" + r2 + "," + r2 + ",0,1," + cw + "," + (x5 - dx) + "," + (y4 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw + "," + (this._x1 = x06) + "," + (this._y1 = y06);
        } else if (da2 > epsilon4) {
          this._ += "A" + r2 + "," + r2 + ",0," + +(da2 >= pi3) + "," + cw + "," + (this._x1 = x5 + r2 * Math.cos(a1)) + "," + (this._y1 = y4 + r2 * Math.sin(a1));
        }
      },
      rect: function(x5, y4, w, h2) {
        this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y4) + "h" + +w + "v" + +h2 + "h" + -w + "Z";
      },
      toString: function() {
        return this._;
      }
    };
    path_default = path;
  }
});

// node_modules/d3-path/src/index.js
var init_src13 = __esm({
  "node_modules/d3-path/src/index.js"() {
    init_shims();
    init_path();
  }
});

// node_modules/d3-chord/src/array.js
var slice2;
var init_array4 = __esm({
  "node_modules/d3-chord/src/array.js"() {
    init_shims();
    slice2 = Array.prototype.slice;
  }
});

// node_modules/d3-chord/src/constant.js
function constant_default5(x5) {
  return function() {
    return x5;
  };
}
var init_constant6 = __esm({
  "node_modules/d3-chord/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-chord/src/ribbon.js
function defaultSource(d) {
  return d.source;
}
function defaultTarget(d) {
  return d.target;
}
function defaultRadius(d) {
  return d.radius;
}
function defaultStartAngle(d) {
  return d.startAngle;
}
function defaultEndAngle(d) {
  return d.endAngle;
}
function defaultPadAngle() {
  return 0;
}
function defaultArrowheadRadius() {
  return 10;
}
function ribbon(headRadius) {
  var source = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;
  function ribbon2() {
    var buffer, s4 = source.apply(this, arguments), t4 = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice2.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s4, argv)), sa0 = startAngle.apply(this, argv) - halfPi2, sa1 = endAngle.apply(this, argv) - halfPi2, tr = +targetRadius.apply(this, (argv[0] = t4, argv)), ta0 = startAngle.apply(this, argv) - halfPi2, ta1 = endAngle.apply(this, argv) - halfPi2;
    if (!context)
      context = buffer = path_default();
    if (ap > epsilon3) {
      if (abs2(sa1 - sa0) > ap * 2 + epsilon3)
        sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
      else
        sa0 = sa1 = (sa0 + sa1) / 2;
      if (abs2(ta1 - ta0) > ap * 2 + epsilon3)
        ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
      else
        ta0 = ta1 = (ta0 + ta1) / 2;
    }
    context.moveTo(sr * cos(sa0), sr * sin(sa0));
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      if (headRadius) {
        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
        context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));
        context.lineTo(tr * cos(ta2), tr * sin(ta2));
        context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));
      } else {
        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
        context.arc(0, 0, tr, ta0, ta1);
      }
    }
    context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  if (headRadius)
    ribbon2.headRadius = function(_) {
      return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : headRadius;
    };
  ribbon2.radius = function(_) {
    return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : sourceRadius;
  };
  ribbon2.sourceRadius = function(_) {
    return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : sourceRadius;
  };
  ribbon2.targetRadius = function(_) {
    return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : targetRadius;
  };
  ribbon2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : startAngle;
  };
  ribbon2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : endAngle;
  };
  ribbon2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default5(+_), ribbon2) : padAngle;
  };
  ribbon2.source = function(_) {
    return arguments.length ? (source = _, ribbon2) : source;
  };
  ribbon2.target = function(_) {
    return arguments.length ? (target = _, ribbon2) : target;
  };
  ribbon2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, ribbon2) : context;
  };
  return ribbon2;
}
function ribbon_default() {
  return ribbon();
}
function ribbonArrow() {
  return ribbon(defaultArrowheadRadius);
}
var init_ribbon = __esm({
  "node_modules/d3-chord/src/ribbon.js"() {
    init_shims();
    init_src13();
    init_array4();
    init_constant6();
    init_math3();
  }
});

// node_modules/d3-chord/src/index.js
var init_src14 = __esm({
  "node_modules/d3-chord/src/index.js"() {
    init_shims();
    init_chord();
    init_ribbon();
  }
});

// node_modules/d3-contour/src/array.js
var array3, slice3;
var init_array5 = __esm({
  "node_modules/d3-contour/src/array.js"() {
    init_shims();
    array3 = Array.prototype;
    slice3 = array3.slice;
  }
});

// node_modules/d3-contour/src/ascending.js
function ascending_default(a3, b) {
  return a3 - b;
}
var init_ascending2 = __esm({
  "node_modules/d3-contour/src/ascending.js"() {
    init_shims();
  }
});

// node_modules/d3-contour/src/area.js
function area_default(ring) {
  var i2 = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i2 < n)
    area += ring[i2 - 1][1] * ring[i2][0] - ring[i2 - 1][0] * ring[i2][1];
  return area;
}
var init_area = __esm({
  "node_modules/d3-contour/src/area.js"() {
    init_shims();
  }
});

// node_modules/d3-contour/src/constant.js
var constant_default6;
var init_constant7 = __esm({
  "node_modules/d3-contour/src/constant.js"() {
    init_shims();
    constant_default6 = (x5) => () => x5;
  }
});

// node_modules/d3-contour/src/contains.js
function contains_default(ring, hole) {
  var i2 = -1, n = hole.length, c5;
  while (++i2 < n)
    if (c5 = ringContains(ring, hole[i2]))
      return c5;
  return 0;
}
function ringContains(ring, point6) {
  var x5 = point6[0], y4 = point6[1], contains = -1;
  for (var i2 = 0, n = ring.length, j = n - 1; i2 < n; j = i2++) {
    var pi6 = ring[i2], xi = pi6[0], yi = pi6[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi6, pj, point6))
      return 0;
    if (yi > y4 !== yj > y4 && x5 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)
      contains = -contains;
  }
  return contains;
}
function segmentContains(a3, b, c5) {
  var i2;
  return collinear(a3, b, c5) && within(a3[i2 = +(a3[0] === b[0])], c5[i2], b[i2]);
}
function collinear(a3, b, c5) {
  return (b[0] - a3[0]) * (c5[1] - a3[1]) === (c5[0] - a3[0]) * (b[1] - a3[1]);
}
function within(p, q, r2) {
  return p <= q && q <= r2 || r2 <= q && q <= p;
}
var init_contains = __esm({
  "node_modules/d3-contour/src/contains.js"() {
    init_shims();
  }
});

// node_modules/d3-contour/src/noop.js
function noop_default() {
}
var init_noop = __esm({
  "node_modules/d3-contour/src/noop.js"() {
    init_shims();
  }
});

// node_modules/d3-contour/src/contours.js
function contours_default() {
  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
  function contours(values) {
    var tz = threshold2(values);
    if (!Array.isArray(tz)) {
      const e3 = extent(values), ts = tickStep(e3[0], e3[1], tz);
      tz = ticks(Math.floor(e3[0] / ts) * ts, Math.floor(e3[1] / ts - 1) * ts, tz);
    } else {
      tz = tz.slice().sort(ascending_default);
    }
    return tz.map((value) => contour(values, value));
  }
  function contour(values, value) {
    var polygons = [], holes = [];
    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area_default(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i2 = 0, n = polygons.length, polygon; i2 < n; ++i2) {
        if (contains_default((polygon = polygons[i2])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x5, y4, t03, t13, t22, t32;
    x5 = y4 = -1;
    t13 = values[0] >= value;
    cases[t13 << 1].forEach(stitch);
    while (++x5 < dx - 1) {
      t03 = t13, t13 = values[x5 + 1] >= value;
      cases[t03 | t13 << 1].forEach(stitch);
    }
    cases[t13 << 0].forEach(stitch);
    while (++y4 < dy - 1) {
      x5 = -1;
      t13 = values[y4 * dx + dx] >= value;
      t22 = values[y4 * dx] >= value;
      cases[t13 << 1 | t22 << 2].forEach(stitch);
      while (++x5 < dx - 1) {
        t03 = t13, t13 = values[y4 * dx + dx + x5 + 1] >= value;
        t32 = t22, t22 = values[y4 * dx + x5 + 1] >= value;
        cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t13 | t22 << 3].forEach(stitch);
    }
    x5 = -1;
    t22 = values[y4 * dx] >= value;
    cases[t22 << 2].forEach(stitch);
    while (++x5 < dx - 1) {
      t32 = t22, t22 = values[y4 * dx + x5 + 1] >= value;
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line) {
      var start2 = [line[0][0] + x5, line[0][1] + y4], end = [line[1][0] + x5, line[1][1] + y4], startIndex = index3(start2), endIndex = index3(end), f3, g;
      if (f3 = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f3.end];
          delete fragmentByStart[g.start];
          if (f3 === g) {
            f3.ring.push(end);
            callback(f3.ring);
          } else {
            fragmentByStart[f3.start] = fragmentByEnd[g.end] = { start: f3.start, end: g.end, ring: f3.ring.concat(g.ring) };
          }
        } else {
          delete fragmentByEnd[f3.end];
          f3.ring.push(end);
          fragmentByEnd[f3.end = endIndex] = f3;
        }
      } else if (f3 = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f3.start];
          delete fragmentByEnd[g.end];
          if (f3 === g) {
            f3.ring.push(end);
            callback(f3.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f3.end] = { start: g.start, end: f3.end, ring: g.ring.concat(f3.ring) };
          }
        } else {
          delete fragmentByStart[f3.start];
          f3.ring.unshift(start2);
          fragmentByStart[f3.start = startIndex] = f3;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };
      }
    }
  }
  function index3(point6) {
    return point6[0] * 2 + point6[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values, value) {
    ring.forEach(function(point6) {
      var x5 = point6[0], y4 = point6[1], xt = x5 | 0, yt = y4 | 0, v0, v1 = values[yt * dx + xt];
      if (x5 > 0 && x5 < dx && xt === x5) {
        v0 = values[yt * dx + xt - 1];
        point6[0] = x5 + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y4 > 0 && y4 < dy && yt === y4) {
        v0 = values[(yt - 1) * dx + xt];
        point6[1] = y4 + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours.contour = contour;
  contours.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };
  contours.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), contours) : threshold2;
  };
  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
  };
  return contours;
}
var cases;
var init_contours = __esm({
  "node_modules/d3-contour/src/contours.js"() {
    init_shims();
    init_src2();
    init_array5();
    init_ascending2();
    init_area();
    init_constant7();
    init_contains();
    init_noop();
    cases = [
      [],
      [[[1, 1.5], [0.5, 1]]],
      [[[1.5, 1], [1, 1.5]]],
      [[[1.5, 1], [0.5, 1]]],
      [[[1, 0.5], [1.5, 1]]],
      [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
      [[[1, 0.5], [1, 1.5]]],
      [[[1, 0.5], [0.5, 1]]],
      [[[0.5, 1], [1, 0.5]]],
      [[[1, 1.5], [1, 0.5]]],
      [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
      [[[1.5, 1], [1, 0.5]]],
      [[[0.5, 1], [1.5, 1]]],
      [[[1, 1.5], [1.5, 1]]],
      [[[0.5, 1], [1, 1.5]]],
      []
    ];
  }
});

// node_modules/d3-contour/src/blur.js
function blurX(source, target, r2) {
  var n = source.width, m3 = source.height, w = (r2 << 1) + 1;
  for (var j = 0; j < m3; ++j) {
    for (var i2 = 0, sr = 0; i2 < n + r2; ++i2) {
      if (i2 < n) {
        sr += source.data[i2 + j * n];
      }
      if (i2 >= r2) {
        if (i2 >= w) {
          sr -= source.data[i2 - w + j * n];
        }
        target.data[i2 - r2 + j * n] = sr / Math.min(i2 + 1, n - 1 + w - i2, w);
      }
    }
  }
}
function blurY(source, target, r2) {
  var n = source.width, m3 = source.height, w = (r2 << 1) + 1;
  for (var i2 = 0; i2 < n; ++i2) {
    for (var j = 0, sr = 0; j < m3 + r2; ++j) {
      if (j < m3) {
        sr += source.data[i2 + j * n];
      }
      if (j >= r2) {
        if (j >= w) {
          sr -= source.data[i2 + (j - w) * n];
        }
        target.data[i2 + (j - r2) * n] = sr / Math.min(j + 1, m3 - 1 + w - j, w);
      }
    }
  }
}
var init_blur = __esm({
  "node_modules/d3-contour/src/blur.js"() {
    init_shims();
  }
});

// node_modules/d3-contour/src/density.js
function defaultX(d) {
  return d[0];
}
function defaultY(d) {
  return d[1];
}
function defaultWeight() {
  return 1;
}
function density_default() {
  var x5 = defaultX, y4 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r2 = 20, k2 = 2, o = r2 * 3, n = dx + o * 2 >> k2, m3 = dy + o * 2 >> k2, threshold2 = constant_default6(20);
  function density(data) {
    var values0 = new Float32Array(n * m3), values1 = new Float32Array(n * m3), pow2k = Math.pow(2, -k2);
    data.forEach(function(d, i2, data2) {
      var xi = (x5(d, i2, data2) + o) * pow2k, yi = (y4(d, i2, data2) + o) * pow2k, wi = +weight(d, i2, data2);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m3) {
        var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;
        values0[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;
        values0[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;
        values0[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;
        values0[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;
      }
    });
    blurX({ width: n, height: m3, data: values0 }, { width: n, height: m3, data: values1 }, r2 >> k2);
    blurY({ width: n, height: m3, data: values1 }, { width: n, height: m3, data: values0 }, r2 >> k2);
    blurX({ width: n, height: m3, data: values0 }, { width: n, height: m3, data: values1 }, r2 >> k2);
    blurY({ width: n, height: m3, data: values1 }, { width: n, height: m3, data: values0 }, r2 >> k2);
    blurX({ width: n, height: m3, data: values0 }, { width: n, height: m3, data: values1 }, r2 >> k2);
    blurY({ width: n, height: m3, data: values1 }, { width: n, height: m3, data: values0 }, r2 >> k2);
    var tz = threshold2(values0);
    if (!Array.isArray(tz)) {
      var stop = max(values0);
      tz = tickStep(0, stop, tz);
      tz = range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }
    return contours_default().thresholds(tz).size([n, m3])(values0).map(transform2);
  }
  function transform2(geometry) {
    geometry.value *= Math.pow(2, -2 * k2);
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }
  function transformPolygon(coordinates2) {
    coordinates2.forEach(transformRing);
  }
  function transformRing(coordinates2) {
    coordinates2.forEach(transformPoint);
  }
  function transformPoint(coordinates2) {
    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;
    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;
  }
  function resize() {
    o = r2 * 3;
    n = dx + o * 2 >> k2;
    m3 = dy + o * 2 >> k2;
    return density;
  }
  density.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default6(+_), density) : x5;
  };
  density.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default6(+_), density) : y4;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant_default6(+_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };
  density.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k2;
    if (!((_ = +_) >= 1))
      throw new Error("invalid cell size");
    return k2 = Math.floor(Math.log(_) / Math.LN2), resize();
  };
  density.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), density) : threshold2;
  };
  density.bandwidth = function(_) {
    if (!arguments.length)
      return Math.sqrt(r2 * (r2 + 1));
    if (!((_ = +_) >= 0))
      throw new Error("invalid bandwidth");
    return r2 = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };
  return density;
}
var init_density = __esm({
  "node_modules/d3-contour/src/density.js"() {
    init_shims();
    init_src2();
    init_array5();
    init_blur();
    init_constant7();
    init_contours();
  }
});

// node_modules/d3-contour/src/index.js
var init_src15 = __esm({
  "node_modules/d3-contour/src/index.js"() {
    init_shims();
    init_contours();
    init_density();
  }
});

// node_modules/robust-predicates/esm/util.js
function sum2(elen, e3, flen, f3, h2) {
  let Q, Qnew, hh, bvirt;
  let enow = e3[0];
  let fnow = f3[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e3[++eindex];
  } else {
    Q = fnow;
    fnow = f3[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e3[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f3[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f3[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e3[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f3[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h2[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e3) {
  let Q = e3[0];
  for (let i2 = 1; i2 < elen; i2++)
    Q += e3[i2];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}
var epsilon5, splitter, resulterrbound;
var init_util = __esm({
  "node_modules/robust-predicates/esm/util.js"() {
    init_shims();
    epsilon5 = 11102230246251565e-32;
    splitter = 134217729;
    resulterrbound = (3 + 8 * epsilon5) * epsilon5;
  }
});

// node_modules/robust-predicates/esm/orient2d.js
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c5, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c5 = splitter * acx;
  ahi = c5 - (c5 - acx);
  alo = acx - ahi;
  c5 = splitter * bcy;
  bhi = c5 - (c5 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c5 = splitter * acy;
  ahi = c5 - (c5 - acy);
  alo = acy - ahi;
  c5 = splitter * bcx;
  bhi = c5 - (c5 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B2[3] = u32;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound)
    return det;
  s1 = acxtail * bcy;
  c5 = splitter * acxtail;
  ahi = c5 - (c5 - acxtail);
  alo = acxtail - ahi;
  c5 = splitter * bcy;
  bhi = c5 - (c5 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c5 = splitter * acytail;
  ahi = c5 - (c5 - acytail);
  alo = acytail - ahi;
  c5 = splitter * bcx;
  bhi = c5 - (c5 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum2(4, B2, 4, u, C1);
  s1 = acx * bcytail;
  c5 = splitter * acx;
  ahi = c5 - (c5 - acx);
  alo = acx - ahi;
  c5 = splitter * bcytail;
  bhi = c5 - (c5 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c5 = splitter * acy;
  ahi = c5 - (c5 - acy);
  alo = acy - ahi;
  c5 = splitter * bcxtail;
  bhi = c5 - (c5 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum2(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c5 = splitter * acxtail;
  ahi = c5 - (c5 - acxtail);
  alo = acxtail - ahi;
  c5 = splitter * bcytail;
  bhi = c5 - (c5 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c5 = splitter * acytail;
  ahi = c5 - (c5 - acytail);
  alo = acytail - ahi;
  c5 = splitter * bcxtail;
  bhi = c5 - (c5 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum2(C2len, C2, 4, u, D2);
  return D2[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)
    return det;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum)
    return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
var ccwerrboundA, ccwerrboundB, ccwerrboundC, B2, C1, C2, D2, u;
var init_orient2d = __esm({
  "node_modules/robust-predicates/esm/orient2d.js"() {
    init_shims();
    init_util();
    ccwerrboundA = (3 + 16 * epsilon5) * epsilon5;
    ccwerrboundB = (2 + 12 * epsilon5) * epsilon5;
    ccwerrboundC = (9 + 64 * epsilon5) * epsilon5 * epsilon5;
    B2 = vec(4);
    C1 = vec(8);
    C2 = vec(12);
    D2 = vec(16);
    u = vec(4);
  }
});

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA, o3derrboundB, o3derrboundC, bc, ca, ab, at_b, at_c, bt_c, bt_a, ct_a, ct_b, bct, cat, abt, u2, _8, _8b, _16, _12, fin, fin2;
var init_orient3d = __esm({
  "node_modules/robust-predicates/esm/orient3d.js"() {
    init_shims();
    init_util();
    o3derrboundA = (7 + 56 * epsilon5) * epsilon5;
    o3derrboundB = (3 + 28 * epsilon5) * epsilon5;
    o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;
    bc = vec(4);
    ca = vec(4);
    ab = vec(4);
    at_b = vec(4);
    at_c = vec(4);
    bt_c = vec(4);
    bt_a = vec(4);
    ct_a = vec(4);
    ct_b = vec(4);
    bct = vec(8);
    cat = vec(8);
    abt = vec(8);
    u2 = vec(4);
    _8 = vec(8);
    _8b = vec(8);
    _16 = vec(8);
    _12 = vec(12);
    fin = vec(192);
    fin2 = vec(192);
  }
});

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA, iccerrboundB, iccerrboundC, bc2, ca2, ab2, aa, bb, cc, u3, v, axtbc, aytbc, bxtca, bytca, cxtab, cytab, abt2, bct2, cat2, abtt, bctt, catt, _82, _162, _16b, _16c, _32, _32b, _48, _64, fin3, fin22;
var init_incircle = __esm({
  "node_modules/robust-predicates/esm/incircle.js"() {
    init_shims();
    init_util();
    iccerrboundA = (10 + 96 * epsilon5) * epsilon5;
    iccerrboundB = (4 + 48 * epsilon5) * epsilon5;
    iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;
    bc2 = vec(4);
    ca2 = vec(4);
    ab2 = vec(4);
    aa = vec(4);
    bb = vec(4);
    cc = vec(4);
    u3 = vec(4);
    v = vec(4);
    axtbc = vec(8);
    aytbc = vec(8);
    bxtca = vec(8);
    bytca = vec(8);
    cxtab = vec(8);
    cytab = vec(8);
    abt2 = vec(8);
    bct2 = vec(8);
    cat2 = vec(8);
    abtt = vec(4);
    bctt = vec(4);
    catt = vec(4);
    _82 = vec(8);
    _162 = vec(16);
    _16b = vec(16);
    _16c = vec(16);
    _32 = vec(32);
    _32b = vec(32);
    _48 = vec(48);
    _64 = vec(64);
    fin3 = vec(1152);
    fin22 = vec(1152);
  }
});

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA, isperrboundB, isperrboundC, ab3, bc3, cd, de, ea, ac, bd, ce, da, eb, abc, bcd, cde, dea, eab, abd, bce, cda, deb, eac, adet, bdet, cdet, ddet, edet, abdet, cddet, cdedet, deter, _83, _8b2, _8c, _163, _24, _482, _48b, _96, _192, _384x, _384y, _384z, _768, xdet, ydet, zdet, fin4;
var init_insphere = __esm({
  "node_modules/robust-predicates/esm/insphere.js"() {
    init_shims();
    init_util();
    isperrboundA = (16 + 224 * epsilon5) * epsilon5;
    isperrboundB = (5 + 72 * epsilon5) * epsilon5;
    isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;
    ab3 = vec(4);
    bc3 = vec(4);
    cd = vec(4);
    de = vec(4);
    ea = vec(4);
    ac = vec(4);
    bd = vec(4);
    ce = vec(4);
    da = vec(4);
    eb = vec(4);
    abc = vec(24);
    bcd = vec(24);
    cde = vec(24);
    dea = vec(24);
    eab = vec(24);
    abd = vec(24);
    bce = vec(24);
    cda = vec(24);
    deb = vec(24);
    eac = vec(24);
    adet = vec(1152);
    bdet = vec(1152);
    cdet = vec(1152);
    ddet = vec(1152);
    edet = vec(1152);
    abdet = vec(2304);
    cddet = vec(2304);
    cdedet = vec(3456);
    deter = vec(5760);
    _83 = vec(8);
    _8b2 = vec(8);
    _8c = vec(8);
    _163 = vec(16);
    _24 = vec(24);
    _482 = vec(48);
    _48b = vec(48);
    _96 = vec(96);
    _192 = vec(192);
    _384x = vec(384);
    _384y = vec(384);
    _384z = vec(384);
    _768 = vec(768);
    xdet = vec(96);
    ydet = vec(96);
    zdet = vec(96);
    fin4 = vec(1152);
  }
});

// node_modules/robust-predicates/index.js
var init_robust_predicates = __esm({
  "node_modules/robust-predicates/index.js"() {
    init_shims();
    init_orient2d();
    init_orient3d();
    init_incircle();
    init_insphere();
  }
});

// node_modules/delaunator/index.js
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x5 = (ey * bl - dy * cl) * d;
  const y4 = (dx * cl - ex * bl) * d;
  return x5 * x5 + y4 * y4;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x5 = ax + (ey * bl - dy * cl) * d;
  const y4 = ay + (dx * cl - ex * bl) * d;
  return { x: x5, y: y4 };
}
function quicksort(ids, dists, left2, right2) {
  if (right2 - left2 <= 20) {
    for (let i2 = left2 + 1; i2 <= right2; i2++) {
      const temp = ids[i2];
      const tempDist = dists[temp];
      let j = i2 - 1;
      while (j >= left2 && dists[ids[j]] > tempDist)
        ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median2 = left2 + right2 >> 1;
    let i2 = left2 + 1;
    let j = right2;
    swap2(ids, median2, i2);
    if (dists[ids[left2]] > dists[ids[right2]])
      swap2(ids, left2, right2);
    if (dists[ids[i2]] > dists[ids[right2]])
      swap2(ids, i2, right2);
    if (dists[ids[left2]] > dists[ids[i2]])
      swap2(ids, left2, i2);
    const temp = ids[i2];
    const tempDist = dists[temp];
    while (true) {
      do
        i2++;
      while (dists[ids[i2]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i2)
        break;
      swap2(ids, i2, j);
    }
    ids[left2 + 1] = ids[j];
    ids[j] = temp;
    if (right2 - i2 + 1 >= j - left2) {
      quicksort(ids, dists, i2, right2);
      quicksort(ids, dists, left2, j - 1);
    } else {
      quicksort(ids, dists, left2, j - 1);
      quicksort(ids, dists, i2, right2);
    }
  }
}
function swap2(arr, i2, j) {
  const tmp = arr[i2];
  arr[i2] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}
var EPSILON, EDGE_STACK, Delaunator;
var init_delaunator = __esm({
  "node_modules/delaunator/index.js"() {
    init_shims();
    init_robust_predicates();
    EPSILON = Math.pow(2, -52);
    EDGE_STACK = new Uint32Array(512);
    Delaunator = class {
      static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);
        for (let i2 = 0; i2 < n; i2++) {
          const p = points[i2];
          coords[2 * i2] = getX(p);
          coords[2 * i2 + 1] = getY(p);
        }
        return new Delaunator(coords);
      }
      constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== "number")
          throw new Error("Expected coords to contain numbers.");
        this.coords = coords;
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n);
        this._hullNext = new Uint32Array(n);
        this._hullTri = new Uint32Array(n);
        this._hullHash = new Int32Array(this._hashSize).fill(-1);
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);
        this.update();
      }
      update() {
        const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
        const n = coords.length >> 1;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY2 = -Infinity;
        for (let i3 = 0; i3 < n; i3++) {
          const x5 = coords[2 * i3];
          const y4 = coords[2 * i3 + 1];
          if (x5 < minX)
            minX = x5;
          if (y4 < minY)
            minY = y4;
          if (x5 > maxX)
            maxX = x5;
          if (y4 > maxY2)
            maxY2 = y4;
          this._ids[i3] = i3;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY2) / 2;
        let minDist = Infinity;
        let i0, i1, i2;
        for (let i3 = 0; i3 < n; i3++) {
          const d = dist(cx, cy, coords[2 * i3], coords[2 * i3 + 1]);
          if (d < minDist) {
            i0 = i3;
            minDist = d;
          }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];
        minDist = Infinity;
        for (let i3 = 0; i3 < n; i3++) {
          if (i3 === i0)
            continue;
          const d = dist(i0x, i0y, coords[2 * i3], coords[2 * i3 + 1]);
          if (d < minDist && d > 0) {
            i1 = i3;
            minDist = d;
          }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];
        let minRadius = Infinity;
        for (let i3 = 0; i3 < n; i3++) {
          if (i3 === i0 || i3 === i1)
            continue;
          const r2 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i3], coords[2 * i3 + 1]);
          if (r2 < minRadius) {
            i2 = i3;
            minRadius = r2;
          }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];
        if (minRadius === Infinity) {
          for (let i3 = 0; i3 < n; i3++) {
            this._dists[i3] = coords[2 * i3] - coords[0] || coords[2 * i3 + 1] - coords[1];
          }
          quicksort(this._ids, this._dists, 0, n - 1);
          const hull = new Uint32Array(n);
          let j = 0;
          for (let i3 = 0, d0 = -Infinity; i3 < n; i3++) {
            const id2 = this._ids[i3];
            if (this._dists[id2] > d0) {
              hull[j++] = id2;
              d0 = this._dists[id2];
            }
          }
          this.hull = hull.subarray(0, j);
          this.triangles = new Uint32Array(0);
          this.halfedges = new Uint32Array(0);
          return;
        }
        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
          const i3 = i1;
          const x5 = i1x;
          const y4 = i1y;
          i1 = i2;
          i1x = i2x;
          i1y = i2y;
          i2 = i3;
          i2x = x5;
          i2y = y4;
        }
        const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center2.x;
        this._cy = center2.y;
        for (let i3 = 0; i3 < n; i3++) {
          this._dists[i3] = dist(coords[2 * i3], coords[2 * i3 + 1], center2.x, center2.y);
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        this._hullStart = i0;
        let hullSize = 3;
        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;
        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;
        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;
        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);
        for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {
          const i3 = this._ids[k2];
          const x5 = coords[2 * i3];
          const y4 = coords[2 * i3 + 1];
          if (k2 > 0 && Math.abs(x5 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON)
            continue;
          xp = x5;
          yp = y4;
          if (i3 === i0 || i3 === i1 || i3 === i2)
            continue;
          let start2 = 0;
          for (let j = 0, key = this._hashKey(x5, y4); j < this._hashSize; j++) {
            start2 = hullHash[(key + j) % this._hashSize];
            if (start2 !== -1 && start2 !== hullNext[start2])
              break;
          }
          start2 = hullPrev[start2];
          let e3 = start2, q;
          while (q = hullNext[e3], orient2d(x5, y4, coords[2 * e3], coords[2 * e3 + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
            e3 = q;
            if (e3 === start2) {
              e3 = -1;
              break;
            }
          }
          if (e3 === -1)
            continue;
          let t4 = this._addTriangle(e3, i3, hullNext[e3], -1, -1, hullTri[e3]);
          hullTri[i3] = this._legalize(t4 + 2);
          hullTri[e3] = t4;
          hullSize++;
          let n2 = hullNext[e3];
          while (q = hullNext[n2], orient2d(x5, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
            t4 = this._addTriangle(n2, i3, q, hullTri[i3], -1, hullTri[n2]);
            hullTri[i3] = this._legalize(t4 + 2);
            hullNext[n2] = n2;
            hullSize--;
            n2 = q;
          }
          if (e3 === start2) {
            while (q = hullPrev[e3], orient2d(x5, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e3], coords[2 * e3 + 1]) < 0) {
              t4 = this._addTriangle(q, i3, e3, -1, hullTri[e3], hullTri[q]);
              this._legalize(t4 + 2);
              hullTri[q] = t4;
              hullNext[e3] = e3;
              hullSize--;
              e3 = q;
            }
          }
          this._hullStart = hullPrev[i3] = e3;
          hullNext[e3] = hullPrev[n2] = i3;
          hullNext[i3] = n2;
          hullHash[this._hashKey(x5, y4)] = i3;
          hullHash[this._hashKey(coords[2 * e3], coords[2 * e3 + 1])] = e3;
        }
        this.hull = new Uint32Array(hullSize);
        for (let i3 = 0, e3 = this._hullStart; i3 < hullSize; i3++) {
          this.hull[i3] = e3;
          e3 = hullNext[e3];
        }
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
      }
      _hashKey(x5, y4) {
        return Math.floor(pseudoAngle(x5 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;
      }
      _legalize(a3) {
        const { _triangles: triangles, _halfedges: halfedges, coords } = this;
        let i2 = 0;
        let ar = 0;
        while (true) {
          const b = halfedges[a3];
          const a0 = a3 - a3 % 3;
          ar = a0 + (a3 + 2) % 3;
          if (b === -1) {
            if (i2 === 0)
              break;
            a3 = EDGE_STACK[--i2];
            continue;
          }
          const b02 = b - b % 3;
          const al = a0 + (a3 + 1) % 3;
          const bl = b02 + (b + 2) % 3;
          const p02 = triangles[ar];
          const pr = triangles[a3];
          const pl = triangles[al];
          const p1 = triangles[bl];
          const illegal = inCircle(coords[2 * p02], coords[2 * p02 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);
          if (illegal) {
            triangles[a3] = p1;
            triangles[b] = p02;
            const hbl = halfedges[bl];
            if (hbl === -1) {
              let e3 = this._hullStart;
              do {
                if (this._hullTri[e3] === bl) {
                  this._hullTri[e3] = a3;
                  break;
                }
                e3 = this._hullPrev[e3];
              } while (e3 !== this._hullStart);
            }
            this._link(a3, hbl);
            this._link(b, halfedges[ar]);
            this._link(ar, bl);
            const br = b02 + (b + 1) % 3;
            if (i2 < EDGE_STACK.length) {
              EDGE_STACK[i2++] = br;
            }
          } else {
            if (i2 === 0)
              break;
            a3 = EDGE_STACK[--i2];
          }
        }
        return ar;
      }
      _link(a3, b) {
        this._halfedges[a3] = b;
        if (b !== -1)
          this._halfedges[b] = a3;
      }
      _addTriangle(i0, i1, i2, a3, b, c5) {
        const t4 = this.trianglesLen;
        this._triangles[t4] = i0;
        this._triangles[t4 + 1] = i1;
        this._triangles[t4 + 2] = i2;
        this._link(t4, a3);
        this._link(t4 + 1, b);
        this._link(t4 + 2, c5);
        this.trianglesLen += 3;
        return t4;
      }
    };
  }
});

// node_modules/d3-delaunay/src/path.js
var epsilon6, Path2;
var init_path2 = __esm({
  "node_modules/d3-delaunay/src/path.js"() {
    init_shims();
    epsilon6 = 1e-6;
    Path2 = class {
      constructor() {
        this._x0 = this._y0 = this._x1 = this._y1 = null;
        this._ = "";
      }
      moveTo(x5, y4) {
        this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y4}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x5, y4) {
        this._ += `L${this._x1 = +x5},${this._y1 = +y4}`;
      }
      arc(x5, y4, r2) {
        x5 = +x5, y4 = +y4, r2 = +r2;
        const x06 = x5 + r2;
        const y06 = y4;
        if (r2 < 0)
          throw new Error("negative radius");
        if (this._x1 === null)
          this._ += `M${x06},${y06}`;
        else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)
          this._ += "L" + x06 + "," + y06;
        if (!r2)
          return;
        this._ += `A${r2},${r2},0,1,1,${x5 - r2},${y4}A${r2},${r2},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
      }
      rect(x5, y4, w, h2) {
        this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y4}h${+w}v${+h2}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    };
  }
});

// node_modules/d3-delaunay/src/polygon.js
var Polygon;
var init_polygon = __esm({
  "node_modules/d3-delaunay/src/polygon.js"() {
    init_shims();
    Polygon = class {
      constructor() {
        this._ = [];
      }
      moveTo(x5, y4) {
        this._.push([x5, y4]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x5, y4) {
        this._.push([x5, y4]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    };
  }
});

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi;
var init_voronoi = __esm({
  "node_modules/d3-delaunay/src/voronoi.js"() {
    init_shims();
    init_path2();
    init_polygon();
    Voronoi = class {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
          throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const { delaunay: { points, hull, triangles }, vectors } = this;
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i2 = 0, j = 0, n = triangles.length, x5, y4; i2 < n; i2 += 3, j += 2) {
          const t13 = triangles[i2] * 2;
          const t22 = triangles[i2 + 1] * 2;
          const t32 = triangles[i2 + 2] * 2;
          const x13 = points[t13];
          const y13 = points[t13 + 1];
          const x22 = points[t22];
          const y22 = points[t22 + 1];
          const x32 = points[t32];
          const y32 = points[t32 + 1];
          const dx = x22 - x13;
          const dy = y22 - y13;
          const ex = x32 - x13;
          const ey = y32 - y13;
          const ab4 = (dx * ey - dy * ex) * 2;
          if (Math.abs(ab4) < 1e-9) {
            let a3 = 1e9;
            const r2 = triangles[0] * 2;
            a3 *= Math.sign((points[r2] - x13) * ey - (points[r2 + 1] - y13) * ex);
            x5 = (x13 + x32) / 2 - a3 * ey;
            y4 = (y13 + y32) / 2 + a3 * ex;
          } else {
            const d = 1 / ab4;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x5 = x13 + (ey * bl - dy * cl) * d;
            y4 = y13 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x5;
          circumcenters[j + 1] = y4;
        }
        let h2 = hull[hull.length - 1];
        let p02, p1 = h2 * 4;
        let x06, x12 = points[2 * h2];
        let y06, y12 = points[2 * h2 + 1];
        vectors.fill(0);
        for (let i2 = 0; i2 < hull.length; ++i2) {
          h2 = hull[i2];
          p02 = p1, x06 = x12, y06 = y12;
          p1 = h2 * 4, x12 = points[2 * h2], y12 = points[2 * h2 + 1];
          vectors[p02 + 2] = vectors[p1] = y06 - y12;
          vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path2() : void 0;
        const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
        if (hull.length <= 1)
          return null;
        for (let i2 = 0, n = halfedges.length; i2 < n; ++i2) {
          const j = halfedges[i2];
          if (j < i2)
            continue;
          const ti = Math.floor(i2 / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i2 = 0; i2 < hull.length; ++i2) {
          h0 = h1, h1 = hull[i2];
          const t4 = Math.floor(inedges[h1] / 3) * 2;
          const x5 = circumcenters[t4];
          const y4 = circumcenters[t4 + 1];
          const v2 = h0 * 4;
          const p = this._project(x5, y4, vectors[v2 + 2], vectors[v2 + 3]);
          if (p)
            this._renderSegment(x5, y4, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path2() : void 0;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i2, context) {
        const buffer = context == null ? context = new Path2() : void 0;
        const points = this._clip(i2);
        if (points === null || !points.length)
          return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)
          n -= 2;
        for (let i3 = 2; i3 < n; i3 += 2) {
          if (points[i3] !== points[i3 - 2] || points[i3 + 1] !== points[i3 - 1])
            context.lineTo(points[i3], points[i3 + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const { delaunay: { points } } = this;
        for (let i2 = 0, n = points.length / 2; i2 < n; ++i2) {
          const cell = this.cellPolygon(i2);
          if (cell)
            cell.index = i2, yield cell;
        }
      }
      cellPolygon(i2) {
        const polygon = new Polygon();
        this.renderCell(i2, polygon);
        return polygon.value();
      }
      _renderSegment(x06, y06, x12, y12, context) {
        let S2;
        const c0 = this._regioncode(x06, y06);
        const c1 = this._regioncode(x12, y12);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x06, y06);
          context.lineTo(x12, y12);
        } else if (S2 = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
          context.moveTo(S2[0], S2[1]);
          context.lineTo(S2[2], S2[3]);
        }
      }
      contains(i2, x5, y4) {
        if ((x5 = +x5, x5 !== x5) || (y4 = +y4, y4 !== y4))
          return false;
        return this.delaunay._step(i2, x5, y4) === i2;
      }
      *neighbors(i2) {
        const ci = this._clip(i2);
        if (ci)
          for (const j of this.delaunay.neighbors(i2)) {
            const cj = this._clip(j);
            if (cj)
              loop:
                for (let ai = 0, li = ci.length; ai < li; ai += 2) {
                  for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                    if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
                      yield j;
                      break loop;
                    }
                  }
                }
          }
      }
      _cell(i2) {
        const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
        const e0 = inedges[i2];
        if (e0 === -1)
          return null;
        const points = [];
        let e3 = e0;
        do {
          const t4 = Math.floor(e3 / 3);
          points.push(circumcenters[t4 * 2], circumcenters[t4 * 2 + 1]);
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i2)
            break;
          e3 = halfedges[e3];
        } while (e3 !== e0 && e3 !== -1);
        return points;
      }
      _clip(i2) {
        if (i2 === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i2);
        if (points === null)
          return null;
        const { vectors: V } = this;
        const v2 = i2 * 4;
        return V[v2] || V[v2 + 1] ? this._clipInfinite(i2, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i2, points);
      }
      _clipFinite(i2, points) {
        const n = points.length;
        let P = null;
        let x06, y06, x12 = points[n - 2], y12 = points[n - 1];
        let c0, c1 = this._regioncode(x12, y12);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x12, y12);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P)
              P.push(x12, y12);
            else
              P = [x12, y12];
          } else {
            let S2, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S2 = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)
                continue;
              [sx0, sy0, sx1, sy1] = S2;
            } else {
              if ((S2 = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)
                continue;
              [sx1, sy1, sx0, sy0] = S2;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1)
                this._edge(i2, e0, e1, P, P.length);
              if (P)
                P.push(sx0, sy0);
              else
                P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1)
              this._edge(i2, e0, e1, P, P.length);
            if (P)
              P.push(sx1, sy1);
            else
              P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1)
            this._edge(i2, e0, e1, P, P.length);
        } else if (this.contains(i2, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x06, y06, x12, y12, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0)
            return [x06, y06, x12, y12];
          if (c0 & c1)
            return null;
          let x5, y4, c5 = c0 || c1;
          if (c5 & 8)
            x5 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;
          else if (c5 & 4)
            x5 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;
          else if (c5 & 2)
            y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x5 = this.xmax;
          else
            y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x5 = this.xmin;
          if (c0)
            x06 = x5, y06 = y4, c0 = this._regioncode(x06, y06);
          else
            x12 = x5, y12 = y4, c1 = this._regioncode(x12, y12);
        }
      }
      _clipInfinite(i2, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0))
          P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
          P.push(p[0], p[1]);
        if (P = this._clipFinite(i2, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1)
              j = this._edge(i2, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i2, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i2, e0, e1, P, j) {
        while (e0 !== e1) {
          let x5, y4;
          switch (e0) {
            case 5:
              e0 = 4;
              continue;
            case 4:
              e0 = 6, x5 = this.xmax, y4 = this.ymin;
              break;
            case 6:
              e0 = 2;
              continue;
            case 2:
              e0 = 10, x5 = this.xmax, y4 = this.ymax;
              break;
            case 10:
              e0 = 8;
              continue;
            case 8:
              e0 = 9, x5 = this.xmin, y4 = this.ymax;
              break;
            case 9:
              e0 = 1;
              continue;
            case 1:
              e0 = 5, x5 = this.xmin, y4 = this.ymin;
              break;
          }
          if ((P[j] !== x5 || P[j + 1] !== y4) && this.contains(i2, x5, y4)) {
            P.splice(j, 0, x5, y4), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i3 = 0; i3 < P.length; i3 += 2) {
            const j2 = (i3 + 2) % P.length, k2 = (i3 + 4) % P.length;
            if (P[i3] === P[j2] && P[j2] === P[k2] || P[i3 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])
              P.splice(j2, 2), i3 -= 2;
          }
        }
        return j;
      }
      _project(x06, y06, vx, vy) {
        let t4 = Infinity, c5, x5, y4;
        if (vy < 0) {
          if (y06 <= this.ymin)
            return null;
          if ((c5 = (this.ymin - y06) / vy) < t4)
            y4 = this.ymin, x5 = x06 + (t4 = c5) * vx;
        } else if (vy > 0) {
          if (y06 >= this.ymax)
            return null;
          if ((c5 = (this.ymax - y06) / vy) < t4)
            y4 = this.ymax, x5 = x06 + (t4 = c5) * vx;
        }
        if (vx > 0) {
          if (x06 >= this.xmax)
            return null;
          if ((c5 = (this.xmax - x06) / vx) < t4)
            x5 = this.xmax, y4 = y06 + (t4 = c5) * vy;
        } else if (vx < 0) {
          if (x06 <= this.xmin)
            return null;
          if ((c5 = (this.xmin - x06) / vx) < t4)
            x5 = this.xmin, y4 = y06 + (t4 = c5) * vy;
        }
        return [x5, y4];
      }
      _edgecode(x5, y4) {
        return (x5 === this.xmin ? 1 : x5 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);
      }
      _regioncode(x5, y4) {
        return (x5 < this.xmin ? 1 : x5 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);
      }
    };
  }
});

// node_modules/d3-delaunay/src/delaunay.js
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear2(d) {
  const { triangles, coords } = d;
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    const a3 = 2 * triangles[i2], b = 2 * triangles[i2 + 1], c5 = 2 * triangles[i2 + 2], cross2 = (coords[c5] - coords[a3]) * (coords[b + 1] - coords[a3 + 1]) - (coords[b] - coords[a3]) * (coords[c5 + 1] - coords[a3 + 1]);
    if (cross2 > 1e-10)
      return false;
  }
  return true;
}
function jitter(x5, y4, r2) {
  return [x5 + Math.sin(x5 + y4) * r2, y4 + Math.cos(x5 - y4) * r2];
}
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array4 = new Float64Array(n * 2);
  for (let i2 = 0; i2 < n; ++i2) {
    const p = points[i2];
    array4[i2 * 2] = fx.call(that, p, i2, points);
    array4[i2 * 2 + 1] = fy.call(that, p, i2, points);
  }
  return array4;
}
function* flatIterable(points, fx, fy, that) {
  let i2 = 0;
  for (const p of points) {
    yield fx.call(that, p, i2, points);
    yield fy.call(that, p, i2, points);
    ++i2;
  }
}
var tau4, pow, Delaunay;
var init_delaunay = __esm({
  "node_modules/d3-delaunay/src/delaunay.js"() {
    init_shims();
    init_delaunator();
    init_path2();
    init_polygon();
    init_voronoi();
    tau4 = 2 * Math.PI;
    pow = Math.pow;
    Delaunay = class {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;
        if (d.hull && d.hull.length > 2 && collinear2(d)) {
          this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i2) => i2).sort((i2, j) => points[2 * i2] - points[2 * j] || points[2 * i2 + 1] - points[2 * j + 1]);
          const e3 = this.collinear[0], f3 = this.collinear[this.collinear.length - 1], bounds = [points[2 * e3], points[2 * e3 + 1], points[2 * f3], points[2 * f3 + 1]], r2 = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i2 = 0, n = points.length / 2; i2 < n; ++i2) {
            const p = jitter(points[2 * i2], points[2 * i2 + 1], r2);
            points[2 * i2] = p[0];
            points[2 * i2 + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }
        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);
        for (let e3 = 0, n = halfedges.length; e3 < n; ++e3) {
          const p = triangles[e3 % 3 === 2 ? e3 - 2 : e3 + 1];
          if (halfedges[e3] === -1 || inedges[p] === -1)
            inedges[p] = e3;
        }
        for (let i2 = 0, n = hull.length; i2 < n; ++i2) {
          hullIndex[hull[i2]] = i2;
        }
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i2) {
        const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
        if (collinear3) {
          const l = collinear3.indexOf(i2);
          if (l > 0)
            yield collinear3[l - 1];
          if (l < collinear3.length - 1)
            yield collinear3[l + 1];
          return;
        }
        const e0 = inedges[i2];
        if (e0 === -1)
          return;
        let e3 = e0, p02 = -1;
        do {
          yield p02 = triangles[e3];
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i2)
            return;
          e3 = halfedges[e3];
          if (e3 === -1) {
            const p = hull[(_hullIndex[i2] + 1) % hull.length];
            if (p !== p02)
              yield p;
            return;
          }
        } while (e3 !== e0);
      }
      find(x5, y4, i2 = 0) {
        if ((x5 = +x5, x5 !== x5) || (y4 = +y4, y4 !== y4))
          return -1;
        const i0 = i2;
        let c5;
        while ((c5 = this._step(i2, x5, y4)) >= 0 && c5 !== i2 && c5 !== i0)
          i2 = c5;
        return c5;
      }
      _step(i2, x5, y4) {
        const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
        if (inedges[i2] === -1 || !points.length)
          return (i2 + 1) % (points.length >> 1);
        let c5 = i2;
        let dc = pow(x5 - points[i2 * 2], 2) + pow(y4 - points[i2 * 2 + 1], 2);
        const e0 = inedges[i2];
        let e3 = e0;
        do {
          let t4 = triangles[e3];
          const dt = pow(x5 - points[t4 * 2], 2) + pow(y4 - points[t4 * 2 + 1], 2);
          if (dt < dc)
            dc = dt, c5 = t4;
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i2)
            break;
          e3 = halfedges[e3];
          if (e3 === -1) {
            e3 = hull[(_hullIndex[i2] + 1) % hull.length];
            if (e3 !== t4) {
              if (pow(x5 - points[e3 * 2], 2) + pow(y4 - points[e3 * 2 + 1], 2) < dc)
                return e3;
            }
            break;
          }
        } while (e3 !== e0);
        return c5;
      }
      render(context) {
        const buffer = context == null ? context = new Path2() : void 0;
        const { points, halfedges, triangles } = this;
        for (let i2 = 0, n = halfedges.length; i2 < n; ++i2) {
          const j = halfedges[i2];
          if (j < i2)
            continue;
          const ti = triangles[i2] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r2) {
        if (r2 === void 0 && (!context || typeof context.moveTo !== "function"))
          r2 = context, context = null;
        r2 = r2 == void 0 ? 2 : +r2;
        const buffer = context == null ? context = new Path2() : void 0;
        const { points } = this;
        for (let i2 = 0, n = points.length; i2 < n; i2 += 2) {
          const x5 = points[i2], y4 = points[i2 + 1];
          context.moveTo(x5 + r2, y4);
          context.arc(x5, y4, r2, 0, tau4);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path2() : void 0;
        const { hull, points } = this;
        const h2 = hull[0] * 2, n = hull.length;
        context.moveTo(points[h2], points[h2 + 1]);
        for (let i2 = 1; i2 < n; ++i2) {
          const h3 = 2 * hull[i2];
          context.lineTo(points[h3], points[h3 + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon();
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i2, context) {
        const buffer = context == null ? context = new Path2() : void 0;
        const { points, triangles } = this;
        const t03 = triangles[i2 *= 3] * 2;
        const t13 = triangles[i2 + 1] * 2;
        const t22 = triangles[i2 + 2] * 2;
        context.moveTo(points[t03], points[t03 + 1]);
        context.lineTo(points[t13], points[t13 + 1]);
        context.lineTo(points[t22], points[t22 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const { triangles } = this;
        for (let i2 = 0, n = triangles.length / 3; i2 < n; ++i2) {
          yield this.trianglePolygon(i2);
        }
      }
      trianglePolygon(i2) {
        const polygon = new Polygon();
        this.renderTriangle(i2, polygon);
        return polygon.value();
      }
    };
  }
});

// node_modules/d3-delaunay/src/index.js
var init_src16 = __esm({
  "node_modules/d3-delaunay/src/index.js"() {
    init_shims();
    init_delaunay();
    init_voronoi();
  }
});

// node_modules/d3-dsv/src/dsv.js
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i2) {
    return JSON.stringify(name) + ": d[" + i2 + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f3) {
  var object2 = objectConverter(columns);
  return function(row, i2) {
    return f3(object2(row), i2, columns);
  };
}
function inferColumns(rows) {
  var columnSet = Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value, width) {
  var s4 = value + "", length3 = s4.length;
  return length3 < width ? new Array(width - length3 + 1).join(0) + s4 : s4;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad(-year2, 6) : year2 > 9999 ? "+" + pad(year2, 6) : pad(year2, 4);
}
function formatDate(date2) {
  var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad(date2.getUTCMonth() + 1, 2) + "-" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours2, 2) + ":" + pad(minutes2, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours2, 2) + ":" + pad(minutes2, 2) + ":" + pad(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad(hours2, 2) + ":" + pad(minutes2, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f3) {
    var convert, columns, rows = parseRows(text, function(row, i2) {
      if (convert)
        return convert(row, i2 - 1);
      columns = row, convert = f3 ? customConverter(row, f3) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f3) {
    var rows = [], N = text.length, I = 0, n = 0, t4, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i2, j = I, c5;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
          ;
        if ((i2 = I) >= N)
          eof = true;
        else if ((c5 = text.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text.slice(j + 1, i2 - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c5 = text.charCodeAt(i2 = I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c5 !== DELIMITER)
          continue;
        return text.slice(j, i2);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t4 = token()) !== EOF) {
      var row = [];
      while (t4 !== EOL && t4 !== EOF)
        row.push(t4), t4 = token();
      if (f3 && (row = f3(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}
var EOL, EOF, QUOTE, NEWLINE, RETURN;
var init_dsv = __esm({
  "node_modules/d3-dsv/src/dsv.js"() {
    init_shims();
    EOL = {};
    EOF = {};
    QUOTE = 34;
    NEWLINE = 10;
    RETURN = 13;
  }
});

// node_modules/d3-dsv/src/csv.js
var csv, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue;
var init_csv = __esm({
  "node_modules/d3-dsv/src/csv.js"() {
    init_shims();
    init_dsv();
    csv = dsv_default(",");
    csvParse = csv.parse;
    csvParseRows = csv.parseRows;
    csvFormat = csv.format;
    csvFormatBody = csv.formatBody;
    csvFormatRows = csv.formatRows;
    csvFormatRow = csv.formatRow;
    csvFormatValue = csv.formatValue;
  }
});

// node_modules/d3-dsv/src/tsv.js
var tsv, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue;
var init_tsv = __esm({
  "node_modules/d3-dsv/src/tsv.js"() {
    init_shims();
    init_dsv();
    tsv = dsv_default("	");
    tsvParse = tsv.parse;
    tsvParseRows = tsv.parseRows;
    tsvFormat = tsv.format;
    tsvFormatBody = tsv.formatBody;
    tsvFormatRows = tsv.formatRows;
    tsvFormatRow = tsv.formatRow;
    tsvFormatValue = tsv.formatValue;
  }
});

// node_modules/d3-dsv/src/autoType.js
function autoType(object2) {
  for (var key in object2) {
    var value = object2[key].trim(), number5, m3;
    if (!value)
      value = null;
    else if (value === "true")
      value = true;
    else if (value === "false")
      value = false;
    else if (value === "NaN")
      value = NaN;
    else if (!isNaN(number5 = +value))
      value = number5;
    else if (m3 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m3[4] && !m3[7])
        value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    } else
      continue;
    object2[key] = value;
  }
  return object2;
}
var fixtz;
var init_autoType = __esm({
  "node_modules/d3-dsv/src/autoType.js"() {
    init_shims();
    fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
  }
});

// node_modules/d3-dsv/src/index.js
var init_src17 = __esm({
  "node_modules/d3-dsv/src/index.js"() {
    init_shims();
    init_dsv();
    init_csv();
    init_tsv();
    init_autoType();
  }
});

// node_modules/d3-fetch/src/blob.js
function responseBlob(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.blob();
}
function blob_default(input, init3) {
  return fetch(input, init3).then(responseBlob);
}
var init_blob = __esm({
  "node_modules/d3-fetch/src/blob.js"() {
    init_shims();
  }
});

// node_modules/d3-fetch/src/buffer.js
function responseArrayBuffer(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}
function buffer_default(input, init3) {
  return fetch(input, init3).then(responseArrayBuffer);
}
var init_buffer = __esm({
  "node_modules/d3-fetch/src/buffer.js"() {
    init_shims();
  }
});

// node_modules/d3-fetch/src/text.js
function responseText(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text_default3(input, init3) {
  return fetch(input, init3).then(responseText);
}
var init_text3 = __esm({
  "node_modules/d3-fetch/src/text.js"() {
    init_shims();
  }
});

// node_modules/d3-fetch/src/dsv.js
function dsvParse(parse) {
  return function(input, init3, row) {
    if (arguments.length === 2 && typeof init3 === "function")
      row = init3, init3 = void 0;
    return text_default3(input, init3).then(function(response) {
      return parse(response, row);
    });
  };
}
function dsv(delimiter, input, init3, row) {
  if (arguments.length === 3 && typeof init3 === "function")
    row = init3, init3 = void 0;
  var format3 = dsv_default(delimiter);
  return text_default3(input, init3).then(function(response) {
    return format3.parse(response, row);
  });
}
var csv2, tsv2;
var init_dsv2 = __esm({
  "node_modules/d3-fetch/src/dsv.js"() {
    init_shims();
    init_src17();
    init_text3();
    csv2 = dsvParse(csvParse);
    tsv2 = dsvParse(tsvParse);
  }
});

// node_modules/d3-fetch/src/image.js
function image_default(input, init3) {
  return new Promise(function(resolve2, reject) {
    var image = new Image();
    for (var key in init3)
      image[key] = init3[key];
    image.onerror = reject;
    image.onload = function() {
      resolve2(image);
    };
    image.src = input;
  });
}
var init_image = __esm({
  "node_modules/d3-fetch/src/image.js"() {
    init_shims();
  }
});

// node_modules/d3-fetch/src/json.js
function responseJson(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205)
    return;
  return response.json();
}
function json_default(input, init3) {
  return fetch(input, init3).then(responseJson);
}
var init_json = __esm({
  "node_modules/d3-fetch/src/json.js"() {
    init_shims();
  }
});

// node_modules/d3-fetch/src/xml.js
function parser(type2) {
  return (input, init3) => text_default3(input, init3).then((text) => new DOMParser().parseFromString(text, type2));
}
var xml_default, html, svg;
var init_xml = __esm({
  "node_modules/d3-fetch/src/xml.js"() {
    init_shims();
    init_text3();
    xml_default = parser("application/xml");
    html = parser("text/html");
    svg = parser("image/svg+xml");
  }
});

// node_modules/d3-fetch/src/index.js
var init_src18 = __esm({
  "node_modules/d3-fetch/src/index.js"() {
    init_shims();
    init_blob();
    init_buffer();
    init_dsv2();
    init_image();
    init_json();
    init_text3();
    init_xml();
  }
});

// node_modules/d3-force/src/center.js
function center_default(x5, y4) {
  var nodes, strength = 1;
  if (x5 == null)
    x5 = 0;
  if (y4 == null)
    y4 = 0;
  function force() {
    var i2, n = nodes.length, node, sx = 0, sy = 0;
    for (i2 = 0; i2 < n; ++i2) {
      node = nodes[i2], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x5) * strength, sy = (sy / n - y4) * strength, i2 = 0; i2 < n; ++i2) {
      node = nodes[i2], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = +_, force) : x5;
  };
  force.y = function(_) {
    return arguments.length ? (y4 = +_, force) : y4;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}
var init_center = __esm({
  "node_modules/d3-force/src/center.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x5 = +this._x.call(null, d), y4 = +this._y.call(null, d);
  return add(this.cover(x5, y4), x5, y4, d);
}
function add(tree, x5, y4, d) {
  if (isNaN(x5) || isNaN(y4))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom2, i2, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right2 = x5 >= (xm = (x06 + x12) / 2))
      x06 = xm;
    else
      x12 = xm;
    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))
      y06 = ym;
    else
      y12 = ym;
    if (parent = node, !(node = node[i2 = bottom2 << 1 | right2]))
      return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x5 === xp && y4 === yp)
    return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right2 = x5 >= (xm = (x06 + x12) / 2))
      x06 = xm;
    else
      x12 = xm;
    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))
      y06 = ym;
    else
      y12 = ym;
  } while ((i2 = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i2] = leaf, tree;
}
function addAll(data) {
  var d, i2, n = data.length, x5, y4, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i2 = 0; i2 < n; ++i2) {
    if (isNaN(x5 = +this._x.call(null, d = data[i2])) || isNaN(y4 = +this._y.call(null, d)))
      continue;
    xz[i2] = x5;
    yz[i2] = y4;
    if (x5 < x06)
      x06 = x5;
    if (x5 > x12)
      x12 = x5;
    if (y4 < y06)
      y06 = y4;
    if (y4 > y12)
      y12 = y4;
  }
  if (x06 > x12 || y06 > y12)
    return this;
  this.cover(x06, y06).cover(x12, y12);
  for (i2 = 0; i2 < n; ++i2) {
    add(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}
var init_add = __esm({
  "node_modules/d3-quadtree/src/add.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/cover.js
function cover_default(x5, y4) {
  if (isNaN(x5 = +x5) || isNaN(y4 = +y4))
    return this;
  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x06)) {
    x12 = (x06 = Math.floor(x5)) + 1;
    y12 = (y06 = Math.floor(y4)) + 1;
  } else {
    var z = x12 - x06 || 1, node = this._root, parent, i2;
    while (x06 > x5 || x5 >= x12 || y06 > y4 || y4 >= y12) {
      i2 = (y4 < y06) << 1 | x5 < x06;
      parent = new Array(4), parent[i2] = node, node = parent, z *= 2;
      switch (i2) {
        case 0:
          x12 = x06 + z, y12 = y06 + z;
          break;
        case 1:
          x06 = x12 - z, y12 = y06 + z;
          break;
        case 2:
          x12 = x06 + z, y06 = y12 - z;
          break;
        case 3:
          x06 = x12 - z, y06 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}
var init_cover = __esm({
  "node_modules/d3-quadtree/src/cover.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}
var init_data2 = __esm({
  "node_modules/d3-quadtree/src/data.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
var init_extent2 = __esm({
  "node_modules/d3-quadtree/src/extent.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x06, y06, x12, y12) {
  this.node = node;
  this.x0 = x06;
  this.y0 = y06;
  this.x1 = x12;
  this.y1 = y12;
}
var init_quad2 = __esm({
  "node_modules/d3-quadtree/src/quad.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/find.js
function find_default(x5, y4, radius) {
  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i2;
  if (node)
    quads.push(new quad_default(node, x06, y06, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x06 = x5 - radius, y06 = y4 - radius;
    x32 = x5 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(new quad_default(node[3], xm, ym, x22, y22), new quad_default(node[2], x12, ym, xm, y22), new quad_default(node[1], xm, y12, x22, ym), new quad_default(node[0], x12, y12, xm, ym));
      if (i2 = (y4 >= ym) << 1 | x5 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q;
      }
    } else {
      var dx = x5 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x06 = x5 - d, y06 = y4 - d;
        x32 = x5 + d, y32 = y4 + d;
        data = node.data;
      }
    }
  }
  return data;
}
var init_find = __esm({
  "node_modules/d3-quadtree/src/find.js"() {
    init_shims();
    init_quad2();
  }
});

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d) {
  if (isNaN(x5 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x5, y4, xm, ym, right2, bottom2, i2, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right2 = x5 >= (xm = (x06 + x12) / 2))
        x06 = xm;
      else
        x12 = xm;
      if (bottom2 = y4 >= (ym = (y06 + y12) / 2))
        y06 = ym;
      else
        y12 = ym;
      if (!(parent = node, node = node[i2 = bottom2 << 1 | right2]))
        return this;
      if (!node.length)
        break;
      if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3])
        retainer = parent, j = i2;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n = data.length; i2 < n; ++i2)
    this.remove(data[i2]);
  return this;
}
var init_remove3 = __esm({
  "node_modules/d3-quadtree/src/remove.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}
var init_root = __esm({
  "node_modules/d3-quadtree/src/root.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}
var init_size2 = __esm({
  "node_modules/d3-quadtree/src/size.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x06, y06, x12, y12;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2])
        quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x06, y06, xm, ym));
    }
  }
  return this;
}
var init_visit = __esm({
  "node_modules/d3-quadtree/src/visit.js"() {
    init_shims();
    init_quad2();
  }
});

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x06, y06, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}
var init_visitAfter = __esm({
  "node_modules/d3-quadtree/src/visitAfter.js"() {
    init_shims();
    init_quad2();
  }
});

// node_modules/d3-quadtree/src/x.js
function defaultX2(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}
var init_x = __esm({
  "node_modules/d3-quadtree/src/x.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/y.js
function defaultY2(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}
var init_y = __esm({
  "node_modules/d3-quadtree/src/y.js"() {
    init_shims();
  }
});

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x5, y4) {
  var tree = new Quadtree(x5 == null ? defaultX2 : x5, y4 == null ? defaultY2 : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x5, y4, x06, y06, x12, y12) {
  this._x = x5;
  this._y = y4;
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto;
var init_quadtree = __esm({
  "node_modules/d3-quadtree/src/quadtree.js"() {
    init_shims();
    init_add();
    init_cover();
    init_data2();
    init_extent2();
    init_find();
    init_remove3();
    init_root();
    init_size2();
    init_visit();
    init_visitAfter();
    init_x();
    init_y();
    treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function() {
      var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
      if (!node)
        return copy3;
      if (!node.length)
        return copy3._root = leaf_copy(node), copy3;
      nodes = [{ source: node, target: copy3._root = new Array(4) }];
      while (node = nodes.pop()) {
        for (var i2 = 0; i2 < 4; ++i2) {
          if (child = node.source[i2]) {
            if (child.length)
              nodes.push({ source: child, target: node.target[i2] = new Array(4) });
            else
              node.target[i2] = leaf_copy(child);
          }
        }
      }
      return copy3;
    };
    treeProto.add = add_default;
    treeProto.addAll = addAll;
    treeProto.cover = cover_default;
    treeProto.data = data_default2;
    treeProto.extent = extent_default;
    treeProto.find = find_default;
    treeProto.remove = remove_default3;
    treeProto.removeAll = removeAll;
    treeProto.root = root_default;
    treeProto.size = size_default2;
    treeProto.visit = visit_default;
    treeProto.visitAfter = visitAfter_default;
    treeProto.x = x_default;
    treeProto.y = y_default;
  }
});

// node_modules/d3-quadtree/src/index.js
var init_src19 = __esm({
  "node_modules/d3-quadtree/src/index.js"() {
    init_shims();
    init_quadtree();
  }
});

// node_modules/d3-force/src/constant.js
function constant_default7(x5) {
  return function() {
    return x5;
  };
}
var init_constant8 = __esm({
  "node_modules/d3-force/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}
var init_jiggle = __esm({
  "node_modules/d3-force/src/jiggle.js"() {
    init_shims();
  }
});

// node_modules/d3-force/src/collide.js
function x2(d) {
  return d.x + d.vx;
}
function y(d) {
  return d.y + d.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations2 = 1;
  if (typeof radius !== "function")
    radius = constant_default7(radius == null ? 1 : +radius);
  function force() {
    var i2, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      tree = quadtree(nodes, x2, y).visitAfter(prepare);
      for (i2 = 0; i2 < n; ++i2) {
        node = nodes[i2];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x06, y06, x12, y12) {
      var data = quad.data, rj = quad.r, r2 = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x5 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l = x5 * x5 + y4 * y4;
          if (l < r2 * r2) {
            if (x5 === 0)
              x5 = jiggle_default(random), l += x5 * x5;
            if (y4 === 0)
              y4 = jiggle_default(random), l += y4 * y4;
            l = (r2 - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x5 *= l) * (r2 = (rj *= rj) / (ri2 + rj));
            node.vy += (y4 *= l) * r2;
            data.vx -= x5 * (r2 = 1 - r2);
            data.vy -= y4 * r2;
          }
        }
        return;
      }
      return x06 > xi + r2 || x12 < xi - r2 || y06 > yi + r2 || y12 < yi - r2;
    }
  }
  function prepare(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i2 = quad.r = 0; i2 < 4; ++i2) {
      if (quad[i2] && quad[i2].r > quad.r) {
        quad.r = quad[i2].r;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n = nodes.length, node;
    radii = new Array(n);
    for (i2 = 0; i2 < n; ++i2)
      node = nodes[i2], radii[node.index] = +radius(node, i2, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : radius;
  };
  return force;
}
var init_collide = __esm({
  "node_modules/d3-force/src/collide.js"() {
    init_shims();
    init_src19();
    init_constant8();
    init_jiggle();
  }
});

// node_modules/d3-force/src/link.js
function index2(d) {
  return d.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id2 = index2, strength = defaultStrength, strengths, distance = constant_default7(30), distances, nodes, count3, bias, random, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count3[link3.source.index], count3[link3.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {
      for (var i2 = 0, link3, source, target, x5, y4, l, b; i2 < n; ++i2) {
        link3 = links[i2], source = link3.source, target = link3.target;
        x5 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l = Math.sqrt(x5 * x5 + y4 * y4);
        l = (l - distances[i2]) / l * alpha * strengths[i2];
        x5 *= l, y4 *= l;
        target.vx -= x5 * (b = bias[i2]);
        target.vy -= y4 * b;
        source.vx += x5 * (b = 1 - b);
        source.vy += y4 * b;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i3) => [id2(d, i3, nodes), d])), link3;
    for (i2 = 0, count3 = new Array(n); i2 < m3; ++i2) {
      link3 = links[i2], link3.index = i2;
      if (typeof link3.source !== "object")
        link3.source = find2(nodeById, link3.source);
      if (typeof link3.target !== "object")
        link3.target = find2(nodeById, link3.target);
      count3[link3.source.index] = (count3[link3.source.index] || 0) + 1;
      count3[link3.target.index] = (count3[link3.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link3 = links[i2], bias[i2] = count3[link3.source.index] / (count3[link3.source.index] + count3[link3.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i2 = 0, n = links.length; i2 < n; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i2 = 0, n = links.length; i2 < n; ++i2) {
      distances[i2] = +distance(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id2 = _, force) : id2;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default7(+_), initializeDistance(), force) : distance;
  };
  return force;
}
var init_link = __esm({
  "node_modules/d3-force/src/link.js"() {
    init_shims();
    init_constant8();
    init_jiggle();
  }
});

// node_modules/d3-force/src/lcg.js
function lcg_default() {
  let s4 = 1;
  return () => (s4 = (a * s4 + c) % m2) / m2;
}
var a, c, m2;
var init_lcg = __esm({
  "node_modules/d3-force/src/lcg.js"() {
    init_shims();
    a = 1664525;
    c = 1013904223;
    m2 = 4294967296;
  }
});

// node_modules/d3-force/src/simulation.js
function x3(d) {
  return d.x;
}
function y2(d) {
  return d.y;
}
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations2) {
    var i2, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n; ++i2) {
        node = nodes[i2];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n = nodes.length, node; i2 < n; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle2 = i2 * initialAngle;
        node.x = radius * Math.cos(angle2);
        node.y = radius * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function(x5, y4, radius) {
      var i2 = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i2 = 0; i2 < n; ++i2) {
        node = nodes[i2];
        dx = x5 - node.x;
        dy = y4 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}
var initialRadius, initialAngle;
var init_simulation = __esm({
  "node_modules/d3-force/src/simulation.js"() {
    init_shims();
    init_src4();
    init_src9();
    init_lcg();
    initialRadius = 10;
    initialAngle = Math.PI * (3 - Math.sqrt(5));
  }
});

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default7(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i2, n = nodes.length, tree = quadtree(nodes, x3, y2).visitAfter(accumulate);
    for (alpha = _, i2 = 0; i2 < n; ++i2)
      node = nodes[i2], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n = nodes.length, node2;
    strengths = new Array(n);
    for (i2 = 0; i2 < n; ++i2)
      node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c5, weight = 0, x5, y4, i2;
    if (quad.length) {
      for (x5 = y4 = i2 = 0; i2 < 4; ++i2) {
        if ((q = quad[i2]) && (c5 = Math.abs(q.value))) {
          strength2 += q.value, weight += c5, x5 += c5 * q.x, y4 += c5 * q.y;
        }
      }
      quad.x = x5 / weight;
      quad.y = y4 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x12, _, x22) {
    if (!quad.value)
      return true;
    var x5 = quad.x - node.x, y4 = quad.y - node.y, w = x22 - x12, l = x5 * x5 + y4 * y4;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x5 === 0)
          x5 = jiggle_default(random), l += x5 * x5;
        if (y4 === 0)
          y4 = jiggle_default(random), l += y4 * y4;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x5 * quad.value * alpha / l;
        node.vy += y4 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x5 === 0)
        x5 = jiggle_default(random), l += x5 * x5;
      if (y4 === 0)
        y4 = jiggle_default(random), l += y4 * y4;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x5 * w;
        node.vy += y4 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}
var init_manyBody = __esm({
  "node_modules/d3-force/src/manyBody.js"() {
    init_shims();
    init_src19();
    init_constant8();
    init_jiggle();
    init_simulation();
  }
});

// node_modules/d3-force/src/radial.js
function radial_default(radius, x5, y4) {
  var nodes, strength = constant_default7(0.1), strengths, radiuses;
  if (typeof radius !== "function")
    radius = constant_default7(+radius);
  if (x5 == null)
    x5 = 0;
  if (y4 == null)
    y4 = 0;
  function force(alpha) {
    for (var i2 = 0, n = nodes.length; i2 < n; ++i2) {
      var node = nodes[i2], dx = node.x - x5 || 1e-6, dy = node.y - y4 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node.vx += dx * k2;
      node.vy += dy * k2;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i2 = 0; i2 < n; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _, initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : radius;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = +_, force) : x5;
  };
  force.y = function(_) {
    return arguments.length ? (y4 = +_, force) : y4;
  };
  return force;
}
var init_radial = __esm({
  "node_modules/d3-force/src/radial.js"() {
    init_shims();
    init_constant8();
  }
});

// node_modules/d3-force/src/x.js
function x_default2(x5) {
  var strength = constant_default7(0.1), nodes, strengths, xz;
  if (typeof x5 !== "function")
    x5 = constant_default7(x5 == null ? 0 : +x5);
  function force(alpha) {
    for (var i2 = 0, n = nodes.length, node; i2 < n; ++i2) {
      node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i2 = 0; i2 < n; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x5(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : x5;
  };
  return force;
}
var init_x2 = __esm({
  "node_modules/d3-force/src/x.js"() {
    init_shims();
    init_constant8();
  }
});

// node_modules/d3-force/src/y.js
function y_default2(y4) {
  var strength = constant_default7(0.1), nodes, strengths, yz;
  if (typeof y4 !== "function")
    y4 = constant_default7(y4 == null ? 0 : +y4);
  function force(alpha) {
    for (var i2 = 0, n = nodes.length, node; i2 < n; ++i2) {
      node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i2 = 0; i2 < n; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : strength;
  };
  force.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default7(+_), initialize(), force) : y4;
  };
  return force;
}
var init_y2 = __esm({
  "node_modules/d3-force/src/y.js"() {
    init_shims();
    init_constant8();
  }
});

// node_modules/d3-force/src/index.js
var init_src20 = __esm({
  "node_modules/d3-force/src/index.js"() {
    init_shims();
    init_center();
    init_collide();
    init_link();
    init_manyBody();
    init_radial();
    init_simulation();
    init_x2();
    init_y2();
  }
});

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x5) {
  return Math.abs(x5 = Math.round(x5)) >= 1e21 ? x5.toLocaleString("en").replace(/,/g, "") : x5.toString(10);
}
function formatDecimalParts(x5, p) {
  if ((i2 = (x5 = p ? x5.toExponential(p - 1) : x5.toExponential()).indexOf("e")) < 0)
    return null;
  var i2, coefficient = x5.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x5.slice(i2 + 1)
  ];
}
var init_formatDecimal = __esm({
  "node_modules/d3-format/src/formatDecimal.js"() {
    init_shims();
  }
});

// node_modules/d3-format/src/exponent.js
function exponent_default(x5) {
  return x5 = formatDecimalParts(Math.abs(x5)), x5 ? x5[1] : NaN;
}
var init_exponent = __esm({
  "node_modules/d3-format/src/exponent.js"() {
    init_shims();
    init_formatDecimal();
  }
});

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i2 = value.length, t4 = [], j = 0, g = grouping[0], length3 = 0;
    while (i2 > 0 && g > 0) {
      if (length3 + g + 1 > width)
        g = Math.max(1, width - length3);
      t4.push(value.substring(i2 -= g, i2 + g));
      if ((length3 += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}
var init_formatGroup = __esm({
  "node_modules/d3-format/src/formatGroup.js"() {
    init_shims();
  }
});

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}
var init_formatNumerals = __esm({
  "node_modules/d3-format/src/formatNumerals.js"() {
    init_shims();
  }
});

// node_modules/d3-format/src/formatSpecifier.js
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
var re;
var init_formatSpecifier = __esm({
  "node_modules/d3-format/src/formatSpecifier.js"() {
    init_shims();
    re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier.prototype = FormatSpecifier.prototype;
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
  }
});

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s4) {
  out:
    for (var n = s4.length, i2 = 1, i0 = -1, i1; i2 < n; ++i2) {
      switch (s4[i2]) {
        case ".":
          i0 = i1 = i2;
          break;
        case "0":
          if (i0 === 0)
            i0 = i2;
          i1 = i2;
          break;
        default:
          if (!+s4[i2])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s4.slice(0, i0) + s4.slice(i1 + 1) : s4;
}
var init_formatTrim = __esm({
  "node_modules/d3-format/src/formatTrim.js"() {
    init_shims();
  }
});

// node_modules/d3-format/src/formatPrefixAuto.js
function formatPrefixAuto_default(x5, p) {
  var d = formatDecimalParts(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent2 = d[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i2 === n ? coefficient : i2 > n ? coefficient + new Array(i2 - n + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x5, Math.max(0, p + i2 - 1))[0];
}
var prefixExponent;
var init_formatPrefixAuto = __esm({
  "node_modules/d3-format/src/formatPrefixAuto.js"() {
    init_shims();
    init_formatDecimal();
  }
});

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x5, p) {
  var d = formatDecimalParts(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
var init_formatRounded = __esm({
  "node_modules/d3-format/src/formatRounded.js"() {
    init_shims();
    init_formatDecimal();
  }
});

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default;
var init_formatTypes = __esm({
  "node_modules/d3-format/src/formatTypes.js"() {
    init_shims();
    init_formatDecimal();
    init_formatPrefixAuto();
    init_formatRounded();
    formatTypes_default = {
      "%": (x5, p) => (x5 * 100).toFixed(p),
      "b": (x5) => Math.round(x5).toString(2),
      "c": (x5) => x5 + "",
      "d": formatDecimal_default,
      "e": (x5, p) => x5.toExponential(p),
      "f": (x5, p) => x5.toFixed(p),
      "g": (x5, p) => x5.toPrecision(p),
      "o": (x5) => Math.round(x5).toString(8),
      "p": (x5, p) => formatRounded_default(x5 * 100, p),
      "r": formatRounded_default,
      "s": formatPrefixAuto_default,
      "X": (x5) => Math.round(x5).toString(16).toUpperCase(),
      "x": (x5) => Math.round(x5).toString(16)
    };
  }
});

// node_modules/d3-format/src/identity.js
function identity_default2(x5) {
  return x5;
}
var init_identity3 = __esm({
  "node_modules/d3-format/src/identity.js"() {
    init_shims();
  }
});

// node_modules/d3-format/src/locale.js
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n, c5;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n = value.length;
          while (++i2 < n) {
            if (c5 = value.charCodeAt(i2), 48 > c5 || c5 > 57) {
              valueSuffix = (c5 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
              value = value.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group2(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma && zero2)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var f3 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f3(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var map3, prefixes;
var init_locale = __esm({
  "node_modules/d3-format/src/locale.js"() {
    init_shims();
    init_exponent();
    init_formatGroup();
    init_formatNumerals();
    init_formatSpecifier();
    init_formatTrim();
    init_formatTypes();
    init_formatPrefixAuto();
    init_identity3();
    map3 = Array.prototype.map;
    prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  }
});

// node_modules/d3-format/src/defaultLocale.js
function defaultLocale(definition) {
  locale = locale_default(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
var locale, format2, formatPrefix;
var init_defaultLocale = __esm({
  "node_modules/d3-format/src/defaultLocale.js"() {
    init_shims();
    init_locale();
    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
  }
});

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}
var init_precisionFixed = __esm({
  "node_modules/d3-format/src/precisionFixed.js"() {
    init_shims();
    init_exponent();
  }
});

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}
var init_precisionPrefix = __esm({
  "node_modules/d3-format/src/precisionPrefix.js"() {
    init_shims();
    init_exponent();
  }
});

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max5) {
  step = Math.abs(step), max5 = Math.abs(max5) - step;
  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
}
var init_precisionRound = __esm({
  "node_modules/d3-format/src/precisionRound.js"() {
    init_shims();
    init_exponent();
  }
});

// node_modules/d3-format/src/index.js
var init_src21 = __esm({
  "node_modules/d3-format/src/index.js"() {
    init_shims();
    init_defaultLocale();
    init_locale();
    init_formatSpecifier();
    init_precisionFixed();
    init_precisionPrefix();
    init_precisionRound();
  }
});

// node_modules/d3-geo/src/math.js
function acos(x5) {
  return x5 > 1 ? 0 : x5 < -1 ? pi4 : Math.acos(x5);
}
function asin(x5) {
  return x5 > 1 ? halfPi3 : x5 < -1 ? -halfPi3 : Math.asin(x5);
}
function haversin(x5) {
  return (x5 = sin2(x5 / 2)) * x5;
}
var epsilon7, epsilon22, pi4, halfPi3, quarterPi, tau5, degrees3, radians2, abs3, atan, atan2, cos2, ceil, exp, hypot, log, pow2, sin2, sign, sqrt, tan;
var init_math4 = __esm({
  "node_modules/d3-geo/src/math.js"() {
    init_shims();
    epsilon7 = 1e-6;
    epsilon22 = 1e-12;
    pi4 = Math.PI;
    halfPi3 = pi4 / 2;
    quarterPi = pi4 / 4;
    tau5 = pi4 * 2;
    degrees3 = 180 / pi4;
    radians2 = pi4 / 180;
    abs3 = Math.abs;
    atan = Math.atan;
    atan2 = Math.atan2;
    cos2 = Math.cos;
    ceil = Math.ceil;
    exp = Math.exp;
    hypot = Math.hypot;
    log = Math.log;
    pow2 = Math.pow;
    sin2 = Math.sin;
    sign = Math.sign || function(x5) {
      return x5 > 0 ? 1 : x5 < 0 ? -1 : 0;
    };
    sqrt = Math.sqrt;
    tan = Math.tan;
  }
});

// node_modules/d3-geo/src/noop.js
function noop4() {
}
var init_noop2 = __esm({
  "node_modules/d3-geo/src/noop.js"() {
    init_shims();
  }
});

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
function streamLine(coordinates2, stream, closed) {
  var i2 = -1, n = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n)
    coordinate = coordinates2[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i2 = -1, n = coordinates2.length;
  stream.polygonStart();
  while (++i2 < n)
    streamLine(coordinates2[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}
var streamObjectType, streamGeometryType;
var init_stream = __esm({
  "node_modules/d3-geo/src/stream.js"() {
    init_shims();
    streamObjectType = {
      Feature: function(object2, stream) {
        streamGeometry(object2.geometry, stream);
      },
      FeatureCollection: function(object2, stream) {
        var features = object2.features, i2 = -1, n = features.length;
        while (++i2 < n)
          streamGeometry(features[i2].geometry, stream);
      }
    };
    streamGeometryType = {
      Sphere: function(object2, stream) {
        stream.sphere();
      },
      Point: function(object2, stream) {
        object2 = object2.coordinates;
        stream.point(object2[0], object2[1], object2[2]);
      },
      MultiPoint: function(object2, stream) {
        var coordinates2 = object2.coordinates, i2 = -1, n = coordinates2.length;
        while (++i2 < n)
          object2 = coordinates2[i2], stream.point(object2[0], object2[1], object2[2]);
      },
      LineString: function(object2, stream) {
        streamLine(object2.coordinates, stream, 0);
      },
      MultiLineString: function(object2, stream) {
        var coordinates2 = object2.coordinates, i2 = -1, n = coordinates2.length;
        while (++i2 < n)
          streamLine(coordinates2[i2], stream, 0);
      },
      Polygon: function(object2, stream) {
        streamPolygon(object2.coordinates, stream);
      },
      MultiPolygon: function(object2, stream) {
        var coordinates2 = object2.coordinates, i2 = -1, n = coordinates2.length;
        while (++i2 < n)
          streamPolygon(coordinates2[i2], stream);
      },
      GeometryCollection: function(object2, stream) {
        var geometries = object2.geometries, i2 = -1, n = geometries.length;
        while (++i2 < n)
          streamGeometry(geometries[i2], stream);
      }
    };
  }
});

// node_modules/d3-geo/src/area.js
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians2, phi2 *= radians2;
  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k2 = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k2 * cos2(adLambda), v2 = k2 * sdLambda * sin2(adLambda);
  areaRingSum.add(atan2(v2, u4));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default2(object2) {
  areaSum = new Adder();
  stream_default(object2, areaStream);
  return areaSum * 2;
}
var areaRingSum, areaSum, lambda00, phi00, lambda0, cosPhi0, sinPhi0, areaStream;
var init_area2 = __esm({
  "node_modules/d3-geo/src/area.js"() {
    init_shims();
    init_src2();
    init_math4();
    init_noop2();
    init_stream();
    areaRingSum = new Adder();
    areaSum = new Adder();
    areaStream = {
      point: noop4,
      lineStart: noop4,
      lineEnd: noop4,
      polygonStart: function() {
        areaRingSum = new Adder();
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum;
        areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop4;
      },
      sphere: function() {
        areaSum.add(tau5);
      }
    };
  }
});

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a3, b) {
  return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
}
function cartesianCross(a3, b) {
  return [a3[1] * b[2] - a3[2] * b[1], a3[2] * b[0] - a3[0] * b[2], a3[0] * b[1] - a3[1] * b[0]];
}
function cartesianAddInPlace(a3, b) {
  a3[0] += b[0], a3[1] += b[1], a3[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
var init_cartesian = __esm({
  "node_modules/d3-geo/src/cartesian.js"() {
    init_shims();
    init_math4();
  }
});

// node_modules/d3-geo/src/bounds.js
function boundsPoint(lambda, phi2) {
  ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians2, phi2 * radians2]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs3(delta) > 180;
    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = inflection[1] * degrees3;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = -inflection[1] * degrees3;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1))
          lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02)
          lambda02 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range3[0] = lambda02, range3[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs3(deltaSum) > epsilon7)
    lambda02 = -(lambda1 = 180);
  range3[0] = lambda02, range3[1] = lambda1;
  p0 = null;
}
function angle(lambda04, lambda12) {
  return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a3, b) {
  return a3[0] - b[0];
}
function rangeContains(range4, x5) {
  return range4[0] <= range4[1] ? range4[0] <= x5 && x5 <= range4[1] : x5 < range4[0] || range4[1] < x5;
}
function bounds_default(feature) {
  var i2, n, a3, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i2 = 1, a3 = ranges[0], merged = [a3]; i2 < n; ++i2) {
      b = ranges[i2];
      if (rangeContains(a3, b[0]) || rangeContains(a3, b[1])) {
        if (angle(a3[0], b[1]) > angle(a3[0], a3[1]))
          a3[1] = b[1];
        if (angle(b[0], a3[1]) > angle(a3[0], a3[1]))
          a3[0] = b[0];
      } else {
        merged.push(a3 = b);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i2 = 0, a3 = merged[n]; i2 <= n; a3 = b, ++i2) {
      b = merged[i2];
      if ((delta = angle(a3[1], b[0])) > deltaMax)
        deltaMax = delta, lambda02 = b[0], lambda1 = a3[1];
    }
  }
  ranges = range3 = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}
var lambda02, phi0, lambda1, phi1, lambda2, lambda002, phi002, p0, deltaSum, ranges, range3, boundsStream;
var init_bounds = __esm({
  "node_modules/d3-geo/src/bounds.js"() {
    init_shims();
    init_src2();
    init_area2();
    init_cartesian();
    init_math4();
    init_stream();
    boundsStream = {
      point: boundsPoint,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream.point = boundsRingPoint;
        boundsStream.lineStart = boundsRingStart;
        boundsStream.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream.polygonStart();
      },
      polygonEnd: function() {
        areaStream.polygonEnd();
        boundsStream.point = boundsPoint;
        boundsStream.lineStart = boundsLineStart;
        boundsStream.lineEnd = boundsLineEnd;
        if (areaRingSum < 0)
          lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon7)
          phi1 = 90;
        else if (deltaSum < -epsilon7)
          phi0 = -90;
        range3[0] = lambda02, range3[1] = lambda1;
      },
      sphere: function() {
        lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };
  }
});

// node_modules/d3-geo/src/centroid.js
function centroidPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x5, y4, z) {
  ++W0;
  X0 += (x5 - X0) / W0;
  Y0 += (y4 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), w = atan2(sqrt((w = y0 * z - z0 * y4) * w + (w = z0 * x5 - x0 * z) * w + (w = x0 * y4 - y0 * x5) * w), x0 * x5 + y0 * y4 + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x5));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y4, cy = z0 * x5 - x0 * z, cz = x0 * y4 - y0 * x5, m3 = hypot(cx, cy, cz), w = asin(m3), v2 = m3 && -w / m3;
  X2.add(v2 * cx);
  Y2.add(v2 * cy);
  Z2.add(v2 * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x5));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object2, centroidStream);
  var x5 = +X2, y4 = +Y2, z = +Z2, m3 = hypot(x5, y4, z);
  if (m3 < epsilon22) {
    x5 = X1, y4 = Y1, z = Z1;
    if (W1 < epsilon7)
      x5 = X0, y4 = Y0, z = Z0;
    m3 = hypot(x5, y4, z);
    if (m3 < epsilon22)
      return [NaN, NaN];
  }
  return [atan2(y4, x5) * degrees3, asin(z / m3) * degrees3];
}
var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda003, phi003, x0, y0, z0, centroidStream;
var init_centroid = __esm({
  "node_modules/d3-geo/src/centroid.js"() {
    init_shims();
    init_src2();
    init_math4();
    init_noop2();
    init_stream();
    centroidStream = {
      sphere: noop4,
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      }
    };
  }
});

// node_modules/d3-geo/src/constant.js
function constant_default8(x5) {
  return function() {
    return x5;
  };
}
var init_constant9 = __esm({
  "node_modules/d3-geo/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-geo/src/compose.js
function compose_default(a3, b) {
  function compose(x5, y4) {
    return x5 = a3(x5, y4), b(x5[0], x5[1]);
  }
  if (a3.invert && b.invert)
    compose.invert = function(x5, y4) {
      return x5 = b.invert(x5, y4), x5 && a3.invert(x5[0], x5[1]);
    };
  return compose;
}
var init_compose = __esm({
  "node_modules/d3-geo/src/compose.js"() {
    init_shims();
  }
});

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [abs3(lambda) > pi4 ? lambda + Math.round(-lambda / tau5) * tau5 : lambda, phi2];
}
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi4 ? lambda - tau5 : lambda < -pi4 ? lambda + tau5 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x5 * sinDeltaPhi;
    return [
      atan2(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x5 * cosDeltaPhi - z * sinDeltaPhi),
      asin(k2 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan2(y4 * cosDeltaGamma + z * sinDeltaGamma, x5 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin(k2 * cosDeltaPhi - x5 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  };
  return forward;
}
var init_rotation = __esm({
  "node_modules/d3-geo/src/rotation.js"() {
    init_shims();
    init_compose();
    init_math4();
    rotationIdentity.invert = rotationIdentity;
  }
});

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t03, t13) {
  if (!delta)
    return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t03 == null) {
    t03 = radius + direction * tau5;
    t13 = radius - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13)
      t03 += direction * tau5;
  }
  for (var point6, t4 = t03; direction > 0 ? t4 > t13 : t4 < t13; t4 -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos2(t4), -sinRadius * sin2(t4)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius = acos(-point6[1]);
  return ((-point6[2] < 0 ? -radius : radius) + tau5 - epsilon7) % tau5;
}
function circle_default() {
  var center2 = constant_default8([0, 0]), radius = constant_default8(90), precision = constant_default8(6), ring, rotate, stream = { point: point6 };
  function point6(x5, y4) {
    ring.push(x5 = rotate(x5, y4));
    x5[0] *= degrees3, x5[1] *= degrees3;
  }
  function circle2() {
    var c5 = center2.apply(this, arguments), r2 = radius.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;
    ring = [];
    rotate = rotateRadians(-c5[0] * radians2, -c5[1] * radians2, 0).invert;
    circleStream(stream, r2, p, 1);
    c5 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c5;
  }
  circle2.center = function(_) {
    return arguments.length ? (center2 = typeof _ === "function" ? _ : constant_default8([+_[0], +_[1]]), circle2) : center2;
  };
  circle2.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default8(+_), circle2) : radius;
  };
  circle2.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant_default8(+_), circle2) : precision;
  };
  return circle2;
}
var init_circle2 = __esm({
  "node_modules/d3-geo/src/circle.js"() {
    init_shims();
    init_cartesian();
    init_constant9();
    init_math4();
    init_rotation();
  }
});

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default2() {
  var lines = [], line;
  return {
    point: function(x5, y4, m3) {
      line.push([x5, y4, m3]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop4,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}
var init_buffer2 = __esm({
  "node_modules/d3-geo/src/clip/buffer.js"() {
    init_shims();
    init_noop2();
  }
});

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a3, b) {
  return abs3(a3[0] - b[0]) < epsilon7 && abs3(a3[1] - b[1]) < epsilon7;
}
var init_pointEqual = __esm({
  "node_modules/d3-geo/src/pointEqual.js"() {
    init_shims();
    init_math4();
  }
});

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i2, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x5;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n2; ++i2)
          stream.point((p02 = segment[i2])[0], p02[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon7;
    }
    subject.push(x5 = new Intersection(p02, segment, null, true));
    clip.push(x5.o = new Intersection(p02, null, x5, false));
    subject.push(x5 = new Intersection(p1, segment, null, false));
    clip.push(x5.o = new Intersection(p1, null, x5, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i2 = 0, n = clip.length; i2 < n; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point6;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n = points.length; i2 < n; ++i2)
            stream.point((point6 = points[i2])[0], point6[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i2 = points.length - 1; i2 >= 0; --i2)
            stream.point((point6 = points[i2])[0], point6[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array4) {
  if (!(n = array4.length))
    return;
  var n, i2 = 0, a3 = array4[0], b;
  while (++i2 < n) {
    a3.n = b = array4[i2];
    b.p = a3;
    a3 = b;
  }
  a3.n = b = array4[0];
  b.p = a3;
}
var init_rejoin = __esm({
  "node_modules/d3-geo/src/clip/rejoin.js"() {
    init_shims();
    init_pointEqual();
    init_math4();
  }
});

// node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs3(point6[0]) <= pi4 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi4) % tau5 - pi4);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi3 + epsilon7;
  else if (sinPhi === -1)
    phi2 = -halfPi3 - epsilon7;
  for (var i2 = 0, n = polygon.length; i2 < n; ++i2) {
    if (!(m3 = (ring = polygon[i2]).length))
      continue;
    var ring, m3, point0 = ring[m3 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin2(phi02), cosPhi03 = cos2(phi02);
    for (var j = 0; j < m3; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda04, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi4, k2 = sinPhi03 * sinPhi1;
      sum4.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k2 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau5 : delta;
      if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon7 || angle2 < epsilon7 && sum4 < -epsilon22) ^ winding & 1;
}
var init_polygonContains = __esm({
  "node_modules/d3-geo/src/polygonContains.js"() {
    init_shims();
    init_src2();
    init_cartesian();
    init_math4();
  }
});

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start2) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n = ringSegments.length, m3, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m3; ++i2)
            sink.point((point7 = segment[i2])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a3, b) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi3 - epsilon7 : halfPi3 - a3[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);
}
var init_clip = __esm({
  "node_modules/d3-geo/src/clip/index.js"() {
    init_shims();
    init_buffer2();
    init_rejoin();
    init_math4();
    init_polygonContains();
    init_src2();
  }
});

// node_modules/d3-geo/src/clip/antimeridian.js
function clipAntimeridianLine(stream) {
  var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi4 : -pi4, delta = abs3(lambda12 - lambda04);
      if (abs3(delta - pi4) < epsilon7) {
        stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        stream.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi4) {
        if (abs3(lambda04 - sign0) < epsilon7)
          lambda04 -= sign0 * epsilon7;
        if (abs3(lambda12 - sign1) < epsilon7)
          lambda12 -= sign1 * epsilon7;
        phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        clean = 0;
      }
      stream.point(lambda04 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda04 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {
  var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);
  return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi3;
    stream.point(-pi4, phi2);
    stream.point(0, phi2);
    stream.point(pi4, phi2);
    stream.point(pi4, 0);
    stream.point(pi4, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi4, -phi2);
    stream.point(-pi4, 0);
    stream.point(-pi4, phi2);
  } else if (abs3(from[0] - to[0]) > epsilon7) {
    var lambda = from[0] < to[0] ? pi4 : -pi4;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}
var antimeridian_default;
var init_antimeridian = __esm({
  "node_modules/d3-geo/src/clip/antimeridian.js"() {
    init_shims();
    init_clip();
    init_math4();
    antimeridian_default = clip_default(function() {
      return true;
    }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi4, -halfPi3]);
  }
});

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon7;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c5 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;
        if (!point0 && (v00 = v0 = v2))
          stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect2(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect2(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect2(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t4;
          if (!(c5 & c0) && (t4 = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1]);
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c5;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a3, b, two) {
    var pa = cartesian(a3), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a3;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B3);
    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0)
      return;
    var t4 = sqrt(t22), q = cartesianScale(u4, (-w - t4) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two)
      return q;
    var lambda04 = a3[0], lambda12 = b[0], phi02 = a3[1], phi12 = b[1], z;
    if (lambda12 < lambda04)
      z = lambda04, lambda04 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda04, polar = abs3(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;
    if (!polar && phi12 < phi02)
      z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs3(q[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u4, (-w + t4) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi4 - radius, code2 = 0;
    if (lambda < -r2)
      code2 |= 1;
    else if (lambda > r2)
      code2 |= 2;
    if (phi2 < -r2)
      code2 |= 4;
    else if (phi2 > r2)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi4, radius - pi4]);
}
var init_circle3 = __esm({
  "node_modules/d3-geo/src/clip/circle.js"() {
    init_shims();
    init_cartesian();
    init_circle2();
    init_math4();
    init_pointEqual();
    init_clip();
  }
});

// node_modules/d3-geo/src/clip/line.js
function line_default(a3, b, x06, y06, x12, y12) {
  var ax = a3[0], ay = a3[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x06 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t03)
      return;
    if (r2 < t13)
      t13 = r2;
  } else if (dx > 0) {
    if (r2 > t13)
      return;
    if (r2 > t03)
      t03 = r2;
  }
  r2 = x12 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t13)
      return;
    if (r2 > t03)
      t03 = r2;
  } else if (dx > 0) {
    if (r2 < t03)
      return;
    if (r2 < t13)
      t13 = r2;
  }
  r2 = y06 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t03)
      return;
    if (r2 < t13)
      t13 = r2;
  } else if (dy > 0) {
    if (r2 > t13)
      return;
    if (r2 > t03)
      t03 = r2;
  }
  r2 = y12 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t13)
      return;
    if (r2 > t03)
      t03 = r2;
  } else if (dy > 0) {
    if (r2 < t03)
      return;
    if (r2 < t13)
      t13 = r2;
  }
  if (t03 > 0)
    a3[0] = ax + t03 * dx, a3[1] = ay + t03 * dy;
  if (t13 < 1)
    b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;
  return true;
}
var init_line = __esm({
  "node_modules/d3-geo/src/clip/line.js"() {
    init_shims();
  }
});

// node_modules/d3-geo/src/clip/rectangle.js
function clipRectangle(x06, y06, x12, y12) {
  function visible(x5, y4) {
    return x06 <= x5 && x5 <= x12 && y06 <= y4 && y4 <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a3 = 0, a1 = 0;
    if (from == null || (a3 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x06 : x12, a3 > 1 ? y12 : y06);
      while ((a3 = (a3 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a3, b) {
    return comparePoint(a3.x, b.x);
  }
  function comparePoint(a3, b) {
    var ca3 = corner(a3, 1), cb = corner(b, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a3[1] : ca3 === 1 ? a3[0] - b[0] : ca3 === 2 ? a3[1] - b[1] : b[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x5, y4) {
      if (visible(x5, y4))
        activeStream.point(x5, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n = polygon.length; i2 < n; ++i2) {
        for (var ring2 = polygon[i2], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b02 = point7[0], b12 = point7[1]; j < m3; ++j) {
          a0 = b02, a1 = b12, point7 = ring2[j], b02 = point7[0], b12 = point7[1];
          if (a1 <= y12) {
            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0))
              ++winding;
          } else {
            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x5, y4) {
      var v2 = visible(x5, y4);
      if (polygon)
        ring.push([x5, y4]);
      if (first) {
        x__ = x5, y__ = y4, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x5, y4);
        }
      } else {
        if (v2 && v_)
          activeStream.point(x5, y4);
        else {
          var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x5 = Math.max(clipMin, Math.min(clipMax, x5)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default(a3, b, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v2)
              activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x5, y4);
            clean = false;
          }
        }
      }
      x_ = x5, y_ = y4, v_ = v2;
    }
    return clipStream;
  };
}
var clipMax, clipMin;
var init_rectangle = __esm({
  "node_modules/d3-geo/src/clip/rectangle.js"() {
    init_shims();
    init_math4();
    init_buffer2();
    init_line();
    init_rejoin();
    init_src2();
    clipMax = 1e9;
    clipMin = -clipMax;
  }
});

// node_modules/d3-geo/src/clip/extent.js
function extent_default2() {
  var x06 = 0, y06 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip;
  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip) : [[x06, y06], [x12, y12]];
    }
  };
}
var init_extent3 = __esm({
  "node_modules/d3-geo/src/clip/extent.js"() {
    init_shims();
    init_rectangle();
  }
});

// node_modules/d3-geo/src/length.js
function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop4;
}
function lengthPointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);
  lengthStream.point = lengthPoint;
}
function lengthPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs3(lambda - lambda03), cosDelta = cos2(delta), sinDelta = sin2(delta), x5 = cosPhi * sinDelta, y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x5 * x5 + y4 * y4), z));
  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
}
function length_default(object2) {
  lengthSum = new Adder();
  stream_default(object2, lengthStream);
  return +lengthSum;
}
var lengthSum, lambda03, sinPhi02, cosPhi02, lengthStream;
var init_length = __esm({
  "node_modules/d3-geo/src/length.js"() {
    init_shims();
    init_src2();
    init_math4();
    init_noop2();
    init_stream();
    lengthStream = {
      sphere: noop4,
      point: noop4,
      lineStart: lengthLineStart,
      lineEnd: noop4,
      polygonStart: noop4,
      polygonEnd: noop4
    };
  }
});

// node_modules/d3-geo/src/distance.js
function distance_default(a3, b) {
  coordinates[0] = a3;
  coordinates[1] = b;
  return length_default(object);
}
var coordinates, object;
var init_distance = __esm({
  "node_modules/d3-geo/src/distance.js"() {
    init_shims();
    init_length();
    coordinates = [null, null];
    object = { type: "LineString", coordinates };
  }
});

// node_modules/d3-geo/src/contains.js
function containsGeometry(geometry, point6) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point6) : false;
}
function containsPoint(coordinates2, point6) {
  return distance_default(coordinates2, point6) === 0;
}
function containsLine(coordinates2, point6) {
  var ao, bo, ab4;
  for (var i2 = 0, n = coordinates2.length; i2 < n; i2++) {
    bo = distance_default(coordinates2[i2], point6);
    if (bo === 0)
      return true;
    if (i2 > 0) {
      ab4 = distance_default(coordinates2[i2], coordinates2[i2 - 1]);
      if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)
        return true;
    }
    ao = bo;
  }
  return false;
}
function containsPolygon(coordinates2, point6) {
  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point6));
}
function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point6) {
  return [point6[0] * radians2, point6[1] * radians2];
}
function contains_default2(object2, point6) {
  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point6);
}
var containsObjectType, containsGeometryType;
var init_contains2 = __esm({
  "node_modules/d3-geo/src/contains.js"() {
    init_shims();
    init_polygonContains();
    init_distance();
    init_math4();
    containsObjectType = {
      Feature: function(object2, point6) {
        return containsGeometry(object2.geometry, point6);
      },
      FeatureCollection: function(object2, point6) {
        var features = object2.features, i2 = -1, n = features.length;
        while (++i2 < n)
          if (containsGeometry(features[i2].geometry, point6))
            return true;
        return false;
      }
    };
    containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object2, point6) {
        return containsPoint(object2.coordinates, point6);
      },
      MultiPoint: function(object2, point6) {
        var coordinates2 = object2.coordinates, i2 = -1, n = coordinates2.length;
        while (++i2 < n)
          if (containsPoint(coordinates2[i2], point6))
            return true;
        return false;
      },
      LineString: function(object2, point6) {
        return containsLine(object2.coordinates, point6);
      },
      MultiLineString: function(object2, point6) {
        var coordinates2 = object2.coordinates, i2 = -1, n = coordinates2.length;
        while (++i2 < n)
          if (containsLine(coordinates2[i2], point6))
            return true;
        return false;
      },
      Polygon: function(object2, point6) {
        return containsPolygon(object2.coordinates, point6);
      },
      MultiPolygon: function(object2, point6) {
        var coordinates2 = object2.coordinates, i2 = -1, n = coordinates2.length;
        while (++i2 < n)
          if (containsPolygon(coordinates2[i2], point6))
            return true;
        return false;
      },
      GeometryCollection: function(object2, point6) {
        var geometries = object2.geometries, i2 = -1, n = geometries.length;
        while (++i2 < n)
          if (containsGeometry(geometries[i2], point6))
            return true;
        return false;
      }
    };
  }
});

// node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y4 = range(y06, y12 - epsilon7, dy).concat(y12);
  return function(x5) {
    return y4.map(function(y5) {
      return [x5, y5];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x5 = range(x06, x12 - epsilon7, dx).concat(x12);
  return function(y4) {
    return x5.map(function(x6) {
      return [x6, y4];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x5, y4, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x6) {
      return abs3(x6 % DX) > epsilon7;
    }).map(x5)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {
      return abs3(y5 % DY) > epsilon7;
    }).map(y4));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X03).concat(Y3(Y13).slice(1), X3(X13).reverse().slice(1), Y3(Y03).reverse().slice(1))
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length)
      return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13)
      _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13)
      _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length)
      return [[x06, y06], [x12, y12]];
    x06 = +_[0][0], x12 = +_[1][0];
    y06 = +_[0][1], y12 = +_[1][1];
    if (x06 > x12)
      _ = x06, x06 = x12, x12 = _;
    if (y06 > y12)
      _ = y06, y06 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length)
      return precision;
    precision = +_;
    x5 = graticuleX(y06, y12, 90);
    y4 = graticuleY(x06, x12, precision);
    X3 = graticuleX(Y03, Y13, 90);
    Y3 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon7], [180, 90 - epsilon7]]).extentMinor([[-180, -80 - epsilon7], [180, 80 + epsilon7]]);
}
function graticule10() {
  return graticule()();
}
var init_graticule = __esm({
  "node_modules/d3-geo/src/graticule.js"() {
    init_shims();
    init_src2();
    init_math4();
  }
});

// node_modules/d3-geo/src/interpolate.js
function interpolate_default2(a3, b) {
  var x06 = a3[0] * radians2, y06 = a3[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k2 = sin2(d);
  var interpolate = d ? function(t4) {
    var B3 = sin2(t4 *= d) / k2, A5 = sin2(d - t4) / k2, x5 = A5 * kx0 + B3 * kx1, y4 = A5 * ky0 + B3 * ky1, z = A5 * sy0 + B3 * sy1;
    return [
      atan2(y4, x5) * degrees3,
      atan2(z, sqrt(x5 * x5 + y4 * y4)) * degrees3
    ];
  } : function() {
    return [x06 * degrees3, y06 * degrees3];
  };
  interpolate.distance = d;
  return interpolate;
}
var init_interpolate2 = __esm({
  "node_modules/d3-geo/src/interpolate.js"() {
    init_shims();
    init_math4();
  }
});

// node_modules/d3-geo/src/identity.js
var identity_default3;
var init_identity4 = __esm({
  "node_modules/d3-geo/src/identity.js"() {
    init_shims();
    identity_default3 = (x5) => x5;
  }
});

// node_modules/d3-geo/src/path/area.js
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x5, y4) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x5, y00 = y02 = y4;
}
function areaPoint2(x5, y4) {
  areaRingSum2.add(y02 * x5 - x02 * y4);
  x02 = x5, y02 = y4;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var areaSum2, areaRingSum2, x00, y00, x02, y02, areaStream2, area_default3;
var init_area3 = __esm({
  "node_modules/d3-geo/src/path/area.js"() {
    init_shims();
    init_src2();
    init_math4();
    init_noop2();
    areaSum2 = new Adder();
    areaRingSum2 = new Adder();
    areaStream2 = {
      point: noop4,
      lineStart: noop4,
      lineEnd: noop4,
      polygonStart: function() {
        areaStream2.lineStart = areaRingStart2;
        areaStream2.lineEnd = areaRingEnd2;
      },
      polygonEnd: function() {
        areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop4;
        areaSum2.add(abs3(areaRingSum2));
        areaRingSum2 = new Adder();
      },
      result: function() {
        var area = areaSum2 / 2;
        areaSum2 = new Adder();
        return area;
      }
    };
    area_default3 = areaStream2;
  }
});

// node_modules/d3-geo/src/path/bounds.js
function boundsPoint2(x5, y4) {
  if (x5 < x03)
    x03 = x5;
  if (x5 > x1)
    x1 = x5;
  if (y4 < y03)
    y03 = y4;
  if (y4 > y1)
    y1 = y4;
}
var x03, y03, x1, y1, boundsStream2, bounds_default2;
var init_bounds2 = __esm({
  "node_modules/d3-geo/src/path/bounds.js"() {
    init_shims();
    init_noop2();
    x03 = Infinity;
    y03 = x03;
    x1 = -x03;
    y1 = x1;
    boundsStream2 = {
      point: boundsPoint2,
      lineStart: noop4,
      lineEnd: noop4,
      polygonStart: noop4,
      polygonEnd: noop4,
      result: function() {
        var bounds = [[x03, y03], [x1, y1]];
        x1 = y1 = -(y03 = x03 = Infinity);
        return bounds;
      }
    };
    bounds_default2 = boundsStream2;
  }
});

// node_modules/d3-geo/src/path/centroid.js
function centroidPoint2(x5, y4) {
  X02 += x5;
  Y02 += y4;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x5, y4) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x5, y04 = y4);
}
function centroidPointLine(x5, y4) {
  var dx = x5 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);
  X12 += z * (x04 + x5) / 2;
  Y12 += z * (y04 + y4) / 2;
  Z12 += z;
  centroidPoint2(x04 = x5, y04 = y4);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x5, y4) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x5, y002 = y04 = y4);
}
function centroidPointRing(x5, y4) {
  var dx = x5 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);
  X12 += z * (x04 + x5) / 2;
  Y12 += z * (y04 + y4) / 2;
  Z12 += z;
  z = y04 * x5 - x04 * y4;
  X22 += z * (x04 + x5);
  Y22 += z * (y04 + y4);
  Z22 += z * 3;
  centroidPoint2(x04 = x5, y04 = y4);
}
var X02, Y02, Z02, X12, Y12, Z12, X22, Y22, Z22, x002, y002, x04, y04, centroidStream2, centroid_default2;
var init_centroid2 = __esm({
  "node_modules/d3-geo/src/path/centroid.js"() {
    init_shims();
    init_math4();
    X02 = 0;
    Y02 = 0;
    Z02 = 0;
    X12 = 0;
    Y12 = 0;
    Z12 = 0;
    X22 = 0;
    Y22 = 0;
    Z22 = 0;
    centroidStream2 = {
      point: centroidPoint2,
      lineStart: centroidLineStart2,
      lineEnd: centroidLineEnd2,
      polygonStart: function() {
        centroidStream2.lineStart = centroidRingStart2;
        centroidStream2.lineEnd = centroidRingEnd2;
      },
      polygonEnd: function() {
        centroidStream2.point = centroidPoint2;
        centroidStream2.lineStart = centroidLineStart2;
        centroidStream2.lineEnd = centroidLineEnd2;
      },
      result: function() {
        var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
        X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
        return centroid;
      }
    };
    centroid_default2 = centroidStream2;
  }
});

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
var init_context = __esm({
  "node_modules/d3-geo/src/path/context.js"() {
    init_shims();
    init_math4();
    init_noop2();
    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x5, y4) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x5, y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x5, y4);
            break;
          }
          default: {
            this._context.moveTo(x5 + this._radius, y4);
            this._context.arc(x5, y4, this._radius, 0, tau5);
            break;
          }
        }
      },
      result: noop4
    };
  }
});

// node_modules/d3-geo/src/path/measure.js
function lengthPointFirst2(x5, y4) {
  lengthStream2.point = lengthPoint2;
  x003 = x05 = x5, y003 = y05 = y4;
}
function lengthPoint2(x5, y4) {
  x05 -= x5, y05 -= y4;
  lengthSum2.add(sqrt(x05 * x05 + y05 * y05));
  x05 = x5, y05 = y4;
}
var lengthSum2, lengthRing, x003, y003, x05, y05, lengthStream2, measure_default;
var init_measure = __esm({
  "node_modules/d3-geo/src/path/measure.js"() {
    init_shims();
    init_src2();
    init_math4();
    init_noop2();
    lengthSum2 = new Adder();
    lengthStream2 = {
      point: noop4,
      lineStart: function() {
        lengthStream2.point = lengthPointFirst2;
      },
      lineEnd: function() {
        if (lengthRing)
          lengthPoint2(x003, y003);
        lengthStream2.point = noop4;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length3 = +lengthSum2;
        lengthSum2 = new Adder();
        return length3;
      }
    };
    measure_default = lengthStream2;
  }
});

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
var init_string2 = __esm({
  "node_modules/d3-geo/src/path/string.js"() {
    init_shims();
    PathString.prototype = {
      _radius: 4.5,
      _circle: circle(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius)
          this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._string.push("Z");
        this._point = NaN;
      },
      point: function(x5, y4) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x5, ",", y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x5, ",", y4);
            break;
          }
          default: {
            if (this._circle == null)
              this._circle = circle(this._radius);
            this._string.push("M", x5, ",", y4, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };
  }
});

// node_modules/d3-geo/src/path/index.js
function path_default2(projection2, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path2(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object2) {
    stream_default(object2, projectionStream(area_default3));
    return area_default3.result();
  };
  path2.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path2.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path2.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity_default3) : (projection2 = _).stream, path2) : projection2;
  };
  path2.context = function(_) {
    if (!arguments.length)
      return context;
    contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path2;
  };
  return path2.projection(projection2).context(context);
}
var init_path3 = __esm({
  "node_modules/d3-geo/src/path/index.js"() {
    init_shims();
    init_identity4();
    init_stream();
    init_area3();
    init_bounds2();
    init_centroid2();
    init_context();
    init_measure();
    init_string2();
  }
});

// node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s4 = new TransformStream();
    for (var key in methods)
      s4[key] = methods[key];
    s4.stream = stream;
    return s4;
  };
}
function TransformStream() {
}
var init_transform2 = __esm({
  "node_modules/d3-geo/src/transform.js"() {
    init_shims();
    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x5, y4) {
        this.stream.point(x5, y4);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
  }
});

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object2) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null)
    projection2.clipExtent(null);
  stream_default(object2, projection2.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip != null)
    projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b) {
    var w = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h2 / (b[1][1] - b[0][1])), x5 = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = +extent2[0][1] + (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x5, y4]);
  }, object2);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}
function fitWidth(projection2, width, object2) {
  return fit(projection2, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x5 = (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x5, y4]);
  }, object2);
}
function fitHeight(projection2, height, object2) {
  return fit(projection2, function(b) {
    var h2 = +height, k2 = h2 / (b[1][1] - b[0][1]), x5 = -k2 * b[0][0], y4 = (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x5, y4]);
  }, object2);
}
var init_fit = __esm({
  "node_modules/d3-geo/src/projection/fit.js"() {
    init_shims();
    init_stream();
    init_bounds2();
  }
});

// node_modules/d3-geo/src/projection/resample.js
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x5, y4) {
      x5 = project(x5, y4);
      this.stream.point(x5[0], x5[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b = b02 + b12, c5 = c0 + c1, m3 = sqrt(a3 * a3 + b * b + c5 * c5), phi2 = asin(c5 /= m3), lambda22 = abs3(abs3(c5) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b, a3), p = project(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a3 /= m3, b /= m3, c5, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda22, a3, b, c5, x12, y12, lambda12, a1, b12, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x5, y4) {
      x5 = project(x5, y4);
      stream.point(x5[0], x5[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint2;
      stream.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c5 = cartesian([lambda, phi2]), p = project(lambda, phi2);
      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c5[0], b02 = c5[1], c0 = c5[2], maxDepth, stream);
      stream.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var maxDepth, cosMinDistance;
var init_resample = __esm({
  "node_modules/d3-geo/src/projection/resample.js"() {
    init_shims();
    init_cartesian();
    init_math4();
    init_transform2();
    maxDepth = 16;
    cosMinDistance = cos2(30 * radians2);
  }
});

// node_modules/d3-geo/src/projection/index.js
function transformRotate(rotate) {
  return transformer({
    point: function(x5, y4) {
      var r2 = rotate(x5, y4);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x5, y4) {
    x5 *= sx;
    y4 *= sy;
    return [dx + k2 * x5, dy - k2 * y4];
  }
  transform2.invert = function(x5, y4) {
    return [(x5 - dx) / k2 * sx, (dy - y4) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a3 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x5, y4) {
    x5 *= sx;
    y4 *= sy;
    return [a3 * x5 - b * y4 + dx, dy - b * x5 - a3 * y4];
  }
  transform2.invert = function(x5, y4) {
    return [sx * (ai * x5 - bi * y4 + ci), sy * (fi - bi * x5 - ai * y4)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x5 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection2(point6) {
    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
  }
  function invert(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees3, point6[1] * degrees3];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, recenter()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x5 = +_[0], y4 = +_[1], recenter()) : [x5, y4];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width, object2) {
    return fitWidth(projection2, width, object2);
  };
  projection2.fitHeight = function(height, object2) {
    return fitHeight(projection2, height, object2);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x5 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}
var transformRadians;
var init_projection = __esm({
  "node_modules/d3-geo/src/projection/index.js"() {
    init_shims();
    init_antimeridian();
    init_circle3();
    init_rectangle();
    init_compose();
    init_identity4();
    init_math4();
    init_rotation();
    init_transform2();
    init_fit();
    init_resample();
    transformRadians = transformer({
      point: function(x5, y4) {
        this.stream.point(x5 * radians2, y4 * radians2);
      }
    });
  }
});

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi4 / 3, m3 = projectionMutator(projectAt), p = m3(phi02, phi12);
  p.parallels = function(_) {
    return arguments.length ? m3(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];
  };
  return p;
}
var init_conic = __esm({
  "node_modules/d3-geo/src/projection/conic.js"() {
    init_shims();
    init_math4();
    init_projection();
  }
});

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi03 = cos2(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi03, sin2(phi2) / cosPhi03];
  }
  forward.invert = function(x5, y4) {
    return [x5 / cosPhi03, asin(y4 * cosPhi03)];
  };
  return forward;
}
var init_cylindricalEqualArea = __esm({
  "node_modules/d3-geo/src/projection/cylindricalEqualArea.js"() {
    init_shims();
    init_math4();
  }
});

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y12) {
  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;
  if (abs3(n) < epsilon7)
    return cylindricalEqualAreaRaw(y06);
  var c5 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c5) / n;
  function project(x5, y4) {
    var r2 = sqrt(c5 - 2 * n * sin2(y4)) / n;
    return [r2 * sin2(x5 *= n), r0 - r2 * cos2(x5)];
  }
  project.invert = function(x5, y4) {
    var r0y = r0 - y4, l = atan2(x5, abs3(r0y)) * sign(r0y);
    if (r0y * n < 0)
      l -= pi4 * sign(x5) * sign(r0y);
    return [l / n, asin((c5 - (x5 * x5 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
var init_conicEqualArea = __esm({
  "node_modules/d3-geo/src/projection/conicEqualArea.js"() {
    init_shims();
    init_math4();
    init_conic();
    init_cylindricalEqualArea();
  }
});

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
var init_albers = __esm({
  "node_modules/d3-geo/src/projection/albers.js"() {
    init_shims();
    init_conicEqualArea();
  }
});

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x5, y4) {
      var i2 = -1;
      while (++i2 < n)
        streams[i2].point(x5, y4);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n)
        streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n)
        streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n)
        streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n)
        streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n)
        streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x5, y4) {
    point6 = [x5, y4];
  } };
  function albersUsa(coordinates2) {
    var x5 = coordinates2[0], y4 = coordinates2[1];
    return point6 = null, (lower48Point.point(x5, y4), point6) || (alaskaPoint.point(x5, y4), point6) || (hawaiiPoint.point(x5, y4), point6);
  }
  albersUsa.invert = function(coordinates2) {
    var k2 = lower48.scale(), t4 = lower48.translate(), x5 = (coordinates2[0] - t4[0]) / k2, y4 = (coordinates2[1] - t4[1]) / k2;
    return (y4 >= 0.12 && y4 < 0.234 && x5 >= -0.425 && x5 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x5 >= -0.214 && x5 < -0.115 ? hawaii : lower48).invert(coordinates2);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length)
      return lower48.translate();
    var k2 = lower48.scale(), x5 = +_[0], y4 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x5 - 0.455 * k2, y4 - 0.238 * k2], [x5 + 0.455 * k2, y4 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x5 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([[x5 - 0.425 * k2 + epsilon7, y4 + 0.12 * k2 + epsilon7], [x5 - 0.214 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x5 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([[x5 - 0.214 * k2 + epsilon7, y4 + 0.166 * k2 + epsilon7], [x5 - 0.115 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa, extent2, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width, object2) {
    return fitWidth(albersUsa, width, object2);
  };
  albersUsa.fitHeight = function(height, object2) {
    return fitHeight(albersUsa, height, object2);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}
var init_albersUsa = __esm({
  "node_modules/d3-geo/src/projection/albersUsa.js"() {
    init_shims();
    init_math4();
    init_albers();
    init_conicEqualArea();
    init_fit();
  }
});

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale2) {
  return function(x5, y4) {
    var cx = cos2(x5), cy = cos2(y4), k2 = scale2(cx * cy);
    if (k2 === Infinity)
      return [2, 0];
    return [
      k2 * cy * sin2(x5),
      k2 * sin2(y4)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x5, y4) {
    var z = sqrt(x5 * x5 + y4 * y4), c5 = angle2(z), sc = sin2(c5), cc2 = cos2(c5);
    return [
      atan2(x5 * sc, z * cc2),
      asin(z && y4 * sc / z)
    ];
  };
}
var init_azimuthal = __esm({
  "node_modules/d3-geo/src/projection/azimuthal.js"() {
    init_shims();
    init_math4();
  }
});

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
var azimuthalEqualAreaRaw;
var init_azimuthalEqualArea = __esm({
  "node_modules/d3-geo/src/projection/azimuthalEqualArea.js"() {
    init_shims();
    init_math4();
    init_azimuthal();
    init_projection();
    azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin(z / 2);
    });
  }
});

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
var azimuthalEquidistantRaw;
var init_azimuthalEquidistant = __esm({
  "node_modules/d3-geo/src/projection/azimuthalEquidistant.js"() {
    init_shims();
    init_math4();
    init_azimuthal();
    init_projection();
    azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
      return (c5 = acos(c5)) && c5 / sin2(c5);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });
  }
});

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi3 + phi2) / 2))];
}
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau5);
}
function mercatorProjection(project) {
  var m3 = projection(project), center2 = m3.center, scale2 = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x06 = null, y06, x12, y12;
  m3.scale = function(_) {
    return arguments.length ? (scale2(_), reclip()) : scale2();
  };
  m3.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };
  m3.center = function(_) {
    return arguments.length ? (center2(_), reclip()) : center2();
  };
  m3.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  function reclip() {
    var k2 = pi4 * scale2(), t4 = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t4[0] - k2, t4[1] - k2], [t4[0] + k2, t4[1] + k2]] : project === mercatorRaw ? [[Math.max(t4[0] - k2, x06), y06], [Math.min(t4[0] + k2, x12), y12]] : [[x06, Math.max(t4[1] - k2, y06)], [x12, Math.min(t4[1] + k2, y12)]]);
  }
  return reclip();
}
var init_mercator = __esm({
  "node_modules/d3-geo/src/projection/mercator.js"() {
    init_shims();
    init_math4();
    init_rotation();
    init_projection();
    mercatorRaw.invert = function(x5, y4) {
      return [x5, 2 * atan(exp(y4)) - halfPi3];
    };
  }
});

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y4) {
  return tan((halfPi3 + y4) / 2);
}
function conicConformalRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)), f3 = cy0 * pow2(tany(y06), n) / n;
  if (!n)
    return mercatorRaw;
  function project(x5, y4) {
    if (f3 > 0) {
      if (y4 < -halfPi3 + epsilon7)
        y4 = -halfPi3 + epsilon7;
    } else {
      if (y4 > halfPi3 - epsilon7)
        y4 = halfPi3 - epsilon7;
    }
    var r2 = f3 / pow2(tany(y4), n);
    return [r2 * sin2(n * x5), f3 - r2 * cos2(n * x5)];
  }
  project.invert = function(x5, y4) {
    var fy = f3 - y4, r2 = sign(n) * sqrt(x5 * x5 + fy * fy), l = atan2(x5, abs3(fy)) * sign(fy);
    if (fy * n < 0)
      l -= pi4 * sign(x5) * sign(fy);
    return [l / n, 2 * atan(pow2(f3 / r2, 1 / n)) - halfPi3];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
var init_conicConformal = __esm({
  "node_modules/d3-geo/src/projection/conicConformal.js"() {
    init_shims();
    init_math4();
    init_conic();
    init_mercator();
  }
});

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}
var init_equirectangular = __esm({
  "node_modules/d3-geo/src/projection/equirectangular.js"() {
    init_shims();
    init_projection();
    equirectangularRaw.invert = equirectangularRaw;
  }
});

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;
  if (abs3(n) < epsilon7)
    return equirectangularRaw;
  function project(x5, y4) {
    var gy = g - y4, nx = n * x5;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x5, y4) {
    var gy = g - y4, l = atan2(x5, abs3(gy)) * sign(gy);
    if (gy * n < 0)
      l -= pi4 * sign(x5) * sign(gy);
    return [l / n, g - sign(n) * sqrt(x5 * x5 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var init_conicEquidistant = __esm({
  "node_modules/d3-geo/src/projection/conicEquidistant.js"() {
    init_shims();
    init_math4();
    init_conic();
    init_equirectangular();
  }
});

// node_modules/d3-geo/src/projection/equalEarth.js
function equalEarthRaw(lambda, phi2) {
  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2))
  ];
}
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}
var A1, A22, A3, A4, M, iterations;
var init_equalEarth = __esm({
  "node_modules/d3-geo/src/projection/equalEarth.js"() {
    init_shims();
    init_projection();
    init_math4();
    A1 = 1.340264;
    A22 = -0.081106;
    A3 = 893e-6;
    A4 = 3796e-6;
    M = sqrt(3) / 2;
    iterations = 12;
    equalEarthRaw.invert = function(x5, y4) {
      var l = y4, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i2 = 0, delta, fy, fpy; i2 < iterations; ++i2) {
        fy = l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2)) - y4;
        fpy = A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs3(delta) < epsilon22)
          break;
      }
      return [
        M * x5 * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
        asin(sin2(l) / M)
      ];
    };
  }
});

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x5, y4) {
  var cy = cos2(y4), k2 = cos2(x5) * cy;
  return [cy * sin2(x5) / k2, sin2(y4) / k2];
}
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}
var init_gnomonic = __esm({
  "node_modules/d3-geo/src/projection/gnomonic.js"() {
    init_shims();
    init_math4();
    init_azimuthal();
    init_projection();
    gnomonicRaw.invert = azimuthalInvert(atan);
  }
});

// node_modules/d3-geo/src/projection/identity.js
function identity_default4() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa, x06 = null, y06, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({
    point: function(x5, y4) {
      var p = projection2([x5, y4]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default3, cache, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache = cacheStream = null;
    return projection2;
  }
  function projection2(p) {
    var x5 = p[0] * kx2, y4 = p[1] * ky2;
    if (alpha) {
      var t4 = y4 * ca3 - x5 * sa;
      x5 = x5 * ca3 + y4 * sa;
      y4 = t4;
    }
    return [x5 + tx, y4 + ty];
  }
  projection2.invert = function(p) {
    var x5 = p[0] - tx, y4 = p[1] - ty;
    if (alpha) {
      var t4 = y4 * ca3 + x5 * sa;
      x5 = x5 * ca3 - y4 * sa;
      y4 = t4;
    }
    return [x5 / kx2, y4 / ky2];
  };
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, reset()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset()) : alpha * degrees3;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width, object2) {
    return fitWidth(projection2, width, object2);
  };
  projection2.fitHeight = function(height, object2) {
    return fitHeight(projection2, height, object2);
  };
  return projection2;
}
var init_identity5 = __esm({
  "node_modules/d3-geo/src/projection/identity.js"() {
    init_shims();
    init_rectangle();
    init_identity4();
    init_transform2();
    init_fit();
    init_math4();
  }
});

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}
var init_naturalEarth1 = __esm({
  "node_modules/d3-geo/src/projection/naturalEarth1.js"() {
    init_shims();
    init_projection();
    init_math4();
    naturalEarth1Raw.invert = function(x5, y4) {
      var phi2 = y4, i2 = 25, delta;
      do {
        var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
      } while (abs3(delta) > epsilon7 && --i2 > 0);
      return [
        x5 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x5, y4) {
  return [cos2(y4) * sin2(x5), sin2(y4)];
}
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);
}
var init_orthographic = __esm({
  "node_modules/d3-geo/src/projection/orthographic.js"() {
    init_shims();
    init_math4();
    init_azimuthal();
    init_projection();
    orthographicRaw.invert = azimuthalInvert(asin);
  }
});

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x5, y4) {
  var cy = cos2(y4), k2 = 1 + cos2(x5) * cy;
  return [cy * sin2(x5) / k2, sin2(y4) / k2];
}
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}
var init_stereographic = __esm({
  "node_modules/d3-geo/src/projection/stereographic.js"() {
    init_shims();
    init_math4();
    init_azimuthal();
    init_projection();
    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });
  }
});

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi3 + phi2) / 2)), -lambda];
}
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;
  m3.center = function(_) {
    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
  };
  m3.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}
var init_transverseMercator = __esm({
  "node_modules/d3-geo/src/projection/transverseMercator.js"() {
    init_shims();
    init_math4();
    init_mercator();
    transverseMercatorRaw.invert = function(x5, y4) {
      return [-y4, 2 * atan(exp(x5)) - halfPi3];
    };
  }
});

// node_modules/d3-geo/src/index.js
var init_src22 = __esm({
  "node_modules/d3-geo/src/index.js"() {
    init_shims();
    init_area2();
    init_bounds();
    init_centroid();
    init_circle2();
    init_antimeridian();
    init_circle3();
    init_extent3();
    init_rectangle();
    init_contains2();
    init_distance();
    init_graticule();
    init_interpolate2();
    init_length();
    init_path3();
    init_albers();
    init_albersUsa();
    init_azimuthalEqualArea();
    init_azimuthalEquidistant();
    init_conicConformal();
    init_conicEqualArea();
    init_conicEquidistant();
    init_equalEarth();
    init_equirectangular();
    init_gnomonic();
    init_identity5();
    init_projection();
    init_mercator();
    init_naturalEarth1();
    init_orthographic();
    init_stereographic();
    init_transverseMercator();
    init_rotation();
    init_stream();
    init_transform2();
  }
});

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a3, b) {
  return a3.parent === b.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x5, c5) {
  return x5 + c5.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y4, c5) {
  return Math.max(y4, c5.y);
}
function leafLeft(node) {
  var children2;
  while (children2 = node.children)
    node = children2[0];
  return node;
}
function leafRight(node) {
  var children2;
  while (children2 = node.children)
    node = children2[children2.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root3) {
    var previousNode, x5 = 0;
    root3.eachAfter(function(node) {
      var children2 = node.children;
      if (children2) {
        node.x = meanX(children2);
        node.y = maxY(children2);
      } else {
        node.x = previousNode ? x5 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root3), right2 = leafRight(root3), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root3.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root3.x) * dx;
      node.y = (root3.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x06) / (x12 - x06) * dx;
      node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;
    });
  }
  cluster.separation = function(x5) {
    return arguments.length ? (separation = x5, cluster) : separation;
  };
  cluster.size = function(x5) {
    return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x5) {
    return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}
var init_cluster = __esm({
  "node_modules/d3-hierarchy/src/cluster.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum4 = 0, children2 = node.children, i2 = children2 && children2.length;
  if (!i2)
    sum4 = 1;
  else
    while (--i2 >= 0)
      sum4 += children2[i2].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count2);
}
var init_count2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/count.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}
var init_each2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/each.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i2, index3 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index3, this);
    if (children2 = node.children) {
      for (i2 = children2.length - 1; i2 >= 0; --i2) {
        nodes.push(children2[i2]);
      }
    }
  }
  return this;
}
var init_eachBefore = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/eachBefore.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i2, n, index3 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i2 = 0, n = children2.length; i2 < n; ++i2) {
        nodes.push(children2[i2]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}
var init_eachAfter = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/eachAfter.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index3, this)) {
      return node;
    }
  }
}
var init_find2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/find.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum4 = +value(node.data) || 0, children2 = node.children, i2 = children2 && children2.length;
    while (--i2 >= 0)
      sum4 += children2[i2].value;
    node.value = sum4;
  });
}
var init_sum2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/sum.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
var init_sort3 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/sort.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default3(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a3, b) {
  if (a3 === b)
    return a3;
  var aNodes = a3.ancestors(), bNodes = b.ancestors(), c5 = null;
  a3 = aNodes.pop();
  b = bNodes.pop();
  while (a3 === b) {
    c5 = a3;
    a3 = aNodes.pop();
    b = bNodes.pop();
  }
  return c5;
}
var init_path4 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/path.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
var init_ancestors = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/ancestors.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}
var init_descendants = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/descendants.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
var init_leaves = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/leaves.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root3 = this, links = [];
  root3.each(function(node) {
    if (node !== root3) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
var init_links = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/links.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i2, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i2 = 0, n = children2.length; i2 < n; ++i2) {
          next.push(children2[i2]);
        }
      }
    }
  } while (next.length);
}
var init_iterator2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/iterator.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root3 = new Node(data), node, nodes = [root3], child, childs, i2, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i2 = n - 1; i2 >= 0; --i2) {
        nodes.push(child = childs[i2] = new Node(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root3.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
var init_hierarchy = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/index.js"() {
    init_shims();
    init_count2();
    init_each2();
    init_eachBefore();
    init_eachAfter();
    init_find2();
    init_sum2();
    init_sort3();
    init_path4();
    init_ancestors();
    init_descendants();
    init_leaves();
    init_links();
    init_iterator2();
    Node.prototype = hierarchy.prototype = {
      constructor: Node,
      count: count_default,
      each: each_default2,
      eachAfter: eachAfter_default,
      eachBefore: eachBefore_default,
      find: find_default2,
      sum: sum_default,
      sort: sort_default2,
      path: path_default3,
      ancestors: ancestors_default,
      descendants: descendants_default,
      leaves: leaves_default,
      links: links_default,
      copy: node_copy,
      [Symbol.iterator]: iterator_default2
    };
  }
});

// node_modules/d3-hierarchy/src/array.js
function array_default2(x5) {
  return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
}
function shuffle(array4) {
  var m3 = array4.length, t4, i2;
  while (m3) {
    i2 = Math.random() * m3-- | 0;
    t4 = array4[m3];
    array4[m3] = array4[i2];
    array4[i2] = t4;
  }
  return array4;
}
var init_array6 = __esm({
  "node_modules/d3-hierarchy/src/array.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
  var i2 = 0, n = (circles = shuffle(Array.from(circles))).length, B3 = [], p, e3;
  while (i2 < n) {
    p = circles[i2];
    if (e3 && enclosesWeak(e3, p))
      ++i2;
    else
      e3 = encloseBasis(B3 = extendBasis(B3, p)), i2 = 0;
  }
  return e3;
}
function extendBasis(B3, p) {
  var i2, j;
  if (enclosesWeakAll(p, B3))
    return [p];
  for (i2 = 0; i2 < B3.length; ++i2) {
    if (enclosesNot(p, B3[i2]) && enclosesWeakAll(encloseBasis2(B3[i2], p), B3)) {
      return [B3[i2], p];
    }
  }
  for (i2 = 0; i2 < B3.length - 1; ++i2) {
    for (j = i2 + 1; j < B3.length; ++j) {
      if (enclosesNot(encloseBasis2(B3[i2], B3[j]), p) && enclosesNot(encloseBasis2(B3[i2], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i2]) && enclosesWeakAll(encloseBasis3(B3[i2], B3[j], p), B3)) {
        return [B3[i2], B3[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a3, b) {
  var dr = a3.r - b.r, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a3, b) {
  var dr = a3.r - b.r + Math.max(a3.r, b.r, 1) * 1e-9, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a3, B3) {
  for (var i2 = 0; i2 < B3.length; ++i2) {
    if (!enclosesWeak(a3, B3[i2])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B3) {
  switch (B3.length) {
    case 1:
      return encloseBasis1(B3[0]);
    case 2:
      return encloseBasis2(B3[0], B3[1]);
    case 3:
      return encloseBasis3(B3[0], B3[1], B3[2]);
  }
}
function encloseBasis1(a3) {
  return {
    x: a3.x,
    y: a3.y,
    r: a3.r
  };
}
function encloseBasis2(a3, b) {
  var x12 = a3.x, y12 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a3, b, c5) {
  var x12 = a3.x, y12 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x32 = c5.x, y32 = c5.y, r3 = c5.r, a22 = x12 - x22, a32 = x12 - x32, b22 = y12 - y22, b32 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x12, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r4 = -(A5 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);
  return {
    x: x12 + xa + xb * r4,
    y: y12 + ya + yb * r4,
    r: r4
  };
}
var init_enclose = __esm({
  "node_modules/d3-hierarchy/src/pack/enclose.js"() {
    init_shims();
    init_array6();
  }
});

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a3, c5) {
  var dx = b.x - a3.x, x5, a22, dy = b.y - a3.y, y4, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a3.r + c5.r, a22 *= a22;
    b22 = b.r + c5.r, b22 *= b22;
    if (a22 > b22) {
      x5 = (d2 + b22 - a22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, b22 / d2 - x5 * x5));
      c5.x = b.x - x5 * dx - y4 * dy;
      c5.y = b.y - x5 * dy + y4 * dx;
    } else {
      x5 = (d2 + a22 - b22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, a22 / d2 - x5 * x5));
      c5.x = a3.x + x5 * dx - y4 * dy;
      c5.y = a3.y + x5 * dy + y4 * dx;
    }
  } else {
    c5.x = a3.x + c5.r;
    c5.y = a3.y;
  }
}
function intersects(a3, b) {
  var dr = a3.r + b.r - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a3 = node._, b = node.next._, ab4 = a3.r + b.r, dx = (a3.x * b.r + b.x * a3.r) / ab4, dy = (a3.y * b.r + b.y * a3.r) / ab4;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array_default2(circles)).length))
    return 0;
  var a3, b, c5, n, aa2, ca3, i2, j, k2, sj, sk;
  a3 = circles[0], a3.x = 0, a3.y = 0;
  if (!(n > 1))
    return a3.r;
  b = circles[1], a3.x = -b.r, b.x = a3.r, b.y = 0;
  if (!(n > 2))
    return a3.r + b.r;
  place(b, a3, c5 = circles[2]);
  a3 = new Node2(a3), b = new Node2(b), c5 = new Node2(c5);
  a3.next = c5.previous = b;
  b.next = a3.previous = c5;
  c5.next = b.previous = a3;
  pack:
    for (i2 = 3; i2 < n; ++i2) {
      place(a3._, b._, c5 = circles[i2]), c5 = new Node2(c5);
      j = b.next, k2 = a3.previous, sj = b._.r, sk = a3._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c5._)) {
            b = j, a3.next = b, b.previous = a3, --i2;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k2._, c5._)) {
            a3 = k2, a3.next = b, b.previous = a3, --i2;
            continue pack;
          }
          sk += k2._.r, k2 = k2.previous;
        }
      } while (j !== k2.next);
      c5.previous = a3, c5.next = b, a3.next = b.previous = b = c5;
      aa2 = score(a3);
      while ((c5 = c5.next) !== b) {
        if ((ca3 = score(c5)) < aa2) {
          a3 = c5, aa2 = ca3;
        }
      }
      b = a3.next;
    }
  a3 = [b._], c5 = b;
  while ((c5 = c5.next) !== b)
    a3.push(c5._);
  c5 = enclose_default(a3);
  for (i2 = 0; i2 < n; ++i2)
    a3 = circles[i2], a3.x -= c5.x, a3.y -= c5.y;
  return c5.r;
}
function siblings_default(circles) {
  packEnclose(circles);
  return circles;
}
var init_siblings = __esm({
  "node_modules/d3-hierarchy/src/pack/siblings.js"() {
    init_shims();
    init_array6();
    init_enclose();
  }
});

// node_modules/d3-hierarchy/src/accessors.js
function optional(f3) {
  return f3 == null ? null : required(f3);
}
function required(f3) {
  if (typeof f3 !== "function")
    throw new Error();
  return f3;
}
var init_accessors = __esm({
  "node_modules/d3-hierarchy/src/accessors.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default9(x5) {
  return function() {
    return x5;
  };
}
var init_constant10 = __esm({
  "node_modules/d3-hierarchy/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius2(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root3) {
    root3.x = dx / 2, root3.y = dy / 2;
    if (radius) {
      root3.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root3.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root3.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));
    }
    return root3;
  }
  pack.radius = function(x5) {
    return arguments.length ? (radius = optional(x5), pack) : radius;
  };
  pack.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], pack) : [dx, dy];
  };
  pack.padding = function(x5) {
    return arguments.length ? (padding = typeof x5 === "function" ? x5 : constant_default9(+x5), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding, k2) {
  return function(node) {
    if (children2 = node.children) {
      var children2, i2, n = children2.length, r2 = padding(node) * k2 || 0, e3;
      if (r2)
        for (i2 = 0; i2 < n; ++i2)
          children2[i2].r += r2;
      e3 = packEnclose(children2);
      if (r2)
        for (i2 = 0; i2 < n; ++i2)
          children2[i2].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}
var init_pack = __esm({
  "node_modules/d3-hierarchy/src/pack/index.js"() {
    init_shims();
    init_siblings();
    init_accessors();
    init_constant10();
  }
});

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
var init_round2 = __esm({
  "node_modules/d3-hierarchy/src/treemap/round.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i2 = -1, n = nodes.length, k2 = parent.value && (x12 - x06) / parent.value;
  while (++i2 < n) {
    node = nodes[i2], node.y0 = y06, node.y1 = y12;
    node.x0 = x06, node.x1 = x06 += node.value * k2;
  }
}
var init_dice = __esm({
  "node_modules/d3-hierarchy/src/treemap/dice.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round = false;
  function partition(root3) {
    var n = root3.height + 1;
    root3.x0 = root3.y0 = padding;
    root3.x1 = dx;
    root3.y1 = dy / n;
    root3.eachBefore(positionNode(dy, n));
    if (round)
      root3.eachBefore(round_default2);
    return root3;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x06)
        x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06)
        y06 = y12 = (y06 + y12) / 2;
      node.x0 = x06;
      node.y0 = y06;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition.round = function(x5) {
    return arguments.length ? (round = !!x5, partition) : round;
  };
  partition.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], partition) : [dx, dy];
  };
  partition.padding = function(x5) {
    return arguments.length ? (padding = +x5, partition) : padding;
  };
  return partition;
}
var init_partition = __esm({
  "node_modules/d3-hierarchy/src/partition.js"() {
    init_shims();
    init_round2();
    init_dice();
  }
});

// node_modules/d3-hierarchy/src/stratify.js
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId, path2;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i2, root3, parent, node, nodeId, nodeKey, nodeByKey = new Map();
    if (path2 != null) {
      const I = nodes.map((d2, i3) => normalize2(path2(d2, i3, data)));
      const P = I.map(parentof);
      const S2 = new Set(I).add("");
      for (const i3 of P) {
        if (!S2.has(i3)) {
          S2.add(i3);
          I.push(i3);
          P.push(parentof(i3));
          nodes.push(imputed);
        }
      }
      currentId = (_, i3) => I[i3];
      currentParentId = (_, i3) => P[i3];
    }
    for (i2 = 0, n = nodes.length; i2 < n; ++i2) {
      d = nodes[i2], node = nodes[i2] = new Node(d);
      if ((nodeId = currentId(d, i2, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i2, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i2 = 0; i2 < n; ++i2) {
      node = nodes[i2];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root3)
          throw new Error("multiple roots");
        root3 = node;
      }
    }
    if (!root3)
      throw new Error("no root");
    if (path2 != null) {
      while (root3.data === imputed && root3.children.length === 1) {
        root3 = root3.children[0], --n;
      }
      for (let i3 = nodes.length - 1; i3 >= 0; --i3) {
        node = nodes[i3];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root3.parent = preroot;
    root3.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root3.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root3;
  }
  stratify.id = function(x5) {
    return arguments.length ? (id2 = optional(x5), stratify) : id2;
  };
  stratify.parentId = function(x5) {
    return arguments.length ? (parentId = optional(x5), stratify) : parentId;
  };
  stratify.path = function(x5) {
    return arguments.length ? (path2 = optional(x5), stratify) : path2;
  };
  return stratify;
}
function normalize2(path2) {
  path2 = `${path2}`;
  let i2 = path2.length;
  if (slash(path2, i2 - 1) && !slash(path2, i2 - 2))
    path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i2 = path2.length;
  if (i2 < 2)
    return "";
  while (--i2 > 1)
    if (slash(path2, i2))
      break;
  return path2.slice(0, i2);
}
function slash(path2, i2) {
  if (path2[i2] === "/") {
    let k2 = 0;
    while (i2 > 0 && path2[--i2] === "\\")
      ++k2;
    if ((k2 & 1) === 0)
      return true;
  }
  return false;
}
var preroot, ambiguous, imputed;
var init_stratify = __esm({
  "node_modules/d3-hierarchy/src/stratify.js"() {
    init_shims();
    init_accessors();
    init_hierarchy();
    preroot = { depth: -1 };
    ambiguous = {};
    imputed = {};
  }
});

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a3, b) {
  return a3.parent === b.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children2 = v2.children;
  return children2 ? children2[0] : v2.t;
}
function nextRight(v2) {
  var children2 = v2.children;
  return children2 ? children2[children2.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change = 0, children2 = v2.children, i2 = children2.length, w;
  while (--i2 >= 0) {
    w = children2[i2];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
function treeRoot(root3) {
  var tree = new TreeNode(root3, 0), node, nodes = [tree], child, children2, i2, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i2 = n - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new TreeNode(children2[i2], i2));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root3) {
    var t4 = treeRoot(root3);
    t4.eachAfter(firstWalk), t4.parent.m = -t4.z;
    t4.eachBefore(secondWalk);
    if (nodeSize)
      root3.eachBefore(sizeNode);
    else {
      var left2 = root3, right2 = root3, bottom2 = root3;
      root3.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom2.depth)
          bottom2 = node;
      });
      var s4 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s4 - left2.x, kx2 = dx / (right2.x + s4 + tx), ky2 = dy / (bottom2.depth || 1);
      root3.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root3;
  }
  function firstWalk(v2) {
    var children2 = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;
    if (children2) {
      executeShifts(v2);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v2.z = w.z + separation(v2._, w._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w) {
      v2.z = w.z + separation(v2._, w._);
    }
    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w, ancestor) {
    if (w) {
      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x5) {
    return arguments.length ? (separation = x5, tree) : separation;
  };
  tree.size = function(x5) {
    return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x5) {
    return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}
var init_tree = __esm({
  "node_modules/d3-hierarchy/src/tree.js"() {
    init_shims();
    init_hierarchy();
    TreeNode.prototype = Object.create(Node.prototype);
  }
});

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i2 = -1, n = nodes.length, k2 = parent.value && (y12 - y06) / parent.value;
  while (++i2 < n) {
    node = nodes[i2], node.x0 = x06, node.x1 = x12;
    node.y0 = y06, node.y1 = y06 += node.value * k2;
  }
}
var init_slice = __esm({
  "node_modules/d3-hierarchy/src/treemap/slice.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/treemap/squarify.js
function squarifyRatio(ratio, parent, x06, y06, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x06, dy = y12 - y06;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);
    else
      slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var phi, squarify_default;
var init_squarify = __esm({
  "node_modules/d3-hierarchy/src/treemap/squarify.js"() {
    init_shims();
    init_dice();
    init_slice();
    phi = (1 + Math.sqrt(5)) / 2;
    squarify_default = function custom10(ratio) {
      function squarify(parent, x06, y06, x12, y12) {
        squarifyRatio(ratio, parent, x06, y06, x12, y12);
      }
      squarify.ratio = function(x5) {
        return custom10((x5 = +x5) > 1 ? x5 : 1);
      };
      return squarify;
    }(phi);
  }
});

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root3) {
    root3.x0 = root3.y0 = 0;
    root3.x1 = dx;
    root3.y1 = dy;
    root3.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root3.eachBefore(round_default2);
    return root3;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
    if (x12 < x06)
      x06 = x12 = (x06 + x12) / 2;
    if (y12 < y06)
      y06 = y12 = (y06 + y12) / 2;
    node.x0 = x06;
    node.y0 = y06;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x06 += paddingLeft(node) - p;
      y06 += paddingTop(node) - p;
      x12 -= paddingRight(node) - p;
      y12 -= paddingBottom(node) - p;
      if (x12 < x06)
        x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06)
        y06 = y12 = (y06 + y12) / 2;
      tile(node, x06, y06, x12, y12);
    }
  }
  treemap.round = function(x5) {
    return arguments.length ? (round = !!x5, treemap) : round;
  };
  treemap.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x5) {
    return arguments.length ? (tile = required(x5), treemap) : tile;
  };
  treemap.padding = function(x5) {
    return arguments.length ? treemap.paddingInner(x5).paddingOuter(x5) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x5) {
    return arguments.length ? (paddingInner = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x5) {
    return arguments.length ? treemap.paddingTop(x5).paddingRight(x5).paddingBottom(x5).paddingLeft(x5) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x5) {
    return arguments.length ? (paddingTop = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x5) {
    return arguments.length ? (paddingRight = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x5) {
    return arguments.length ? (paddingBottom = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x5) {
    return arguments.length ? (paddingLeft = typeof x5 === "function" ? x5 : constant_default9(+x5), treemap) : paddingLeft;
  };
  return treemap;
}
var init_treemap = __esm({
  "node_modules/d3-hierarchy/src/treemap/index.js"() {
    init_shims();
    init_round2();
    init_squarify();
    init_accessors();
    init_constant10();
  }
});

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, i2, n = nodes.length, sum4, sums = new Array(n + 1);
  for (sums[0] = sum4 = i2 = 0; i2 < n; ++i2) {
    sums[i2 + 1] = sum4 += nodes[i2].value;
  }
  partition(0, n, parent.value, x06, y06, x12, y12);
  function partition(i3, j, value, x07, y07, x13, y13) {
    if (i3 >= j - 1) {
      var node = nodes[i3];
      node.x0 = x07, node.y0 = y07;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i3], valueTarget = value / 2 + valueOffset, k2 = i3 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid = k2 + hi >>> 1;
      if (sums[mid] < valueTarget)
        k2 = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i3 + 1 < k2)
      --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;
    if (x13 - x07 > y13 - y07) {
      var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;
      partition(i3, k2, valueLeft, x07, y07, xk, y13);
      partition(k2, j, valueRight, xk, y07, x13, y13);
    } else {
      var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;
      partition(i3, k2, valueLeft, x07, y07, x13, yk);
      partition(k2, j, valueRight, x07, yk, x13, y13);
    }
  }
}
var init_binary = __esm({
  "node_modules/d3-hierarchy/src/treemap/binary.js"() {
    init_shims();
  }
});

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x06, y06, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);
}
var init_sliceDice = __esm({
  "node_modules/d3-hierarchy/src/treemap/sliceDice.js"() {
    init_shims();
    init_dice();
    init_slice();
  }
});

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default;
var init_resquarify = __esm({
  "node_modules/d3-hierarchy/src/treemap/resquarify.js"() {
    init_shims();
    init_dice();
    init_slice();
    init_squarify();
    resquarify_default = function custom11(ratio) {
      function resquarify(parent, x06, y06, x12, y12) {
        if ((rows = parent._squarify) && rows.ratio === ratio) {
          var rows, row, nodes, i2, j = -1, n, m3 = rows.length, value = parent.value;
          while (++j < m3) {
            row = rows[j], nodes = row.children;
            for (i2 = row.value = 0, n = nodes.length; i2 < n; ++i2)
              row.value += nodes[i2].value;
            if (row.dice)
              dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);
            else
              slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);
          rows.ratio = ratio;
        }
      }
      resquarify.ratio = function(x5) {
        return custom11((x5 = +x5) > 1 ? x5 : 1);
      };
      return resquarify;
    }(phi);
  }
});

// node_modules/d3-hierarchy/src/index.js
var init_src23 = __esm({
  "node_modules/d3-hierarchy/src/index.js"() {
    init_shims();
    init_cluster();
    init_hierarchy();
    init_pack();
    init_siblings();
    init_enclose();
    init_partition();
    init_stratify();
    init_tree();
    init_treemap();
    init_binary();
    init_dice();
    init_slice();
    init_sliceDice();
    init_squarify();
    init_resquarify();
  }
});

// node_modules/d3-polygon/src/area.js
function area_default4(polygon) {
  var i2 = -1, n = polygon.length, a3, b = polygon[n - 1], area = 0;
  while (++i2 < n) {
    a3 = b;
    b = polygon[i2];
    area += a3[1] * b[0] - a3[0] * b[1];
  }
  return area / 2;
}
var init_area4 = __esm({
  "node_modules/d3-polygon/src/area.js"() {
    init_shims();
  }
});

// node_modules/d3-polygon/src/centroid.js
function centroid_default3(polygon) {
  var i2 = -1, n = polygon.length, x5 = 0, y4 = 0, a3, b = polygon[n - 1], c5, k2 = 0;
  while (++i2 < n) {
    a3 = b;
    b = polygon[i2];
    k2 += c5 = a3[0] * b[1] - b[0] * a3[1];
    x5 += (a3[0] + b[0]) * c5;
    y4 += (a3[1] + b[1]) * c5;
  }
  return k2 *= 3, [x5 / k2, y4 / k2];
}
var init_centroid3 = __esm({
  "node_modules/d3-polygon/src/centroid.js"() {
    init_shims();
  }
});

// node_modules/d3-polygon/src/cross.js
function cross_default(a3, b, c5) {
  return (b[0] - a3[0]) * (c5[1] - a3[1]) - (b[1] - a3[1]) * (c5[0] - a3[0]);
}
var init_cross2 = __esm({
  "node_modules/d3-polygon/src/cross.js"() {
    init_shims();
  }
});

// node_modules/d3-polygon/src/hull.js
function lexicographicOrder(a3, b) {
  return a3[0] - b[0] || a3[1] - b[1];
}
function computeUpperHullIndexes(points) {
  const n = points.length, indexes2 = [0, 1];
  let size = 2, i2;
  for (i2 = 2; i2 < n; ++i2) {
    while (size > 1 && cross_default(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i2]) <= 0)
      --size;
    indexes2[size++] = i2;
  }
  return indexes2.slice(0, size);
}
function hull_default(points) {
  if ((n = points.length) < 3)
    return null;
  var i2, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
  for (i2 = 0; i2 < n; ++i2)
    sortedPoints[i2] = [+points[i2][0], +points[i2][1], i2];
  sortedPoints.sort(lexicographicOrder);
  for (i2 = 0; i2 < n; ++i2)
    flippedPoints[i2] = [sortedPoints[i2][0], -sortedPoints[i2][1]];
  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
  for (i2 = upperIndexes.length - 1; i2 >= 0; --i2)
    hull.push(points[sortedPoints[upperIndexes[i2]][2]]);
  for (i2 = +skipLeft; i2 < lowerIndexes.length - skipRight; ++i2)
    hull.push(points[sortedPoints[lowerIndexes[i2]][2]]);
  return hull;
}
var init_hull = __esm({
  "node_modules/d3-polygon/src/hull.js"() {
    init_shims();
    init_cross2();
  }
});

// node_modules/d3-polygon/src/contains.js
function contains_default3(polygon, point6) {
  var n = polygon.length, p = polygon[n - 1], x5 = point6[0], y4 = point6[1], x06 = p[0], y06 = p[1], x12, y12, inside = false;
  for (var i2 = 0; i2 < n; ++i2) {
    p = polygon[i2], x12 = p[0], y12 = p[1];
    if (y12 > y4 !== y06 > y4 && x5 < (x06 - x12) * (y4 - y12) / (y06 - y12) + x12)
      inside = !inside;
    x06 = x12, y06 = y12;
  }
  return inside;
}
var init_contains3 = __esm({
  "node_modules/d3-polygon/src/contains.js"() {
    init_shims();
  }
});

// node_modules/d3-polygon/src/length.js
function length_default2(polygon) {
  var i2 = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
  while (++i2 < n) {
    xa = xb;
    ya = yb;
    b = polygon[i2];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.hypot(xa, ya);
  }
  return perimeter;
}
var init_length2 = __esm({
  "node_modules/d3-polygon/src/length.js"() {
    init_shims();
  }
});

// node_modules/d3-polygon/src/index.js
var init_src24 = __esm({
  "node_modules/d3-polygon/src/index.js"() {
    init_shims();
    init_area4();
    init_centroid3();
    init_hull();
    init_contains3();
    init_length2();
  }
});

// node_modules/d3-random/src/defaultSource.js
var defaultSource_default;
var init_defaultSource = __esm({
  "node_modules/d3-random/src/defaultSource.js"() {
    init_shims();
    defaultSource_default = Math.random;
  }
});

// node_modules/d3-random/src/uniform.js
var uniform_default;
var init_uniform = __esm({
  "node_modules/d3-random/src/uniform.js"() {
    init_shims();
    init_defaultSource();
    uniform_default = function sourceRandomUniform(source) {
      function randomUniform(min4, max5) {
        min4 = min4 == null ? 0 : +min4;
        max5 = max5 == null ? 1 : +max5;
        if (arguments.length === 1)
          max5 = min4, min4 = 0;
        else
          max5 -= min4;
        return function() {
          return source() * max5 + min4;
        };
      }
      randomUniform.source = sourceRandomUniform;
      return randomUniform;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/int.js
var int_default;
var init_int = __esm({
  "node_modules/d3-random/src/int.js"() {
    init_shims();
    init_defaultSource();
    int_default = function sourceRandomInt(source) {
      function randomInt(min4, max5) {
        if (arguments.length < 2)
          max5 = min4, min4 = 0;
        min4 = Math.floor(min4);
        max5 = Math.floor(max5) - min4;
        return function() {
          return Math.floor(source() * max5 + min4);
        };
      }
      randomInt.source = sourceRandomInt;
      return randomInt;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/normal.js
var normal_default;
var init_normal = __esm({
  "node_modules/d3-random/src/normal.js"() {
    init_shims();
    init_defaultSource();
    normal_default = function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x5, r2;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y4;
          if (x5 != null)
            y4 = x5, x5 = null;
          else
            do {
              x5 = source() * 2 - 1;
              y4 = source() * 2 - 1;
              r2 = x5 * x5 + y4 * y4;
            } while (!r2 || r2 > 1);
          return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r2) / r2);
        };
      }
      randomNormal.source = sourceRandomNormal;
      return randomNormal;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/logNormal.js
var logNormal_default;
var init_logNormal = __esm({
  "node_modules/d3-random/src/logNormal.js"() {
    init_shims();
    init_defaultSource();
    init_normal();
    logNormal_default = function sourceRandomLogNormal(source) {
      var N = normal_default.source(source);
      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }
      randomLogNormal.source = sourceRandomLogNormal;
      return randomLogNormal;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/irwinHall.js
var irwinHall_default;
var init_irwinHall = __esm({
  "node_modules/d3-random/src/irwinHall.js"() {
    init_shims();
    init_defaultSource();
    irwinHall_default = function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0)
          return () => 0;
        return function() {
          for (var sum4 = 0, i2 = n; i2 > 1; --i2)
            sum4 += source();
          return sum4 + i2 * source();
        };
      }
      randomIrwinHall.source = sourceRandomIrwinHall;
      return randomIrwinHall;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/bates.js
var bates_default;
var init_bates = __esm({
  "node_modules/d3-random/src/bates.js"() {
    init_shims();
    init_defaultSource();
    init_irwinHall();
    bates_default = function sourceRandomBates(source) {
      var I = irwinHall_default.source(source);
      function randomBates(n) {
        if ((n = +n) === 0)
          return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }
      randomBates.source = sourceRandomBates;
      return randomBates;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/exponential.js
var exponential_default;
var init_exponential = __esm({
  "node_modules/d3-random/src/exponential.js"() {
    init_shims();
    init_defaultSource();
    exponential_default = function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }
      randomExponential.source = sourceRandomExponential;
      return randomExponential;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/pareto.js
var pareto_default;
var init_pareto = __esm({
  "node_modules/d3-random/src/pareto.js"() {
    init_shims();
    init_defaultSource();
    pareto_default = function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0)
          throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }
      randomPareto.source = sourceRandomPareto;
      return randomPareto;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/bernoulli.js
var bernoulli_default;
var init_bernoulli = __esm({
  "node_modules/d3-random/src/bernoulli.js"() {
    init_shims();
    init_defaultSource();
    bernoulli_default = function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1)
          throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }
      randomBernoulli.source = sourceRandomBernoulli;
      return randomBernoulli;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/geometric.js
var geometric_default;
var init_geometric = __esm({
  "node_modules/d3-random/src/geometric.js"() {
    init_shims();
    init_defaultSource();
    geometric_default = function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1)
          throw new RangeError("invalid p");
        if (p === 0)
          return () => Infinity;
        if (p === 1)
          return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }
      randomGeometric.source = sourceRandomGeometric;
      return randomGeometric;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/gamma.js
var gamma_default;
var init_gamma = __esm({
  "node_modules/d3-random/src/gamma.js"() {
    init_shims();
    init_defaultSource();
    init_normal();
    gamma_default = function sourceRandomGamma(source) {
      var randomNormal = normal_default.source(source)();
      function randomGamma(k2, theta) {
        if ((k2 = +k2) < 0)
          throw new RangeError("invalid k");
        if (k2 === 0)
          return () => 0;
        theta = theta == null ? 1 : +theta;
        if (k2 === 1)
          return () => -Math.log1p(-source()) * theta;
        var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c5 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;
        return function() {
          do {
            do {
              var x5 = randomNormal(), v2 = 1 + c5 * x5;
            } while (v2 <= 0);
            v2 *= v2 * v2;
            var u4 = 1 - source();
          } while (u4 >= 1 - 0.0331 * x5 * x5 * x5 * x5 && Math.log(u4) >= 0.5 * x5 * x5 + d * (1 - v2 + Math.log(v2)));
          return d * v2 * multiplier() * theta;
        };
      }
      randomGamma.source = sourceRandomGamma;
      return randomGamma;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/beta.js
var beta_default;
var init_beta = __esm({
  "node_modules/d3-random/src/beta.js"() {
    init_shims();
    init_defaultSource();
    init_gamma();
    beta_default = function sourceRandomBeta(source) {
      var G = gamma_default.source(source);
      function randomBeta(alpha, beta) {
        var X3 = G(alpha), Y3 = G(beta);
        return function() {
          var x5 = X3();
          return x5 === 0 ? 0 : x5 / (x5 + Y3());
        };
      }
      randomBeta.source = sourceRandomBeta;
      return randomBeta;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/binomial.js
var binomial_default;
var init_binomial = __esm({
  "node_modules/d3-random/src/binomial.js"() {
    init_shims();
    init_defaultSource();
    init_beta();
    init_geometric();
    binomial_default = function sourceRandomBinomial(source) {
      var G = geometric_default.source(source), B3 = beta_default.source(source);
      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1)
          return () => n;
        if (p <= 0)
          return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i2 = Math.floor((nn + 1) * pp), y4 = B3(i2, nn - i2 + 1)();
            if (y4 <= pp) {
              acc += i2;
              nn -= i2;
              pp = (pp - y4) / (1 - y4);
            } else {
              nn = i2 - 1;
              pp /= y4;
            }
          }
          var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);
          for (var s4 = g(), k2 = 0; s4 <= nn; ++k2)
            s4 += g();
          return acc + (sign3 ? k2 : nn - k2);
        };
      }
      randomBinomial.source = sourceRandomBinomial;
      return randomBinomial;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/weibull.js
var weibull_default;
var init_weibull = __esm({
  "node_modules/d3-random/src/weibull.js"() {
    init_shims();
    init_defaultSource();
    weibull_default = function sourceRandomWeibull(source) {
      function randomWeibull(k2, a3, b) {
        var outerFunc;
        if ((k2 = +k2) === 0) {
          outerFunc = (x5) => -Math.log(x5);
        } else {
          k2 = 1 / k2;
          outerFunc = (x5) => Math.pow(x5, k2);
        }
        a3 = a3 == null ? 0 : +a3;
        b = b == null ? 1 : +b;
        return function() {
          return a3 + b * outerFunc(-Math.log1p(-source()));
        };
      }
      randomWeibull.source = sourceRandomWeibull;
      return randomWeibull;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/cauchy.js
var cauchy_default;
var init_cauchy = __esm({
  "node_modules/d3-random/src/cauchy.js"() {
    init_shims();
    init_defaultSource();
    cauchy_default = function sourceRandomCauchy(source) {
      function randomCauchy(a3, b) {
        a3 = a3 == null ? 0 : +a3;
        b = b == null ? 1 : +b;
        return function() {
          return a3 + b * Math.tan(Math.PI * source());
        };
      }
      randomCauchy.source = sourceRandomCauchy;
      return randomCauchy;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/logistic.js
var logistic_default;
var init_logistic = __esm({
  "node_modules/d3-random/src/logistic.js"() {
    init_shims();
    init_defaultSource();
    logistic_default = function sourceRandomLogistic(source) {
      function randomLogistic(a3, b) {
        a3 = a3 == null ? 0 : +a3;
        b = b == null ? 1 : +b;
        return function() {
          var u4 = source();
          return a3 + b * Math.log(u4 / (1 - u4));
        };
      }
      randomLogistic.source = sourceRandomLogistic;
      return randomLogistic;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/poisson.js
var poisson_default;
var init_poisson = __esm({
  "node_modules/d3-random/src/poisson.js"() {
    init_shims();
    init_defaultSource();
    init_binomial();
    init_gamma();
    poisson_default = function sourceRandomPoisson(source) {
      var G = gamma_default.source(source), B3 = binomial_default.source(source);
      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l), t4 = G(n)();
            if (t4 > l)
              return acc + B3(n - 1, l / t4)();
            acc += n;
            l -= t4;
          }
          for (var s4 = -Math.log1p(-source()), k2 = 0; s4 <= l; ++k2)
            s4 -= Math.log1p(-source());
          return acc + k2;
        };
      }
      randomPoisson.source = sourceRandomPoisson;
      return randomPoisson;
    }(defaultSource_default);
  }
});

// node_modules/d3-random/src/lcg.js
function lcg(seed = Math.random()) {
  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
  return () => (state = mul * state + inc | 0, eps * (state >>> 0));
}
var mul, inc, eps;
var init_lcg2 = __esm({
  "node_modules/d3-random/src/lcg.js"() {
    init_shims();
    mul = 1664525;
    inc = 1013904223;
    eps = 1 / 4294967296;
  }
});

// node_modules/d3-random/src/index.js
var init_src25 = __esm({
  "node_modules/d3-random/src/index.js"() {
    init_shims();
    init_uniform();
    init_int();
    init_normal();
    init_logNormal();
    init_bates();
    init_irwinHall();
    init_exponential();
    init_pareto();
    init_bernoulli();
    init_geometric();
    init_binomial();
    init_gamma();
    init_beta();
    init_weibull();
    init_cauchy();
    init_logistic();
    init_poisson();
    init_lcg2();
  }
});

// node_modules/d3-scale/src/init.js
function initRange(domain, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range4).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
var init_init = __esm({
  "node_modules/d3-scale/src/init.js"() {
    init_shims();
  }
});

// node_modules/d3-scale/src/ordinal.js
function ordinal() {
  var index3 = new InternMap(), domain = [], range4 = [], unknown = implicit;
  function scale2(d) {
    let i2 = index3.get(d);
    if (i2 === void 0) {
      if (unknown !== implicit)
        return unknown;
      index3.set(d, i2 = domain.push(d) - 1);
    }
    return range4[i2 % range4.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index3 = new InternMap();
    for (const value of _) {
      if (index3.has(value))
        continue;
      index3.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), scale2) : range4.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range4).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
var implicit;
var init_ordinal = __esm({
  "node_modules/d3-scale/src/ordinal.js"() {
    init_shims();
    init_src2();
    init_init();
    implicit = Symbol("implicit");
  }
});

// node_modules/d3-scale/src/band.js
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i2) {
      return start2 + step * i2;
    });
    return ordinalRange(reverse2 ? values.reverse() : values);
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale2.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale2.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale2) {
  var copy3 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  delete scale2.paddingOuter;
  scale2.copy = function() {
    return pointish(copy3());
  };
  return scale2;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
var init_band = __esm({
  "node_modules/d3-scale/src/band.js"() {
    init_shims();
    init_src2();
    init_init();
    init_ordinal();
  }
});

// node_modules/d3-scale/src/constant.js
function constants(x5) {
  return function() {
    return x5;
  };
}
var init_constant11 = __esm({
  "node_modules/d3-scale/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-scale/src/number.js
function number3(x5) {
  return +x5;
}
var init_number3 = __esm({
  "node_modules/d3-scale/src/number.js"() {
    init_shims();
  }
});

// node_modules/d3-scale/src/continuous.js
function identity3(x5) {
  return x5;
}
function normalize3(a3, b) {
  return (b -= a3 = +a3) ? function(x5) {
    return (x5 - a3) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a3, b) {
  var t4;
  if (a3 > b)
    t4 = a3, a3 = b, b = t4;
  return function(x5) {
    return Math.max(a3, Math.min(b, x5));
  };
}
function bimap(domain, range4, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range4[0], r1 = range4[1];
  if (d1 < d0)
    d0 = normalize3(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize3(d0, d1), r0 = interpolate(r0, r1);
  return function(x5) {
    return r0(d0(x5));
  };
}
function polymap(domain, range4, interpolate) {
  var j = Math.min(domain.length, range4.length) - 1, d = new Array(j), r2 = new Array(j), i2 = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range4 = range4.slice().reverse();
  }
  while (++i2 < j) {
    d[i2] = normalize3(domain[i2], domain[i2 + 1]);
    r2[i2] = interpolate(range4[i2], range4[i2 + 1]);
  }
  return function(x5) {
    var i3 = bisect_default(domain, x5, 1, j) - 1;
    return r2[i3](d[i3](x5));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range4 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range4.length);
    if (clamp !== identity3)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : (output || (output = piecewise2(domain.map(transform2), range4, interpolate)))(transform2(clamp(x5)));
  }
  scale2.invert = function(y4) {
    return clamp(untransform((input || (input = piecewise2(range4, domain.map(transform2), number_default)))(y4)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), rescale()) : range4.slice();
  };
  scale2.rangeRound = function(_) {
    return range4 = Array.from(_), interpolate = round_default, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t4, u4) {
    transform2 = t4, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity3, identity3);
}
var unit;
var init_continuous = __esm({
  "node_modules/d3-scale/src/continuous.js"() {
    init_shims();
    init_src2();
    init_src8();
    init_constant11();
    init_number3();
    unit = [0, 1];
  }
});

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count3, specifier) {
  var step = tickStep(start2, stop, count3), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format2(specifier);
}
var init_tickFormat = __esm({
  "node_modules/d3-scale/src/tickFormat.js"() {
    init_shims();
    init_src2();
    init_src21();
  }
});

// node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count3) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
  };
  scale2.tickFormat = function(count3, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
  };
  scale2.nice = function(count3) {
    if (count3 == null)
      count3 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count3);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear3() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear3());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
var init_linear2 = __esm({
  "node_modules/d3-scale/src/linear.js"() {
    init_shims();
    init_src2();
    init_continuous();
    init_init();
    init_tickFormat();
  }
});

// node_modules/d3-scale/src/identity.js
function identity4(domain) {
  var unknown;
  function scale2(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : x5;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number3), scale2) : domain.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return identity4(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number3) : [0, 1];
  return linearish(scale2);
}
var init_identity6 = __esm({
  "node_modules/d3-scale/src/identity.js"() {
    init_shims();
    init_linear2();
    init_number3();
  }
});

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t4;
  if (x12 < x06) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x06, x06 = x12, x12 = t4;
  }
  domain[i0] = interval2.floor(x06);
  domain[i1] = interval2.ceil(x12);
  return domain;
}
var init_nice2 = __esm({
  "node_modules/d3-scale/src/nice.js"() {
    init_shims();
  }
});

// node_modules/d3-scale/src/log.js
function transformLog(x5) {
  return Math.log(x5);
}
function transformExp(x5) {
  return Math.exp(x5);
}
function transformLogn(x5) {
  return -Math.log(-x5);
}
function transformExpn(x5) {
  return -Math.exp(-x5);
}
function pow10(x5) {
  return isFinite(x5) ? +("1e" + x5) : x5 < 0 ? 0 : x5;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : (x5) => Math.pow(base2, x5);
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), (x5) => Math.log(x5) / base2);
}
function reflect(f3) {
  return (x5, k2) => -f3(-x5, k2);
}
function loggish(transform2) {
  const scale2 = transform2(transformLog, transformExp);
  const domain = scale2.domain;
  let base2 = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_) {
    return arguments.length ? (base2 = +_, rescale()) : base2;
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.ticks = (count3) => {
    const d = domain();
    let u4 = d[0];
    let v2 = d[d.length - 1];
    const r2 = v2 < u4;
    if (r2)
      [u4, v2] = [v2, u4];
    let i2 = logs(u4);
    let j = logs(v2);
    let k2;
    let t4;
    const n = count3 == null ? 10 : +count3;
    let z = [];
    if (!(base2 % 1) && j - i2 < n) {
      i2 = Math.floor(i2), j = Math.ceil(j);
      if (u4 > 0)
        for (; i2 <= j; ++i2) {
          for (k2 = 1; k2 < base2; ++k2) {
            t4 = i2 < 0 ? k2 / pows(-i2) : k2 * pows(i2);
            if (t4 < u4)
              continue;
            if (t4 > v2)
              break;
            z.push(t4);
          }
        }
      else
        for (; i2 <= j; ++i2) {
          for (k2 = base2 - 1; k2 >= 1; --k2) {
            t4 = i2 > 0 ? k2 / pows(-i2) : k2 * pows(i2);
            if (t4 < u4)
              continue;
            if (t4 > v2)
              break;
            z.push(t4);
          }
        }
      if (z.length * 2 < n)
        z = ticks(u4, v2, n);
    } else {
      z = ticks(i2, j, Math.min(j - i2, n)).map(pows);
    }
    return r2 ? z.reverse() : z;
  };
  scale2.tickFormat = (count3, specifier) => {
    if (count3 == null)
      count3 = 10;
    if (specifier == null)
      specifier = base2 === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base2 % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format2(specifier);
    }
    if (count3 === Infinity)
      return specifier;
    const k2 = Math.max(1, base2 * count3 / scale2.ticks().length);
    return (d) => {
      let i2 = d / pows(Math.round(logs(d)));
      if (i2 * base2 < base2 - 0.5)
        i2 *= base2;
      return i2 <= k2 ? specifier(d) : "";
    };
  };
  scale2.nice = () => {
    return domain(nice2(domain(), {
      floor: (x5) => pows(Math.floor(logs(x5))),
      ceil: (x5) => pows(Math.ceil(logs(x5)))
    }));
  };
  return scale2;
}
function log2() {
  const scale2 = loggish(transformer2()).domain([1, 10]);
  scale2.copy = () => copy(scale2, log2()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}
var init_log = __esm({
  "node_modules/d3-scale/src/log.js"() {
    init_shims();
    init_src2();
    init_src21();
    init_nice2();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c5) {
  return function(x5) {
    return Math.sign(x5) * Math.log1p(Math.abs(x5 / c5));
  };
}
function transformSymexp(c5) {
  return function(x5) {
    return Math.sign(x5) * Math.expm1(Math.abs(x5)) * c5;
  };
}
function symlogish(transform2) {
  var c5 = 1, scale2 = transform2(transformSymlog(c5), transformSymexp(c5));
  scale2.constant = function(_) {
    return arguments.length ? transform2(transformSymlog(c5 = +_), transformSymexp(c5)) : c5;
  };
  return linearish(scale2);
}
function symlog() {
  var scale2 = symlogish(transformer2());
  scale2.copy = function() {
    return copy(scale2, symlog()).constant(scale2.constant());
  };
  return initRange.apply(scale2, arguments);
}
var init_symlog = __esm({
  "node_modules/d3-scale/src/symlog.js"() {
    init_shims();
    init_linear2();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/pow.js
function transformPow(exponent2) {
  return function(x5) {
    return x5 < 0 ? -Math.pow(-x5, exponent2) : Math.pow(x5, exponent2);
  };
}
function transformSqrt(x5) {
  return x5 < 0 ? -Math.sqrt(-x5) : Math.sqrt(x5);
}
function transformSquare(x5) {
  return x5 < 0 ? -x5 * x5 : x5 * x5;
}
function powish(transform2) {
  var scale2 = transform2(identity3, identity3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale2.exponent = function(_) {
    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
  };
  return linearish(scale2);
}
function pow3() {
  var scale2 = powish(transformer2());
  scale2.copy = function() {
    return copy(scale2, pow3()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt2() {
  return pow3.apply(null, arguments).exponent(0.5);
}
var init_pow = __esm({
  "node_modules/d3-scale/src/pow.js"() {
    init_shims();
    init_linear2();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/radial.js
function square(x5) {
  return Math.sign(x5) * x5 * x5;
}
function unsquare(x5) {
  return Math.sign(x5) * Math.sqrt(Math.abs(x5));
}
function radial() {
  var squared = continuous(), range4 = [0, 1], round = false, unknown;
  function scale2(x5) {
    var y4 = unsquare(squared(x5));
    return isNaN(y4) ? unknown : round ? Math.round(y4) : y4;
  }
  scale2.invert = function(y4) {
    return squared.invert(square(y4));
  };
  scale2.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale2) : squared.domain();
  };
  scale2.range = function(_) {
    return arguments.length ? (squared.range((range4 = Array.from(_, number3)).map(square)), scale2) : range4.slice();
  };
  scale2.rangeRound = function(_) {
    return scale2.range(_).round(true);
  };
  scale2.round = function(_) {
    return arguments.length ? (round = !!_, scale2) : round;
  };
  scale2.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale2) : squared.clamp();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return radial(squared.domain(), range4).round(round).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
var init_radial2 = __esm({
  "node_modules/d3-scale/src/radial.js"() {
    init_shims();
    init_continuous();
    init_init();
    init_linear2();
    init_number3();
  }
});

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range4 = [], thresholds = [], unknown;
  function rescale() {
    var i2 = 0, n = Math.max(1, range4.length);
    thresholds = new Array(n - 1);
    while (++i2 < n)
      thresholds[i2 - 1] = quantileSorted(domain, i2 / n);
    return scale2;
  }
  function scale2(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : range4[bisect_default(thresholds, x5)];
  }
  scale2.invertExtent = function(y4) {
    var i2 = range4.indexOf(y4);
    return i2 < 0 ? [NaN, NaN] : [
      i2 > 0 ? thresholds[i2 - 1] : domain[0],
      i2 < thresholds.length ? thresholds[i2] : domain[domain.length - 1]
    ];
  };
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale2.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), rescale()) : range4.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile2().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
var init_quantile2 = __esm({
  "node_modules/d3-scale/src/quantile.js"() {
    init_shims();
    init_src2();
    init_init();
  }
});

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x06 = 0, x12 = 1, n = 1, domain = [0.5], range4 = [0, 1], unknown;
  function scale2(x5) {
    return x5 != null && x5 <= x5 ? range4[bisect_default(domain, x5, 0, n)] : unknown;
  }
  function rescale() {
    var i2 = -1;
    domain = new Array(n);
    while (++i2 < n)
      domain[i2] = ((i2 + 1) * x12 - (i2 - n) * x06) / (n + 1);
    return scale2;
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
  };
  scale2.range = function(_) {
    return arguments.length ? (n = (range4 = Array.from(_)).length - 1, rescale()) : range4.slice();
  };
  scale2.invertExtent = function(y4) {
    var i2 = range4.indexOf(y4);
    return i2 < 0 ? [NaN, NaN] : i2 < 1 ? [x06, domain[0]] : i2 >= n ? [domain[n - 1], x12] : [domain[i2 - 1], domain[i2]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : scale2;
  };
  scale2.thresholds = function() {
    return domain.slice();
  };
  scale2.copy = function() {
    return quantize().domain([x06, x12]).range(range4).unknown(unknown);
  };
  return initRange.apply(linearish(scale2), arguments);
}
var init_quantize2 = __esm({
  "node_modules/d3-scale/src/quantize.js"() {
    init_shims();
    init_src2();
    init_linear2();
    init_init();
  }
});

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range4 = [0, 1], unknown, n = 1;
  function scale2(x5) {
    return x5 != null && x5 <= x5 ? range4[bisect_default(domain, x5, 0, n)] : unknown;
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range4.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), n = Math.min(domain.length, range4.length - 1), scale2) : range4.slice();
  };
  scale2.invertExtent = function(y4) {
    var i2 = range4.indexOf(y4);
    return [domain[i2 - 1], domain[i2]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
var init_threshold = __esm({
  "node_modules/d3-scale/src/threshold.js"() {
    init_shims();
    init_src2();
    init_init();
  }
});

// node_modules/d3-time/src/interval.js
function newInterval(floori, offseti, count3, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start2, stop, step) {
    var range4 = [], previous;
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range4;
    do
      range4.push(previous = new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range4;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count3) {
    interval2.count = function(start2, end) {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count3(t02, t12));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}
var t02, t12;
var init_interval2 = __esm({
  "node_modules/d3-time/src/interval.js"() {
    init_shims();
    t02 = new Date();
    t12 = new Date();
  }
});

// node_modules/d3-time/src/millisecond.js
var millisecond, millisecond_default, milliseconds;
var init_millisecond = __esm({
  "node_modules/d3-time/src/millisecond.js"() {
    init_shims();
    init_interval2();
    millisecond = newInterval(function() {
    }, function(date2, step) {
      date2.setTime(+date2 + step);
    }, function(start2, end) {
      return end - start2;
    });
    millisecond.every = function(k2) {
      k2 = Math.floor(k2);
      if (!isFinite(k2) || !(k2 > 0))
        return null;
      if (!(k2 > 1))
        return millisecond;
      return newInterval(function(date2) {
        date2.setTime(Math.floor(date2 / k2) * k2);
      }, function(date2, step) {
        date2.setTime(+date2 + step * k2);
      }, function(start2, end) {
        return (end - start2) / k2;
      });
    };
    millisecond_default = millisecond;
    milliseconds = millisecond.range;
  }
});

// node_modules/d3-time/src/duration.js
var durationSecond, durationMinute, durationHour, durationDay, durationWeek, durationMonth, durationYear;
var init_duration2 = __esm({
  "node_modules/d3-time/src/duration.js"() {
    init_shims();
    durationSecond = 1e3;
    durationMinute = durationSecond * 60;
    durationHour = durationMinute * 60;
    durationDay = durationHour * 24;
    durationWeek = durationDay * 7;
    durationMonth = durationDay * 30;
    durationYear = durationDay * 365;
  }
});

// node_modules/d3-time/src/second.js
var second, second_default, seconds;
var init_second = __esm({
  "node_modules/d3-time/src/second.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    second = newInterval(function(date2) {
      date2.setTime(date2 - date2.getMilliseconds());
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationSecond);
    }, function(start2, end) {
      return (end - start2) / durationSecond;
    }, function(date2) {
      return date2.getUTCSeconds();
    });
    second_default = second;
    seconds = second.range;
  }
});

// node_modules/d3-time/src/minute.js
var minute, minute_default, minutes;
var init_minute = __esm({
  "node_modules/d3-time/src/minute.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    minute = newInterval(function(date2) {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationMinute);
    }, function(start2, end) {
      return (end - start2) / durationMinute;
    }, function(date2) {
      return date2.getMinutes();
    });
    minute_default = minute;
    minutes = minute.range;
  }
});

// node_modules/d3-time/src/hour.js
var hour, hour_default, hours;
var init_hour = __esm({
  "node_modules/d3-time/src/hour.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    hour = newInterval(function(date2) {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationHour);
    }, function(start2, end) {
      return (end - start2) / durationHour;
    }, function(date2) {
      return date2.getHours();
    });
    hour_default = hour;
    hours = hour.range;
  }
});

// node_modules/d3-time/src/day.js
var day, day_default, days;
var init_day = __esm({
  "node_modules/d3-time/src/day.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    day = newInterval((date2) => date2.setHours(0, 0, 0, 0), (date2, step) => date2.setDate(date2.getDate() + step), (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay, (date2) => date2.getDate() - 1);
    day_default = day;
    days = day.range;
  }
});

// node_modules/d3-time/src/week.js
function weekday(i2) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i2) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start2, end) {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday, monday, tuesday, wednesday, thursday, friday, saturday, sundays, mondays, tuesdays, wednesdays, thursdays, fridays, saturdays;
var init_week = __esm({
  "node_modules/d3-time/src/week.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    sunday = weekday(0);
    monday = weekday(1);
    tuesday = weekday(2);
    wednesday = weekday(3);
    thursday = weekday(4);
    friday = weekday(5);
    saturday = weekday(6);
    sundays = sunday.range;
    mondays = monday.range;
    tuesdays = tuesday.range;
    wednesdays = wednesday.range;
    thursdays = thursday.range;
    fridays = friday.range;
    saturdays = saturday.range;
  }
});

// node_modules/d3-time/src/month.js
var month, month_default, months;
var init_month = __esm({
  "node_modules/d3-time/src/month.js"() {
    init_shims();
    init_interval2();
    month = newInterval(function(date2) {
      date2.setDate(1);
      date2.setHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setMonth(date2.getMonth() + step);
    }, function(start2, end) {
      return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
    }, function(date2) {
      return date2.getMonth();
    });
    month_default = month;
    months = month.range;
  }
});

// node_modules/d3-time/src/year.js
var year, year_default, years;
var init_year = __esm({
  "node_modules/d3-time/src/year.js"() {
    init_shims();
    init_interval2();
    year = newInterval(function(date2) {
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setFullYear(date2.getFullYear() + step);
    }, function(start2, end) {
      return end.getFullYear() - start2.getFullYear();
    }, function(date2) {
      return date2.getFullYear();
    });
    year.every = function(k2) {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
        date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
      }, function(date2, step) {
        date2.setFullYear(date2.getFullYear() + step * k2);
      });
    };
    year_default = year;
    years = year.range;
  }
});

// node_modules/d3-time/src/utcMinute.js
var utcMinute, utcMinute_default, utcMinutes;
var init_utcMinute = __esm({
  "node_modules/d3-time/src/utcMinute.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    utcMinute = newInterval(function(date2) {
      date2.setUTCSeconds(0, 0);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationMinute);
    }, function(start2, end) {
      return (end - start2) / durationMinute;
    }, function(date2) {
      return date2.getUTCMinutes();
    });
    utcMinute_default = utcMinute;
    utcMinutes = utcMinute.range;
  }
});

// node_modules/d3-time/src/utcHour.js
var utcHour, utcHour_default, utcHours;
var init_utcHour = __esm({
  "node_modules/d3-time/src/utcHour.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    utcHour = newInterval(function(date2) {
      date2.setUTCMinutes(0, 0, 0);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationHour);
    }, function(start2, end) {
      return (end - start2) / durationHour;
    }, function(date2) {
      return date2.getUTCHours();
    });
    utcHour_default = utcHour;
    utcHours = utcHour.range;
  }
});

// node_modules/d3-time/src/utcDay.js
var utcDay, utcDay_default, utcDays;
var init_utcDay = __esm({
  "node_modules/d3-time/src/utcDay.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    utcDay = newInterval(function(date2) {
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, function(start2, end) {
      return (end - start2) / durationDay;
    }, function(date2) {
      return date2.getUTCDate() - 1;
    });
    utcDay_default = utcDay;
    utcDays = utcDay.range;
  }
});

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i2) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i2) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start2, end) {
    return (end - start2) / durationWeek;
  });
}
var utcSunday, utcMonday, utcTuesday, utcWednesday, utcThursday, utcFriday, utcSaturday, utcSundays, utcMondays, utcTuesdays, utcWednesdays, utcThursdays, utcFridays, utcSaturdays;
var init_utcWeek = __esm({
  "node_modules/d3-time/src/utcWeek.js"() {
    init_shims();
    init_interval2();
    init_duration2();
    utcSunday = utcWeekday(0);
    utcMonday = utcWeekday(1);
    utcTuesday = utcWeekday(2);
    utcWednesday = utcWeekday(3);
    utcThursday = utcWeekday(4);
    utcFriday = utcWeekday(5);
    utcSaturday = utcWeekday(6);
    utcSundays = utcSunday.range;
    utcMondays = utcMonday.range;
    utcTuesdays = utcTuesday.range;
    utcWednesdays = utcWednesday.range;
    utcThursdays = utcThursday.range;
    utcFridays = utcFriday.range;
    utcSaturdays = utcSaturday.range;
  }
});

// node_modules/d3-time/src/utcMonth.js
var utcMonth, utcMonth_default, utcMonths;
var init_utcMonth = __esm({
  "node_modules/d3-time/src/utcMonth.js"() {
    init_shims();
    init_interval2();
    utcMonth = newInterval(function(date2) {
      date2.setUTCDate(1);
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCMonth(date2.getUTCMonth() + step);
    }, function(start2, end) {
      return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
    }, function(date2) {
      return date2.getUTCMonth();
    });
    utcMonth_default = utcMonth;
    utcMonths = utcMonth.range;
  }
});

// node_modules/d3-time/src/utcYear.js
var utcYear, utcYear_default, utcYears;
var init_utcYear = __esm({
  "node_modules/d3-time/src/utcYear.js"() {
    init_shims();
    init_interval2();
    utcYear = newInterval(function(date2) {
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCFullYear(date2.getUTCFullYear() + step);
    }, function(start2, end) {
      return end.getUTCFullYear() - start2.getUTCFullYear();
    }, function(date2) {
      return date2.getUTCFullYear();
    });
    utcYear.every = function(k2) {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
      }, function(date2, step) {
        date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
      });
    };
    utcYear_default = utcYear;
    utcYears = utcYear.range;
  }
});

// node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond],
    [second_default, 5, 5 * durationSecond],
    [second_default, 15, 15 * durationSecond],
    [second_default, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks2(start2, stop, count3) {
    const reverse2 = stop < start2;
    if (reverse2)
      [start2, stop] = [stop, start2];
    const interval2 = count3 && typeof count3.range === "function" ? count3 : tickInterval(start2, stop, count3);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count3) {
    const target = Math.abs(stop - start2) / count3;
    const i2 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i2 === tickIntervals.length)
      return year2.every(tickStep(start2 / durationYear, stop / durationYear, count3));
    if (i2 === 0)
      return millisecond_default.every(Math.max(tickStep(start2, stop, count3), 1));
    const [t4, step] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t4.every(step);
  }
  return [ticks2, tickInterval];
}
var utcTicks, utcTickInterval, timeTicks, timeTickInterval;
var init_ticks2 = __esm({
  "node_modules/d3-time/src/ticks.js"() {
    init_shims();
    init_src2();
    init_duration2();
    init_millisecond();
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    init_utcMinute();
    init_utcHour();
    init_utcDay();
    init_utcWeek();
    init_utcMonth();
    init_utcYear();
    [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
    [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);
  }
});

// node_modules/d3-time/src/index.js
var init_src26 = __esm({
  "node_modules/d3-time/src/index.js"() {
    init_shims();
    init_interval2();
    init_millisecond();
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    init_utcMinute();
    init_utcHour();
    init_utcDay();
    init_utcWeek();
    init_utcMonth();
    init_utcYear();
    init_ticks2();
  }
});

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y4, m3, d) {
  return { y: y4, m: m3, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i2 = -1, j = 0, n = specifier.length, c5, pad3, format3;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i2 < n) {
        if (specifier.charCodeAt(i2) === 37) {
          string.push(specifier.slice(j, i2));
          if ((pad3 = pads[c5 = specifier.charAt(++i2)]) != null)
            c5 = specifier.charAt(++i2);
          else
            pad3 = c5 === "e" ? " " : "0";
          if (format3 = formats2[c5])
            c5 = format3(date2, pad3);
          string.push(c5);
          j = i2 + 1;
        }
      }
      string.push(specifier.slice(j, i2));
      return string.join("");
    };
  }
  function newParse(specifier, Z3) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i2 = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i2 != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z3 && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i2 = 0, n = specifier.length, m3 = string.length, c5, parse;
    while (i2 < n) {
      if (j >= m3)
        return -1;
      c5 = specifier.charCodeAt(i2++);
      if (c5 === 37) {
        c5 = specifier.charAt(i2++);
        parse = parses[c5 in pads ? specifier.charAt(i2++) : c5];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c5 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i2) {
    var n = periodRe.exec(string.slice(i2));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i2) {
    var n = shortWeekdayRe.exec(string.slice(i2));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseWeekday(d, string, i2) {
    var n = weekdayRe.exec(string.slice(i2));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i2) {
    var n = shortMonthRe.exec(string.slice(i2));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseMonth(d, string, i2) {
    var n = monthRe.exec(string.slice(i2));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i2) {
    return parseSpecifier(d, locale_dateTime, string, i2);
  }
  function parseLocaleDate(d, string, i2) {
    return parseSpecifier(d, locale_date, string, i2);
  }
  function parseLocaleTime(d, string, i2) {
    return parseSpecifier(d, locale_time, string, i2);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f3 = newFormat(specifier += "", formats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f3 = newFormat(specifier += "", utcFormats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
function pad2(value, fill, width) {
  var sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length3 = string.length;
  return sign3 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string : string);
}
function requote(s4) {
  return s4.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i2) => [name.toLowerCase(), i2]));
}
function parseWeekdayNumberSunday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.w = +n[0], i2 + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.u = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.U = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.V = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.W = +n[0], i2 + n[0].length) : -1;
}
function parseFullYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 4));
  return n ? (d.y = +n[0], i2 + n[0].length) : -1;
}
function parseYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i2 + n[0].length) : -1;
}
function parseZone(d, string, i2) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i2, i2 + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i2 + n[0].length) : -1;
}
function parseQuarter(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.q = n[0] * 3 - 3, i2 + n[0].length) : -1;
}
function parseMonthNumber(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.m = n[0] - 1, i2 + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.d = +n[0], i2 + n[0].length) : -1;
}
function parseDayOfYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 3));
  return n ? (d.m = 0, d.d = +n[0], i2 + n[0].length) : -1;
}
function parseHour24(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.H = +n[0], i2 + n[0].length) : -1;
}
function parseMinutes(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.M = +n[0], i2 + n[0].length) : -1;
}
function parseSeconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.S = +n[0], i2 + n[0].length) : -1;
}
function parseMilliseconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 3));
  return n ? (d.L = +n[0], i2 + n[0].length) : -1;
}
function parseMicroseconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i2 + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i2) {
  var n = percentRe.exec(string.slice(i2, i2 + 1));
  return n ? i2 + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i2) {
  var n = numberRe.exec(string.slice(i2));
  return n ? (d.Q = +n[0], i2 + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2));
  return n ? (d.s = +n[0], i2 + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad2(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad2(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad2(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad2(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad2(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad2(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad2(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad2(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var pads, numberRe, percentRe, requoteRe;
var init_locale2 = __esm({
  "node_modules/d3-time-format/src/locale.js"() {
    init_shims();
    init_src26();
    pads = { "-": "", "_": " ", "0": "0" };
    numberRe = /^\s*\d+/;
    percentRe = /^%/;
    requoteRe = /[\\^$*+?|[\]().{}]/g;
  }
});

// node_modules/d3-time-format/src/defaultLocale.js
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}
var locale2, timeFormat, timeParse, utcFormat, utcParse;
var init_defaultLocale2 = __esm({
  "node_modules/d3-time-format/src/defaultLocale.js"() {
    init_shims();
    init_locale2();
    defaultLocale2({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
  }
});

// node_modules/d3-time-format/src/isoFormat.js
function formatIsoNative(date2) {
  return date2.toISOString();
}
var isoSpecifier, formatIso, isoFormat_default;
var init_isoFormat = __esm({
  "node_modules/d3-time-format/src/isoFormat.js"() {
    init_shims();
    init_defaultLocale2();
    isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
    formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
    isoFormat_default = formatIso;
  }
});

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso, isoParse_default;
var init_isoParse = __esm({
  "node_modules/d3-time-format/src/isoParse.js"() {
    init_shims();
    init_isoFormat();
    init_defaultLocale2();
    parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
    isoParse_default = parseIso;
  }
});

// node_modules/d3-time-format/src/index.js
var init_src27 = __esm({
  "node_modules/d3-time-format/src/index.js"() {
    init_shims();
    init_defaultLocale2();
    init_locale2();
    init_isoFormat();
    init_isoParse();
  }
});

// node_modules/d3-scale/src/time.js
function date(t4) {
  return new Date(t4);
}
function number4(t4) {
  return t4 instanceof Date ? +t4 : +new Date(+t4);
}
function calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format3) {
  var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth = format3("%B"), formatYear3 = format3("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale2.invert = function(y4) {
    return new Date(invert(y4));
  };
  scale2.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);
  };
  scale2.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale2.tickFormat = function(count3, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale2.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice2(d, interval2)) : scale2;
  };
  scale2.copy = function() {
    return copy(scale2, calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format3));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var init_time = __esm({
  "node_modules/d3-scale/src/time.js"() {
    init_shims();
    init_src26();
    init_src27();
    init_continuous();
    init_init();
    init_nice2();
  }
});

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default, second_default, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
var init_utcTime = __esm({
  "node_modules/d3-scale/src/utcTime.js"() {
    init_shims();
    init_src26();
    init_src27();
    init_time();
    init_init();
  }
});

// node_modules/d3-scale/src/sequential.js
function transformer3() {
  var x06 = 0, x12 = 1, t03, t13, k10, transform2, interpolator = identity3, clamp = false, unknown;
  function scale2(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : interpolator(k10 === 0 ? 0.5 : (x5 = (transform2(x5) - t03) * k10, clamp ? Math.max(0, Math.min(1, x5)) : x5));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale2) : [x06, x12];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale2) : clamp;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range4(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale2) : [interpolator(0), interpolator(1)];
    };
  }
  scale2.range = range4(value_default);
  scale2.rangeRound = range4(round_default);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t4) {
    transform2 = t4, t03 = t4(x06), t13 = t4(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale2;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale2 = linearish(transformer3()(identity3));
  scale2.copy = function() {
    return copy2(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialLog() {
  var scale2 = loggish(transformer3()).domain([1, 10]);
  scale2.copy = function() {
    return copy2(scale2, sequentialLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSymlog() {
  var scale2 = symlogish(transformer3());
  scale2.copy = function() {
    return copy2(scale2, sequentialSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialPow() {
  var scale2 = powish(transformer3());
  scale2.copy = function() {
    return copy2(scale2, sequentialPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
var init_sequential = __esm({
  "node_modules/d3-scale/src/sequential.js"() {
    init_shims();
    init_src8();
    init_continuous();
    init_init();
    init_linear2();
    init_log();
    init_symlog();
    init_pow();
  }
});

// node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
  var domain = [], interpolator = identity3;
  function scale2(x5) {
    if (x5 != null && !isNaN(x5 = +x5))
      return interpolator((bisect_default(domain, x5, 1) - 1) / (domain.length - 1));
  }
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending);
    return scale2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  scale2.range = function() {
    return domain.map((d, i2) => interpolator(i2 / (domain.length - 1)));
  };
  scale2.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_, i2) => quantile(domain, i2 / n));
  };
  scale2.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale2, arguments);
}
var init_sequentialQuantile = __esm({
  "node_modules/d3-scale/src/sequentialQuantile.js"() {
    init_shims();
    init_src2();
    init_continuous();
    init_init();
  }
});

// node_modules/d3-scale/src/diverging.js
function transformer4() {
  var x06 = 0, x12 = 0.5, x22 = 1, s4 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;
  function scale2(x5) {
    return isNaN(x5 = +x5) ? unknown : (x5 = 0.5 + ((x5 = +transform2(x5)) - t13) * (s4 * x5 < s4 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x5)) : x5));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x06, x12, x22] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s4 = t13 < t03 ? -1 : 1, scale2) : [x06, x12, x22];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale2) : clamp;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range4(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale2.range = range4(value_default);
  scale2.rangeRound = range4(round_default);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t4) {
    transform2 = t4, t03 = t4(x06), t13 = t4(x12), t22 = t4(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s4 = t13 < t03 ? -1 : 1;
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer4()(identity3));
  scale2.copy = function() {
    return copy2(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingLog() {
  var scale2 = loggish(transformer4()).domain([0.1, 1, 10]);
  scale2.copy = function() {
    return copy2(scale2, divergingLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSymlog() {
  var scale2 = symlogish(transformer4());
  scale2.copy = function() {
    return copy2(scale2, divergingSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingPow() {
  var scale2 = powish(transformer4());
  scale2.copy = function() {
    return copy2(scale2, divergingPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
var init_diverging = __esm({
  "node_modules/d3-scale/src/diverging.js"() {
    init_shims();
    init_src8();
    init_continuous();
    init_init();
    init_linear2();
    init_log();
    init_sequential();
    init_symlog();
    init_pow();
  }
});

// node_modules/d3-scale/src/index.js
var init_src28 = __esm({
  "node_modules/d3-scale/src/index.js"() {
    init_shims();
    init_band();
    init_identity6();
    init_linear2();
    init_log();
    init_symlog();
    init_ordinal();
    init_pow();
    init_radial2();
    init_quantile2();
    init_quantize2();
    init_threshold();
    init_time();
    init_utcTime();
    init_sequential();
    init_sequentialQuantile();
    init_diverging();
    init_tickFormat();
  }
});

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i2 = 0;
  while (i2 < n)
    colors[i2] = "#" + specifier.slice(i2 * 6, ++i2 * 6);
  return colors;
}
var init_colors = __esm({
  "node_modules/d3-scale-chromatic/src/colors.js"() {
    init_shims();
  }
});

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default;
var init_category10 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/category10.js"() {
    init_shims();
    init_colors();
    category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default;
var init_Accent = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Accent.js"() {
    init_shims();
    init_colors();
    Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default;
var init_Dark2 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Dark2.js"() {
    init_shims();
    init_colors();
    Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default;
var init_Paired = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Paired.js"() {
    init_shims();
    init_colors();
    Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default;
var init_Pastel1 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Pastel1.js"() {
    init_shims();
    init_colors();
    Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default;
var init_Pastel2 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Pastel2.js"() {
    init_shims();
    init_colors();
    Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default;
var init_Set1 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Set1.js"() {
    init_shims();
    init_colors();
    Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default;
var init_Set2 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Set2.js"() {
    init_shims();
    init_colors();
    Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default;
var init_Set3 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Set3.js"() {
    init_shims();
    init_colors();
    Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
  }
});

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default;
var init_Tableau10 = __esm({
  "node_modules/d3-scale-chromatic/src/categorical/Tableau10.js"() {
    init_shims();
    init_colors();
    Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
  }
});

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default;
var init_ramp = __esm({
  "node_modules/d3-scale-chromatic/src/ramp.js"() {
    init_shims();
    init_src8();
    ramp_default = (scheme29) => rgbBasis(scheme29[scheme29.length - 1]);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme2, BrBG_default;
var init_BrBG = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/BrBG.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme2 = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(colors_default);
    BrBG_default = ramp_default(scheme2);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme3, PRGn_default;
var init_PRGn = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/PRGn.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme3 = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(colors_default);
    PRGn_default = ramp_default(scheme3);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme4, PiYG_default;
var init_PiYG = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/PiYG.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme4 = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(colors_default);
    PiYG_default = ramp_default(scheme4);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme5, PuOr_default;
var init_PuOr = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/PuOr.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme5 = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(colors_default);
    PuOr_default = ramp_default(scheme5);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme6, RdBu_default;
var init_RdBu = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/RdBu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme6 = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(colors_default);
    RdBu_default = ramp_default(scheme6);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme7, RdGy_default;
var init_RdGy = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/RdGy.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme7 = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(colors_default);
    RdGy_default = ramp_default(scheme7);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme8, RdYlBu_default;
var init_RdYlBu = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme8 = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(colors_default);
    RdYlBu_default = ramp_default(scheme8);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme9, RdYlGn_default;
var init_RdYlGn = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme9 = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(colors_default);
    RdYlGn_default = ramp_default(scheme9);
  }
});

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme10, Spectral_default;
var init_Spectral = __esm({
  "node_modules/d3-scale-chromatic/src/diverging/Spectral.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme10 = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(colors_default);
    Spectral_default = ramp_default(scheme10);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme11, BuGn_default;
var init_BuGn = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme11 = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(colors_default);
    BuGn_default = ramp_default(scheme11);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme12, BuPu_default;
var init_BuPu = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme12 = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(colors_default);
    BuPu_default = ramp_default(scheme12);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme13, GnBu_default;
var init_GnBu = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme13 = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(colors_default);
    GnBu_default = ramp_default(scheme13);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme14, OrRd_default;
var init_OrRd = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme14 = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(colors_default);
    OrRd_default = ramp_default(scheme14);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme15, PuBuGn_default;
var init_PuBuGn = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme15 = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(colors_default);
    PuBuGn_default = ramp_default(scheme15);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme16, PuBu_default;
var init_PuBu = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme16 = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(colors_default);
    PuBu_default = ramp_default(scheme16);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme17, PuRd_default;
var init_PuRd = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme17 = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(colors_default);
    PuRd_default = ramp_default(scheme17);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme18, RdPu_default;
var init_RdPu = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme18 = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(colors_default);
    RdPu_default = ramp_default(scheme18);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme19, YlGnBu_default;
var init_YlGnBu = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme19 = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(colors_default);
    YlGnBu_default = ramp_default(scheme19);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme20, YlGn_default;
var init_YlGn = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme20 = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(colors_default);
    YlGn_default = ramp_default(scheme20);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme21, YlOrBr_default;
var init_YlOrBr = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme21 = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(colors_default);
    YlOrBr_default = ramp_default(scheme21);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme22, YlOrRd_default;
var init_YlOrRd = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme22 = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(colors_default);
    YlOrRd_default = ramp_default(scheme22);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme23, Blues_default;
var init_Blues = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-single/Blues.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme23 = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(colors_default);
    Blues_default = ramp_default(scheme23);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme24, Greens_default;
var init_Greens = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-single/Greens.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme24 = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(colors_default);
    Greens_default = ramp_default(scheme24);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme25, Greys_default;
var init_Greys = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-single/Greys.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme25 = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(colors_default);
    Greys_default = ramp_default(scheme25);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme26, Purples_default;
var init_Purples = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-single/Purples.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme26 = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(colors_default);
    Purples_default = ramp_default(scheme26);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme27, Reds_default;
var init_Reds = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-single/Reds.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme27 = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(colors_default);
    Reds_default = ramp_default(scheme27);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme28, Oranges_default;
var init_Oranges = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js"() {
    init_shims();
    init_colors();
    init_ramp();
    scheme28 = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(colors_default);
    Oranges_default = ramp_default(scheme28);
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t4 * (35.34 - t4 * (2381.73 - t4 * (6402.7 - t4 * (7024.72 - t4 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t4 * (170.73 + t4 * (52.82 - t4 * (131.46 - t4 * (176.58 - t4 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t4 * (442.36 - t4 * (2482.43 - t4 * (6167.24 - t4 * (6614.94 - t4 * 2475.67))))))) + ")";
}
var init_cividis = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js"() {
    init_shims();
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2;
var init_cubehelix3 = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js"() {
    init_shims();
    init_src7();
    init_src8();
    cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
function rainbow_default(t4) {
  if (t4 < 0 || t4 > 1)
    t4 -= Math.floor(t4);
  var ts = Math.abs(t4 - 0.5);
  c2.h = 360 * t4 - 100;
  c2.s = 1.5 - 1.5 * ts;
  c2.l = 0.8 - 0.9 * ts;
  return c2 + "";
}
var warm, cool, c2;
var init_rainbow = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js"() {
    init_shims();
    init_src7();
    init_src8();
    warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
    cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
    c2 = cubehelix();
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
function sinebow_default(t4) {
  var x5;
  t4 = (0.5 - t4) * Math.PI;
  c3.r = 255 * (x5 = Math.sin(t4)) * x5;
  c3.g = 255 * (x5 = Math.sin(t4 + pi_1_3)) * x5;
  c3.b = 255 * (x5 = Math.sin(t4 + pi_2_3)) * x5;
  return c3 + "";
}
var c3, pi_1_3, pi_2_3;
var init_sinebow = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js"() {
    init_shims();
    init_src7();
    c3 = rgb();
    pi_1_3 = Math.PI / 3;
    pi_2_3 = Math.PI * 2 / 3;
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t4 * (1172.33 - t4 * (10793.56 - t4 * (33300.12 - t4 * (38394.49 - t4 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t4 * (557.33 + t4 * (1225.33 - t4 * (3574.96 - t4 * (1073.77 + t4 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t4 * (3211.1 - t4 * (15327.97 - t4 * (27814 - t4 * (22569.18 - t4 * 6838.66))))))) + ")";
}
var init_turbo = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js"() {
    init_shims();
  }
});

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range4) {
  var n = range4.length;
  return function(t4) {
    return range4[Math.max(0, Math.min(n - 1, Math.floor(t4 * n)))];
  };
}
var viridis_default, magma, inferno, plasma;
var init_viridis = __esm({
  "node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js"() {
    init_shims();
    init_colors();
    viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
    magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
    inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
    plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
  }
});

// node_modules/d3-scale-chromatic/src/index.js
var init_src29 = __esm({
  "node_modules/d3-scale-chromatic/src/index.js"() {
    init_shims();
    init_category10();
    init_Accent();
    init_Dark2();
    init_Paired();
    init_Pastel1();
    init_Pastel2();
    init_Set1();
    init_Set2();
    init_Set3();
    init_Tableau10();
    init_BrBG();
    init_PRGn();
    init_PiYG();
    init_PuOr();
    init_RdBu();
    init_RdGy();
    init_RdYlBu();
    init_RdYlGn();
    init_Spectral();
    init_BuGn();
    init_BuPu();
    init_GnBu();
    init_OrRd();
    init_PuBuGn();
    init_PuBu();
    init_PuRd();
    init_RdPu();
    init_YlGnBu();
    init_YlGn();
    init_YlOrBr();
    init_YlOrRd();
    init_Blues();
    init_Greens();
    init_Greys();
    init_Purples();
    init_Reds();
    init_Oranges();
    init_cividis();
    init_cubehelix3();
    init_rainbow();
    init_sinebow();
    init_turbo();
    init_viridis();
  }
});

// node_modules/d3-shape/src/constant.js
function constant_default10(x5) {
  return function constant2() {
    return x5;
  };
}
var init_constant12 = __esm({
  "node_modules/d3-shape/src/constant.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/math.js
function acos2(x5) {
  return x5 > 1 ? 0 : x5 < -1 ? pi5 : Math.acos(x5);
}
function asin2(x5) {
  return x5 >= 1 ? halfPi4 : x5 <= -1 ? -halfPi4 : Math.asin(x5);
}
var abs4, atan22, cos3, max4, min3, sin3, sqrt3, epsilon8, pi5, halfPi4, tau6;
var init_math5 = __esm({
  "node_modules/d3-shape/src/math.js"() {
    init_shims();
    abs4 = Math.abs;
    atan22 = Math.atan2;
    cos3 = Math.cos;
    max4 = Math.max;
    min3 = Math.min;
    sin3 = Math.sin;
    sqrt3 = Math.sqrt;
    epsilon8 = 1e-12;
    pi5 = Math.PI;
    halfPi4 = pi5 / 2;
    tau6 = 2 * pi5;
  }
});

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t4 = y322 * x10 - x322 * y10;
  if (t4 * t4 < epsilon8)
    return;
  t4 = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t4;
  return [x06 + t4 * x10, y06 + t4 * y10];
}
function cornerTangents(x06, y06, x12, y12, r1, rc, cw) {
  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x06 + ox, y11 = y06 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r2 * r2 * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default10(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da2 = abs4(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path_default();
    if (r1 < r0)
      r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon8))
      context.moveTo(0, 0);
    else if (da2 > tau6 - epsilon8) {
      context.moveTo(r1 * cos3(a0), r1 * sin3(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon8) {
        context.moveTo(r0 * cos3(a1), r0 * sin3(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
      if (rp > epsilon8) {
        var p02 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));
        if ((da0 -= p02 * 2) > epsilon8)
          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon8)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);
      if (rc > epsilon8) {
        var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x004 = r0 * cos3(a00), y004 = r0 * sin3(a00), oc;
        if (da2 < pi5 && (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min3(rc, (r0 - lc) / (kc - 1));
          rc1 = min3(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon8))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon8) {
        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc1 < rc)
          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
          context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon8) || !(da0 > epsilon8))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon8) {
        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);
        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc0 < rc)
          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);
          context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;
    return [cos3(a3) * r2, sin3(a3) * r2];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default10(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default10(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}
var init_arc = __esm({
  "node_modules/d3-shape/src/arc.js"() {
    init_shims();
    init_src13();
    init_constant12();
    init_math5();
  }
});

// node_modules/d3-shape/src/array.js
function array_default3(x5) {
  return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
}
var slice4;
var init_array7 = __esm({
  "node_modules/d3-shape/src/array.js"() {
    init_shims();
    slice4 = Array.prototype.slice;
  }
});

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
function linear_default(context) {
  return new Linear(context);
}
var init_linear3 = __esm({
  "node_modules/d3-shape/src/curve/linear.js"() {
    init_shims();
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x5, y4);
            break;
        }
      }
    };
  }
});

// node_modules/d3-shape/src/point.js
function x4(p) {
  return p[0];
}
function y3(p) {
  return p[1];
}
var init_point = __esm({
  "node_modules/d3-shape/src/point.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/line.js
function line_default2(x5, y4) {
  var defined = constant_default10(true), context = null, curve = linear_default, output = null;
  x5 = typeof x5 === "function" ? x5 : x5 === void 0 ? x4 : constant_default10(x5);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y3 : constant_default10(y4);
  function line(data) {
    var i2, n = (data = array_default3(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path_default());
    for (i2 = 0; i2 <= n; ++i2) {
      if (!(i2 < n && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x5(d, i2, data), +y4(d, i2, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default10(+_), line) : x5;
  };
  line.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default10(+_), line) : y4;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default10(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}
var init_line2 = __esm({
  "node_modules/d3-shape/src/line.js"() {
    init_shims();
    init_src13();
    init_array7();
    init_constant12();
    init_linear3();
    init_point();
  }
});

// node_modules/d3-shape/src/area.js
function area_default5(x06, y06, y12) {
  var x12 = null, defined = constant_default10(true), context = null, curve = linear_default, output = null;
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x4 : constant_default10(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);
  function area(data) {
    var i2, j, k2, n = (data = array_default3(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path_default());
    for (i2 = 0; i2 <= n; ++i2) {
      if (!(i2 < n && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i2;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i2 - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i2] = +x06(d, i2, data), y0z[i2] = +y06(d, i2, data);
        output.point(x12 ? +x12(d, i2, data) : x0z[i2], y12 ? +y12(d, i2, data) : y0z[i2]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default2().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default10(+_), x12 = null, area) : x06;
  };
  area.x0 = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default10(+_), area) : x06;
  };
  area.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), area) : x12;
  };
  area.y = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default10(+_), y12 = null, area) : y06;
  };
  area.y0 = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default10(+_), area) : y06;
  };
  area.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default10(+_), area) : y12;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default10(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}
var init_area5 = __esm({
  "node_modules/d3-shape/src/area.js"() {
    init_shims();
    init_src13();
    init_array7();
    init_constant12();
    init_linear3();
    init_line2();
    init_point();
  }
});

// node_modules/d3-shape/src/descending.js
function descending_default(a3, b) {
  return b < a3 ? -1 : b > a3 ? 1 : b >= a3 ? 0 : NaN;
}
var init_descending2 = __esm({
  "node_modules/d3-shape/src/descending.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/identity.js
function identity_default5(d) {
  return d;
}
var init_identity7 = __esm({
  "node_modules/d3-shape/src/identity.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default5, sortValues = descending_default, sort2 = null, startAngle = constant_default10(0), endAngle = constant_default10(tau6), padAngle = constant_default10(0);
  function pie(data) {
    var i2, n = (data = array_default3(data)).length, j, k2, sum4 = 0, index3 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;
    for (i2 = 0; i2 < n; ++i2) {
      if ((v2 = arcs[index3[i2] = i2] = +value(data[i2], i2, data)) > 0) {
        sum4 += v2;
      }
    }
    if (sortValues != null)
      index3.sort(function(i3, j2) {
        return sortValues(arcs[i3], arcs[j2]);
      });
    else if (sort2 != null)
      index3.sort(function(i3, j2) {
        return sort2(data[i3], data[j2]);
      });
    for (i2 = 0, k2 = sum4 ? (da2 - n * pa) / sum4 : 0; i2 < n; ++i2, a0 = a1) {
      j = index3[i2], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i2,
        value: v2,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default10(+_), pie) : value;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort2 = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort2 = _, sortValues = null, pie) : sort2;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default10(+_), pie) : padAngle;
  };
  return pie;
}
var init_pie = __esm({
  "node_modules/d3-shape/src/pie.js"() {
    init_shims();
    init_array7();
    init_constant12();
    init_descending2();
    init_identity7();
    init_math5();
  }
});

// node_modules/d3-shape/src/curve/radial.js
function Radial(curve) {
  this._curve = curve;
}
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}
var curveRadialLinear;
var init_radial3 = __esm({
  "node_modules/d3-shape/src/curve/radial.js"() {
    init_shims();
    init_linear3();
    curveRadialLinear = curveRadial(linear_default);
    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a3, r2) {
        this._curve.point(r2 * Math.sin(a3), r2 * -Math.cos(a3));
      }
    };
  }
});

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c5 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c5(curveRadial(_)) : c5()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default2().curve(curveRadialLinear));
}
var init_lineRadial = __esm({
  "node_modules/d3-shape/src/lineRadial.js"() {
    init_shims();
    init_radial3();
    init_line2();
  }
});

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a3 = area_default5().curve(curveRadialLinear), c5 = a3.curve, x06 = a3.lineX0, x12 = a3.lineX1, y06 = a3.lineY0, y12 = a3.lineY1;
  a3.angle = a3.x, delete a3.x;
  a3.startAngle = a3.x0, delete a3.x0;
  a3.endAngle = a3.x1, delete a3.x1;
  a3.radius = a3.y, delete a3.y;
  a3.innerRadius = a3.y0, delete a3.y0;
  a3.outerRadius = a3.y1, delete a3.y1;
  a3.lineStartAngle = function() {
    return lineRadial(x06());
  }, delete a3.lineX0;
  a3.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a3.lineX1;
  a3.lineInnerRadius = function() {
    return lineRadial(y06());
  }, delete a3.lineY0;
  a3.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a3.lineY1;
  a3.curve = function(_) {
    return arguments.length ? c5(curveRadial(_)) : c5()._curve;
  };
  return a3;
}
var init_areaRadial = __esm({
  "node_modules/d3-shape/src/areaRadial.js"() {
    init_shims();
    init_radial3();
    init_area5();
    init_lineRadial();
  }
});

// node_modules/d3-shape/src/pointRadial.js
function pointRadial_default(x5, y4) {
  return [(y4 = +y4) * Math.cos(x5 -= Math.PI / 2), y4 * Math.sin(x5)];
}
var init_pointRadial = __esm({
  "node_modules/d3-shape/src/pointRadial.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/link/index.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link2(curve) {
  var source = linkSource, target = linkTarget, x5 = x4, y4 = y3, context = null;
  function link3() {
    var buffer, argv = slice4.call(arguments), s4 = source.apply(this, argv), t4 = target.apply(this, argv);
    if (!context)
      context = buffer = path_default();
    curve(context, +x5.apply(this, (argv[0] = s4, argv)), +y4.apply(this, argv), +x5.apply(this, (argv[0] = t4, argv)), +y4.apply(this, argv));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  link3.source = function(_) {
    return arguments.length ? (source = _, link3) : source;
  };
  link3.target = function(_) {
    return arguments.length ? (target = _, link3) : target;
  };
  link3.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default10(+_), link3) : x5;
  };
  link3.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default10(+_), link3) : y4;
  };
  link3.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, link3) : context;
  };
  return link3;
}
function curveHorizontal(context, x06, y06, x12, y12) {
  context.moveTo(x06, y06);
  context.bezierCurveTo(x06 = (x06 + x12) / 2, y06, x06, y12, x12, y12);
}
function curveVertical(context, x06, y06, x12, y12) {
  context.moveTo(x06, y06);
  context.bezierCurveTo(x06, y06 = (y06 + y12) / 2, x12, y06, x12, y12);
}
function curveRadial2(context, x06, y06, x12, y12) {
  var p02 = pointRadial_default(x06, y06), p1 = pointRadial_default(x06, y06 = (y06 + y12) / 2), p2 = pointRadial_default(x12, y06), p3 = pointRadial_default(x12, y12);
  context.moveTo(p02[0], p02[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
function linkHorizontal() {
  return link2(curveHorizontal);
}
function linkVertical() {
  return link2(curveVertical);
}
function linkRadial() {
  var l = link2(curveRadial2);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}
var init_link2 = __esm({
  "node_modules/d3-shape/src/link/index.js"() {
    init_shims();
    init_src13();
    init_array7();
    init_constant12();
    init_point();
    init_pointRadial();
  }
});

// node_modules/d3-shape/src/symbol/circle.js
var circle_default3;
var init_circle4 = __esm({
  "node_modules/d3-shape/src/symbol/circle.js"() {
    init_shims();
    init_math5();
    circle_default3 = {
      draw: function(context, size) {
        var r2 = Math.sqrt(size / pi5);
        context.moveTo(r2, 0);
        context.arc(0, 0, r2, 0, tau6);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/cross.js
var cross_default2;
var init_cross3 = __esm({
  "node_modules/d3-shape/src/symbol/cross.js"() {
    init_shims();
    cross_default2 = {
      draw: function(context, size) {
        var r2 = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r2, -r2);
        context.lineTo(-r2, -r2);
        context.lineTo(-r2, -3 * r2);
        context.lineTo(r2, -3 * r2);
        context.lineTo(r2, -r2);
        context.lineTo(3 * r2, -r2);
        context.lineTo(3 * r2, r2);
        context.lineTo(r2, r2);
        context.lineTo(r2, 3 * r2);
        context.lineTo(-r2, 3 * r2);
        context.lineTo(-r2, r2);
        context.lineTo(-3 * r2, r2);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/diamond.js
var tan30, tan30_2, diamond_default;
var init_diamond = __esm({
  "node_modules/d3-shape/src/symbol/diamond.js"() {
    init_shims();
    tan30 = Math.sqrt(1 / 3);
    tan30_2 = tan30 * 2;
    diamond_default = {
      draw: function(context, size) {
        var y4 = Math.sqrt(size / tan30_2), x5 = y4 * tan30;
        context.moveTo(0, -y4);
        context.lineTo(x5, 0);
        context.lineTo(0, y4);
        context.lineTo(-x5, 0);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/star.js
var ka, kr, kx, ky, star_default;
var init_star = __esm({
  "node_modules/d3-shape/src/symbol/star.js"() {
    init_shims();
    init_math5();
    ka = 0.8908130915292852;
    kr = Math.sin(pi5 / 10) / Math.sin(7 * pi5 / 10);
    kx = Math.sin(tau6 / 10) * kr;
    ky = -Math.cos(tau6 / 10) * kr;
    star_default = {
      draw: function(context, size) {
        var r2 = Math.sqrt(size * ka), x5 = kx * r2, y4 = ky * r2;
        context.moveTo(0, -r2);
        context.lineTo(x5, y4);
        for (var i2 = 1; i2 < 5; ++i2) {
          var a3 = tau6 * i2 / 5, c5 = Math.cos(a3), s4 = Math.sin(a3);
          context.lineTo(s4 * r2, -c5 * r2);
          context.lineTo(c5 * x5 - s4 * y4, s4 * x5 + c5 * y4);
        }
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/square.js
var square_default;
var init_square = __esm({
  "node_modules/d3-shape/src/symbol/square.js"() {
    init_shims();
    square_default = {
      draw: function(context, size) {
        var w = Math.sqrt(size), x5 = -w / 2;
        context.rect(x5, x5, w, w);
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32, triangle_default;
var init_triangle = __esm({
  "node_modules/d3-shape/src/symbol/triangle.js"() {
    init_shims();
    sqrt32 = Math.sqrt(3);
    triangle_default = {
      draw: function(context, size) {
        var y4 = -Math.sqrt(size / (sqrt32 * 3));
        context.moveTo(0, y4 * 2);
        context.lineTo(-sqrt32 * y4, -y4);
        context.lineTo(sqrt32 * y4, -y4);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol/wye.js
var c4, s3, k, a2, wye_default;
var init_wye = __esm({
  "node_modules/d3-shape/src/symbol/wye.js"() {
    init_shims();
    c4 = -0.5;
    s3 = Math.sqrt(3) / 2;
    k = 1 / Math.sqrt(12);
    a2 = (k / 2 + 1) * 3;
    wye_default = {
      draw: function(context, size) {
        var r2 = Math.sqrt(size / a2), x06 = r2 / 2, y06 = r2 * k, x12 = x06, y12 = r2 * k + r2, x22 = -x12, y22 = y12;
        context.moveTo(x06, y06);
        context.lineTo(x12, y12);
        context.lineTo(x22, y22);
        context.lineTo(c4 * x06 - s3 * y06, s3 * x06 + c4 * y06);
        context.lineTo(c4 * x12 - s3 * y12, s3 * x12 + c4 * y12);
        context.lineTo(c4 * x22 - s3 * y22, s3 * x22 + c4 * y22);
        context.lineTo(c4 * x06 + s3 * y06, c4 * y06 - s3 * x06);
        context.lineTo(c4 * x12 + s3 * y12, c4 * y12 - s3 * x12);
        context.lineTo(c4 * x22 + s3 * y22, c4 * y22 - s3 * x22);
        context.closePath();
      }
    };
  }
});

// node_modules/d3-shape/src/symbol.js
function symbol_default(type2, size) {
  var context = null;
  type2 = typeof type2 === "function" ? type2 : constant_default10(type2 || circle_default3);
  size = typeof size === "function" ? size : constant_default10(size === void 0 ? 64 : +size);
  function symbol() {
    var buffer;
    if (!context)
      context = buffer = path_default();
    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type2 = typeof _ === "function" ? _ : constant_default10(_), symbol) : type2;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default10(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}
var symbols;
var init_symbol = __esm({
  "node_modules/d3-shape/src/symbol.js"() {
    init_shims();
    init_src13();
    init_circle4();
    init_cross3();
    init_diamond();
    init_star();
    init_square();
    init_triangle();
    init_wye();
    init_constant12();
    symbols = [
      circle_default3,
      cross_default2,
      diamond_default,
      square_default,
      star_default,
      triangle_default,
      wye_default
    ];
  }
});

// node_modules/d3-shape/src/noop.js
function noop_default2() {
}
var init_noop3 = __esm({
  "node_modules/d3-shape/src/noop.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x5, y4) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x5) / 6, (that._y0 + 4 * that._y1 + y4) / 6);
}
function Basis(context) {
  this._context = context;
}
function basis_default2(context) {
  return new Basis(context);
}
var init_basis2 = __esm({
  "node_modules/d3-shape/src/curve/basis.js"() {
    init_shims();
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point2(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point2(this, x5, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = x5;
        this._y0 = this._y1, this._y1 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
function basisClosed_default2(context) {
  return new BasisClosed(context);
}
var init_basisClosed2 = __esm({
  "node_modules/d3-shape/src/curve/basisClosed.js"() {
    init_shims();
    init_noop3();
    init_basis2();
    BasisClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x5, this._y2 = y4;
            break;
          case 1:
            this._point = 2;
            this._x3 = x5, this._y3 = y4;
            break;
          case 2:
            this._point = 3;
            this._x4 = x5, this._y4 = y4;
            this._context.moveTo((this._x0 + 4 * this._x1 + x5) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
            break;
          default:
            point2(this, x5, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = x5;
        this._y0 = this._y1, this._y1 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
function basisOpen_default(context) {
  return new BasisOpen(context);
}
var init_basisOpen = __esm({
  "node_modules/d3-shape/src/curve/basisOpen.js"() {
    init_shims();
    init_basis2();
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x06 = (this._x0 + 4 * this._x1 + x5) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;
            this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
            break;
          case 3:
            this._point = 4;
          default:
            point2(this, x5, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = x5;
        this._y0 = this._y1, this._y1 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/bump.js
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}
var Bump;
var init_bump = __esm({
  "node_modules/d3-shape/src/curve/bump.js"() {
    init_shims();
    Bump = class {
      constructor(context, x5) {
        this._context = context;
        this._x = x5;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line)
              this._context.lineTo(x5, y4);
            else
              this._context.moveTo(x5, y4);
            break;
          }
          case 1:
            this._point = 2;
          default: {
            if (this._x)
              this._context.bezierCurveTo(this._x0 = (this._x0 + x5) / 2, this._y0, this._x0, y4, x5, y4);
            else
              this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x5, this._y0, x5, y4);
            break;
          }
        }
        this._x0 = x5, this._y0 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
var bundle_default;
var init_bundle = __esm({
  "node_modules/d3-shape/src/curve/bundle.js"() {
    init_shims();
    init_basis2();
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x5 = this._x, y4 = this._y, j = x5.length - 1;
        if (j > 0) {
          var x06 = x5[0], y06 = y4[0], dx = x5[j] - x06, dy = y4[j] - y06, i2 = -1, t4;
          while (++i2 <= j) {
            t4 = i2 / j;
            this._basis.point(this._beta * x5[i2] + (1 - this._beta) * (x06 + t4 * dx), this._beta * y4[i2] + (1 - this._beta) * (y06 + t4 * dy));
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x5, y4) {
        this._x.push(+x5);
        this._y.push(+y4);
      }
    };
    bundle_default = function custom12(beta) {
      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }
      bundle.beta = function(beta2) {
        return custom12(+beta2);
      };
      return bundle;
    }(0.85);
  }
});

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x5, y4) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x5), that._y2 + that._k * (that._y1 - y4), that._x2, that._y2);
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinal_default;
var init_cardinal = __esm({
  "node_modules/d3-shape/src/curve/cardinal.js"() {
    init_shims();
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point3(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
            break;
          case 1:
            this._point = 2;
            this._x1 = x5, this._y1 = y4;
            break;
          case 2:
            this._point = 3;
          default:
            point3(this, x5, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    cardinal_default = function custom13(tension) {
      function cardinal(context) {
        return new Cardinal(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom13(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalClosed_default;
var init_cardinalClosed = __esm({
  "node_modules/d3-shape/src/curve/cardinalClosed.js"() {
    init_shims();
    init_noop3();
    init_cardinal();
    CardinalClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x5, this._y3 = y4;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x5, this._y4 = y4);
            break;
          case 2:
            this._point = 3;
            this._x5 = x5, this._y5 = y4;
            break;
          default:
            point3(this, x5, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    cardinalClosed_default = function custom14(tension) {
      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom14(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalOpen_default;
var init_cardinalOpen = __esm({
  "node_modules/d3-shape/src/curve/cardinalOpen.js"() {
    init_shims();
    init_cardinal();
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point3(this, x5, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    cardinalOpen_default = function custom15(tension) {
      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom15(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x5, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon8) {
    var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon8) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x5 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRom_default;
var init_catmullRom = __esm({
  "node_modules/d3-shape/src/curve/catmullRom.js"() {
    init_shims();
    init_math5();
    init_cardinal();
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        if (this._point) {
          var x23 = this._x2 - x5, y23 = this._y2 - y4;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point4(this, x5, y4);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    catmullRom_default = function custom16(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom16(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomClosed_default;
var init_catmullRomClosed = __esm({
  "node_modules/d3-shape/src/curve/catmullRomClosed.js"() {
    init_shims();
    init_cardinalClosed();
    init_noop3();
    init_catmullRom();
    CatmullRomClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        if (this._point) {
          var x23 = this._x2 - x5, y23 = this._y2 - y4;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x5, this._y3 = y4;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x5, this._y4 = y4);
            break;
          case 2:
            this._point = 3;
            this._x5 = x5, this._y5 = y4;
            break;
          default:
            point4(this, x5, y4);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    catmullRomClosed_default = function custom17(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom17(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomOpen_default;
var init_catmullRomOpen = __esm({
  "node_modules/d3-shape/src/curve/catmullRomOpen.js"() {
    init_shims();
    init_cardinalOpen();
    init_catmullRom();
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        if (this._point) {
          var x23 = this._x2 - x5, y23 = this._y2 - y4;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point4(this, x5, y4);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    catmullRomOpen_default = function custom18(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom18(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
function linearClosed_default(context) {
  return new LinearClosed(context);
}
var init_linearClosed = __esm({
  "node_modules/d3-shape/src/curve/linearClosed.js"() {
    init_shims();
    init_noop3();
    LinearClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        if (this._point)
          this._context.lineTo(x5, y4);
        else
          this._point = 1, this._context.moveTo(x5, y4);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/monotone.js
function sign2(x5) {
  return x5 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t4) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t4) / 2 : t4;
}
function point5(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
function ReflectContext(context) {
  this._context = context;
}
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
var init_monotone = __esm({
  "node_modules/d3-shape/src/curve/monotone.js"() {
    init_shims();
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point5(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        var t13 = NaN;
        x5 = +x5, y4 = +y4;
        if (x5 === this._x1 && y4 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point5(this, slope2(this, t13 = slope3(this, x5, y4)), t13);
            break;
          default:
            point5(this, this._t0, t13 = slope3(this, x5, y4));
            break;
        }
        this._x0 = this._x1, this._x1 = x5;
        this._y0 = this._y1, this._y1 = y4;
        this._t0 = t13;
      }
    };
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x5, y4) {
      MonotoneX.prototype.point.call(this, y4, x5);
    };
    ReflectContext.prototype = {
      moveTo: function(x5, y4) {
        this._context.moveTo(y4, x5);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x5, y4) {
        this._context.lineTo(y4, x5);
      },
      bezierCurveTo: function(x12, y12, x22, y22, x5, y4) {
        this._context.bezierCurveTo(y12, x12, y22, x22, y4, x5);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
function controlPoints(x5) {
  var i2, n = x5.length - 1, m3, a3 = new Array(n), b = new Array(n), r2 = new Array(n);
  a3[0] = 0, b[0] = 2, r2[0] = x5[0] + 2 * x5[1];
  for (i2 = 1; i2 < n - 1; ++i2)
    a3[i2] = 1, b[i2] = 4, r2[i2] = 4 * x5[i2] + 2 * x5[i2 + 1];
  a3[n - 1] = 2, b[n - 1] = 7, r2[n - 1] = 8 * x5[n - 1] + x5[n];
  for (i2 = 1; i2 < n; ++i2)
    m3 = a3[i2] / b[i2 - 1], b[i2] -= m3, r2[i2] -= m3 * r2[i2 - 1];
  a3[n - 1] = r2[n - 1] / b[n - 1];
  for (i2 = n - 2; i2 >= 0; --i2)
    a3[i2] = (r2[i2] - a3[i2 + 1]) / b[i2];
  b[n - 1] = (x5[n] + a3[n - 1]) / 2;
  for (i2 = 0; i2 < n - 1; ++i2)
    b[i2] = 2 * x5[i2 + 1] - a3[i2 + 1];
  return [a3, b];
}
function natural_default(context) {
  return new Natural(context);
}
var init_natural = __esm({
  "node_modules/d3-shape/src/curve/natural.js"() {
    init_shims();
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x5 = this._x, y4 = this._y, n = x5.length;
        if (n) {
          this._line ? this._context.lineTo(x5[0], y4[0]) : this._context.moveTo(x5[0], y4[0]);
          if (n === 2) {
            this._context.lineTo(x5[1], y4[1]);
          } else {
            var px = controlPoints(x5), py = controlPoints(y4);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x5[i1], y4[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x5, y4) {
        this._x.push(+x5);
        this._y.push(+y4);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/step.js
function Step(context, t4) {
  this._context = context;
  this._t = t4;
}
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
var init_step = __esm({
  "node_modules/d3-shape/src/curve/step.js"() {
    init_shims();
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x5, y4) {
        x5 = +x5, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y4);
              this._context.lineTo(x5, y4);
            } else {
              var x12 = this._x * (1 - this._t) + x5 * this._t;
              this._context.lineTo(x12, this._y);
              this._context.lineTo(x12, y4);
            }
            break;
          }
        }
        this._x = x5, this._y = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1))
    return;
  for (var i2 = 1, j, s0, s1 = series[order[0]], n, m3 = s1.length; i2 < n; ++i2) {
    s0 = s1, s1 = series[order[i2]];
    for (j = 0; j < m3; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
var init_none = __esm({
  "node_modules/d3-shape/src/offset/none.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
var init_none2 = __esm({
  "node_modules/d3-shape/src/order/none.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  var keys = constant_default10([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i2, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i2 = 0, ++j; i2 < n; ++i2) {
        (sz[i2][j] = [0, +value(d, sz[i2].key, j, data)]).data = d;
      }
    }
    for (i2 = 0, oz = array_default3(order(sz)); i2 < n; ++i2) {
      sz[oz[i2]].index = i2;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default10(Array.from(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default10(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default10(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}
var init_stack = __esm({
  "node_modules/d3-shape/src/stack.js"() {
    init_shims();
    init_array7();
    init_constant12();
    init_none();
    init_none2();
  }
});

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var i2, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {
    for (y4 = i2 = 0; i2 < n; ++i2)
      y4 += series[i2][j][1] || 0;
    if (y4)
      for (i2 = 0; i2 < n; ++i2)
        series[i2][j][1] /= y4;
  }
  none_default(series, order);
}
var init_expand = __esm({
  "node_modules/d3-shape/src/offset/expand.js"() {
    init_shims();
    init_none();
  }
});

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var i2, j = 0, d, dy, yp, yn, n, m3 = series[order[0]].length; j < m3; ++j) {
    for (yp = yn = 0, i2 = 0; i2 < n; ++i2) {
      if ((dy = (d = series[order[i2]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
var init_diverging2 = __esm({
  "node_modules/d3-shape/src/offset/diverging.js"() {
    init_shims();
  }
});

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var j = 0, s0 = series[order[0]], n, m3 = s0.length; j < m3; ++j) {
    for (var i2 = 0, y4 = 0; i2 < n; ++i2)
      y4 += series[i2][j][1] || 0;
    s0[j][1] += s0[j][0] = -y4 / 2;
  }
  none_default(series, order);
}
var init_silhouette = __esm({
  "node_modules/d3-shape/src/offset/silhouette.js"() {
    init_shims();
    init_none();
  }
});

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
  if (!((n = series.length) > 0) || !((m3 = (s0 = series[order[0]]).length) > 0))
    return;
  for (var y4 = 0, j = 1, s0, m3, n; j < m3; ++j) {
    for (var i2 = 0, s1 = 0, s22 = 0; i2 < n; ++i2) {
      var si = series[order[i2]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s32 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i2; ++k2) {
        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s32 += skj0 - skj1;
      }
      s1 += sij0, s22 += s32 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y4;
    if (s1)
      y4 -= s22 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y4;
  none_default(series, order);
}
var init_wiggle = __esm({
  "node_modules/d3-shape/src/offset/wiggle.js"() {
    init_shims();
    init_none();
  }
});

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a3, b) {
    return peaks[a3] - peaks[b];
  });
}
function peak(series) {
  var i2 = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i2 < n)
    if ((vi = +series[i2][1]) > vj)
      vj = vi, j = i2;
  return j;
}
var init_appearance = __esm({
  "node_modules/d3-shape/src/order/appearance.js"() {
    init_shims();
    init_none2();
  }
});

// node_modules/d3-shape/src/order/ascending.js
function ascending_default2(series) {
  var sums = series.map(sum3);
  return none_default2(series).sort(function(a3, b) {
    return sums[a3] - sums[b];
  });
}
function sum3(series) {
  var s4 = 0, i2 = -1, n = series.length, v2;
  while (++i2 < n)
    if (v2 = +series[i2][1])
      s4 += v2;
  return s4;
}
var init_ascending3 = __esm({
  "node_modules/d3-shape/src/order/ascending.js"() {
    init_shims();
    init_none2();
  }
});

// node_modules/d3-shape/src/order/descending.js
function descending_default2(series) {
  return ascending_default2(series).reverse();
}
var init_descending3 = __esm({
  "node_modules/d3-shape/src/order/descending.js"() {
    init_shims();
    init_ascending3();
  }
});

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n = series.length, i2, j, sums = series.map(sum3), order = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
  for (i2 = 0; i2 < n; ++i2) {
    j = order[i2];
    if (top2 < bottom2) {
      top2 += sums[j];
      tops.push(j);
    } else {
      bottom2 += sums[j];
      bottoms.push(j);
    }
  }
  return bottoms.reverse().concat(tops);
}
var init_insideOut = __esm({
  "node_modules/d3-shape/src/order/insideOut.js"() {
    init_shims();
    init_appearance();
    init_ascending3();
  }
});

// node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
  return none_default2(series).reverse();
}
var init_reverse2 = __esm({
  "node_modules/d3-shape/src/order/reverse.js"() {
    init_shims();
    init_none2();
  }
});

// node_modules/d3-shape/src/index.js
var init_src30 = __esm({
  "node_modules/d3-shape/src/index.js"() {
    init_shims();
    init_arc();
    init_area5();
    init_line2();
    init_pie();
    init_areaRadial();
    init_lineRadial();
    init_pointRadial();
    init_link2();
    init_symbol();
    init_circle4();
    init_cross3();
    init_diamond();
    init_square();
    init_star();
    init_triangle();
    init_wye();
    init_basisClosed2();
    init_basisOpen();
    init_basis2();
    init_bump();
    init_bundle();
    init_cardinalClosed();
    init_cardinalOpen();
    init_cardinal();
    init_catmullRomClosed();
    init_catmullRomOpen();
    init_catmullRom();
    init_linearClosed();
    init_linear3();
    init_monotone();
    init_natural();
    init_step();
    init_stack();
    init_expand();
    init_diverging2();
    init_none();
    init_silhouette();
    init_wiggle();
    init_appearance();
    init_ascending3();
    init_descending3();
    init_insideOut();
    init_none2();
    init_reverse2();
  }
});

// node_modules/d3-zoom/src/constant.js
var constant_default11;
var init_constant13 = __esm({
  "node_modules/d3-zoom/src/constant.js"() {
    init_shims();
    constant_default11 = (x5) => () => x5;
  }
});

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type2, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
var init_event3 = __esm({
  "node_modules/d3-zoom/src/event.js"() {
    init_shims();
  }
});

// node_modules/d3-zoom/src/transform.js
function Transform(k2, x5, y4) {
  this.k = k2;
  this.x = x5;
  this.y = y4;
}
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity5;
  return node.__zoom;
}
var identity5;
var init_transform3 = __esm({
  "node_modules/d3-zoom/src/transform.js"() {
    init_shims();
    Transform.prototype = {
      constructor: Transform,
      scale: function(k2) {
        return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
      },
      translate: function(x5, y4) {
        return x5 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x5, this.y + this.k * y4);
      },
      apply: function(point6) {
        return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
      },
      applyX: function(x5) {
        return x5 * this.k + this.x;
      },
      applyY: function(y4) {
        return y4 * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x5) {
        return (x5 - this.x) / this.k;
      },
      invertY: function(y4) {
        return (y4 - this.y) / this.k;
      },
      rescaleX: function(x5) {
        return x5.copy().domain(x5.range().map(this.invertX, this).map(x5.invert, x5));
      },
      rescaleY: function(y4) {
        return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    identity5 = new Transform(1, 0, 0);
    transform.prototype = Transform.prototype;
  }
});

// node_modules/d3-zoom/src/noevent.js
function nopropagation3(event) {
  event.stopImmediatePropagation();
}
function noevent_default3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var init_noevent3 = __esm({
  "node_modules/d3-zoom/src/noevent.js"() {
    init_shims();
  }
});

// node_modules/d3-zoom/src/zoom.js
function defaultFilter3(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent2() {
  var e3 = this;
  if (e3 instanceof SVGElement) {
    e3 = e3.ownerSVGElement || e3;
    if (e3.hasAttribute("viewBox")) {
      e3 = e3.viewBox.baseVal;
      return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
    }
    return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
  }
  return [[0, 0], [e3.clientWidth, e3.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity5;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable3() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent2, translateExtent) {
  var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
  return transform2.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
function zoom_default2() {
  var filter3 = defaultFilter3, extent2 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point6, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point6, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k2, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k2, p, event) {
    zoom.transform(selection2, function() {
      var e3 = extent2.apply(this, arguments), t03 = this.__zoom, p02 = p == null ? centroid(e3) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t03.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale2(t03, k1), p02, p1), e3, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x5, y4, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(typeof x5 === "function" ? x5.apply(this, arguments) : x5, typeof y4 === "function" ? y4.apply(this, arguments) : y4), extent2.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x5, y4, p, event) {
    zoom.transform(selection2, function() {
      var e3 = extent2.apply(this, arguments), t4 = this.__zoom, p02 = p == null ? centroid(e3) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity5.translate(p02[0], p02[1]).scale(t4.k).translate(typeof x5 === "function" ? -x5.apply(this, arguments) : -x5, typeof y4 === "function" ? -y4.apply(this, arguments) : -y4), e3, translateExtent);
    }, p, event);
  };
  function scale2(transform2, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p02, p1) {
    var x5 = p02[0] - p1[0] * transform2.k, y4 = p02[1] - p1[1] * transform2.k;
    return x5 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x5, y4);
  }
  function centroid(extent3) {
    return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
  }
  function schedule(transition2, transform2, point6, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e3 = extent2.apply(that, args), p = point6 == null ? centroid(e3) : typeof point6 === "function" ? point6.apply(that, args) : point6, w = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a3 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i2 = interpolate(a3.invert(p).concat(w / a3.k), b.invert(p).concat(w / b.k));
      return function(t4) {
        if (t4 === 1)
          t4 = b;
        else {
          var l = i2(t4), k2 = w / l[2];
          t4 = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);
        }
        g.zoom(null, t4);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent2.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      var d = select_default2(this.that).datum();
      listeners.call(type2, this.that, new ZoomEvent(type2, {
        sourceEvent: this.sourceEvent,
        target: zoom,
        type: type2,
        transform: this.that.__zoom,
        dispatch: listeners
      }), d);
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t4 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t4.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t4.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t4.k === k2)
      return;
    else {
      g.mouse = [p, t4.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default3(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale2(t4, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;
    nodrag_default(event.view);
    nopropagation3(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default3(event2);
      if (!g.moved) {
        var dx = event2.clientX - x06, dy = event2.clientY - y06;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default3(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var t03 = this.__zoom, p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p02), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale2(t03, k1), p02, p1), extent2.apply(this, args), translateExtent);
    noevent_default3(event);
    if (duration > 0)
      select_default2(this).transition().duration(duration).call(schedule, t13, p02, event);
    else
      select_default2(this).call(zoom.transform, t13, p02, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i2, t4, p;
    nopropagation3(event);
    for (i2 = 0; i2 < n; ++i2) {
      t4 = touches[i2], p = pointer_default(t4, this);
      p = [p, this.__zoom.invert(p), t4.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i2, t4, p, l;
    noevent_default3(event);
    for (i2 = 0; i2 < n; ++i2) {
      t4 = touches[i2], p = pointer_default(t4, this);
      if (g.touch0 && g.touch0[2] === t4.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t4.identifier)
        g.touch1[0] = p;
    }
    t4 = g.that.__zoom;
    if (g.touch1) {
      var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t4 = scale2(t4, Math.sqrt(dp / dl));
      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t4, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i2, t4;
    nopropagation3(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i2 = 0; i2 < n; ++i2) {
      t4 = touches[i2];
      if (g.touch0 && g.touch0[2] === t4.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t4.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t4 = pointer_default(t4, this);
        if (Math.hypot(touchfirst[0] - t4[0], touchfirst[1] - t4[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default11(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter3 = typeof _ === "function" ? _ : constant_default11(!!_), zoom) : filter3;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default11(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent2 = typeof _ === "function" ? _ : constant_default11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent2;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}
var init_zoom2 = __esm({
  "node_modules/d3-zoom/src/zoom.js"() {
    init_shims();
    init_src4();
    init_src6();
    init_src8();
    init_src5();
    init_src11();
    init_constant13();
    init_event3();
    init_transform3();
    init_noevent3();
  }
});

// node_modules/d3-zoom/src/index.js
var init_src31 = __esm({
  "node_modules/d3-zoom/src/index.js"() {
    init_shims();
    init_zoom2();
    init_transform3();
  }
});

// node_modules/d3/src/index.js
var src_exports = {};
__export(src_exports, {
  Adder: () => Adder,
  Delaunay: () => Delaunay,
  FormatSpecifier: () => FormatSpecifier,
  InternMap: () => InternMap,
  InternSet: () => InternSet,
  Node: () => Node,
  Voronoi: () => Voronoi,
  ZoomTransform: () => Transform,
  active: () => active_default,
  arc: () => arc_default,
  area: () => area_default5,
  areaRadial: () => areaRadial_default,
  ascending: () => ascending,
  autoType: () => autoType,
  axisBottom: () => axisBottom,
  axisLeft: () => axisLeft,
  axisRight: () => axisRight,
  axisTop: () => axisTop,
  bin: () => bin,
  bisect: () => bisect_default,
  bisectCenter: () => bisectCenter,
  bisectLeft: () => bisectLeft,
  bisectRight: () => bisectRight,
  bisector: () => bisector,
  blob: () => blob_default,
  brush: () => brush_default,
  brushSelection: () => brushSelection,
  brushX: () => brushX,
  brushY: () => brushY,
  buffer: () => buffer_default,
  chord: () => chord_default,
  chordDirected: () => chordDirected,
  chordTranspose: () => chordTranspose,
  cluster: () => cluster_default,
  color: () => color,
  contourDensity: () => density_default,
  contours: () => contours_default,
  count: () => count,
  create: () => create_default,
  creator: () => creator_default,
  cross: () => cross,
  csv: () => csv2,
  csvFormat: () => csvFormat,
  csvFormatBody: () => csvFormatBody,
  csvFormatRow: () => csvFormatRow,
  csvFormatRows: () => csvFormatRows,
  csvFormatValue: () => csvFormatValue,
  csvParse: () => csvParse,
  csvParseRows: () => csvParseRows,
  cubehelix: () => cubehelix,
  cumsum: () => cumsum,
  curveBasis: () => basis_default2,
  curveBasisClosed: () => basisClosed_default2,
  curveBasisOpen: () => basisOpen_default,
  curveBumpX: () => bumpX,
  curveBumpY: () => bumpY,
  curveBundle: () => bundle_default,
  curveCardinal: () => cardinal_default,
  curveCardinalClosed: () => cardinalClosed_default,
  curveCardinalOpen: () => cardinalOpen_default,
  curveCatmullRom: () => catmullRom_default,
  curveCatmullRomClosed: () => catmullRomClosed_default,
  curveCatmullRomOpen: () => catmullRomOpen_default,
  curveLinear: () => linear_default,
  curveLinearClosed: () => linearClosed_default,
  curveMonotoneX: () => monotoneX,
  curveMonotoneY: () => monotoneY,
  curveNatural: () => natural_default,
  curveStep: () => step_default,
  curveStepAfter: () => stepAfter,
  curveStepBefore: () => stepBefore,
  descending: () => descending,
  deviation: () => deviation,
  difference: () => difference,
  disjoint: () => disjoint,
  dispatch: () => dispatch_default,
  drag: () => drag_default,
  dragDisable: () => nodrag_default,
  dragEnable: () => yesdrag,
  dsv: () => dsv,
  dsvFormat: () => dsv_default,
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut,
  every: () => every,
  extent: () => extent,
  fcumsum: () => fcumsum,
  filter: () => filter,
  flatGroup: () => flatGroup,
  flatRollup: () => flatRollup,
  forceCenter: () => center_default,
  forceCollide: () => collide_default,
  forceLink: () => link_default,
  forceManyBody: () => manyBody_default,
  forceRadial: () => radial_default,
  forceSimulation: () => simulation_default,
  forceX: () => x_default2,
  forceY: () => y_default2,
  format: () => format2,
  formatDefaultLocale: () => defaultLocale,
  formatLocale: () => locale_default,
  formatPrefix: () => formatPrefix,
  formatSpecifier: () => formatSpecifier,
  fsum: () => fsum,
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoArea: () => area_default2,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoBounds: () => bounds_default,
  geoCentroid: () => centroid_default,
  geoCircle: () => circle_default,
  geoClipAntimeridian: () => antimeridian_default,
  geoClipCircle: () => circle_default2,
  geoClipExtent: () => extent_default2,
  geoClipRectangle: () => clipRectangle,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoContains: () => contains_default2,
  geoDistance: () => distance_default,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoGraticule: () => graticule,
  geoGraticule10: () => graticule10,
  geoIdentity: () => identity_default4,
  geoInterpolate: () => interpolate_default2,
  geoLength: () => length_default,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoPath: () => path_default2,
  geoProjection: () => projection,
  geoProjectionMutator: () => projectionMutator,
  geoRotation: () => rotation_default,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoStream: () => stream_default,
  geoTransform: () => transform_default,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw,
  gray: () => gray,
  greatest: () => greatest,
  greatestIndex: () => greatestIndex,
  group: () => group,
  groupSort: () => groupSort,
  groups: () => groups,
  hcl: () => hcl,
  hierarchy: () => hierarchy,
  histogram: () => bin,
  hsl: () => hsl,
  html: () => html,
  image: () => image_default,
  index: () => index,
  indexes: () => indexes,
  interpolate: () => value_default,
  interpolateArray: () => array_default,
  interpolateBasis: () => basis_default,
  interpolateBasisClosed: () => basisClosed_default,
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixDefault: () => cubehelix_default2,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateInferno: () => inferno,
  interpolateLab: () => lab2,
  interpolateMagma: () => magma,
  interpolateNumber: () => number_default,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  interpolateZoom: () => zoom_default,
  interrupt: () => interrupt_default,
  intersection: () => intersection,
  interval: () => interval_default,
  isoFormat: () => isoFormat_default,
  isoParse: () => isoParse_default,
  json: () => json_default,
  lab: () => lab,
  lch: () => lch,
  least: () => least,
  leastIndex: () => leastIndex,
  line: () => line_default2,
  lineRadial: () => lineRadial_default,
  linkHorizontal: () => linkHorizontal,
  linkRadial: () => linkRadial,
  linkVertical: () => linkVertical,
  local: () => local,
  map: () => map2,
  matcher: () => matcher_default,
  max: () => max,
  maxIndex: () => maxIndex,
  mean: () => mean,
  median: () => median,
  merge: () => merge,
  min: () => min,
  minIndex: () => minIndex,
  mode: () => mode,
  namespace: () => namespace_default,
  namespaces: () => namespaces_default,
  nice: () => nice,
  now: () => now,
  pack: () => pack_default,
  packEnclose: () => enclose_default,
  packSiblings: () => siblings_default,
  pairs: () => pairs,
  partition: () => partition_default,
  path: () => path_default,
  permute: () => permute,
  pie: () => pie_default,
  piecewise: () => piecewise,
  pointRadial: () => pointRadial_default,
  pointer: () => pointer_default,
  pointers: () => pointers_default,
  polygonArea: () => area_default4,
  polygonCentroid: () => centroid_default3,
  polygonContains: () => contains_default3,
  polygonHull: () => hull_default,
  polygonLength: () => length_default2,
  precisionFixed: () => precisionFixed_default,
  precisionPrefix: () => precisionPrefix_default,
  precisionRound: () => precisionRound_default,
  quadtree: () => quadtree,
  quantile: () => quantile,
  quantileSorted: () => quantileSorted,
  quantize: () => quantize_default,
  quickselect: () => quickselect,
  radialArea: () => areaRadial_default,
  radialLine: () => lineRadial_default,
  randomBates: () => bates_default,
  randomBernoulli: () => bernoulli_default,
  randomBeta: () => beta_default,
  randomBinomial: () => binomial_default,
  randomCauchy: () => cauchy_default,
  randomExponential: () => exponential_default,
  randomGamma: () => gamma_default,
  randomGeometric: () => geometric_default,
  randomInt: () => int_default,
  randomIrwinHall: () => irwinHall_default,
  randomLcg: () => lcg,
  randomLogNormal: () => logNormal_default,
  randomLogistic: () => logistic_default,
  randomNormal: () => normal_default,
  randomPareto: () => pareto_default,
  randomPoisson: () => poisson_default,
  randomUniform: () => uniform_default,
  randomWeibull: () => weibull_default,
  range: () => range,
  rank: () => rank,
  reduce: () => reduce,
  reverse: () => reverse,
  rgb: () => rgb,
  ribbon: () => ribbon_default,
  ribbonArrow: () => ribbonArrow,
  rollup: () => rollup,
  rollups: () => rollups,
  scaleBand: () => band,
  scaleDiverging: () => diverging,
  scaleDivergingLog: () => divergingLog,
  scaleDivergingPow: () => divergingPow,
  scaleDivergingSqrt: () => divergingSqrt,
  scaleDivergingSymlog: () => divergingSymlog,
  scaleIdentity: () => identity4,
  scaleImplicit: () => implicit,
  scaleLinear: () => linear3,
  scaleLog: () => log2,
  scaleOrdinal: () => ordinal,
  scalePoint: () => point,
  scalePow: () => pow3,
  scaleQuantile: () => quantile2,
  scaleQuantize: () => quantize,
  scaleRadial: () => radial,
  scaleSequential: () => sequential,
  scaleSequentialLog: () => sequentialLog,
  scaleSequentialPow: () => sequentialPow,
  scaleSequentialQuantile: () => sequentialQuantile,
  scaleSequentialSqrt: () => sequentialSqrt,
  scaleSequentialSymlog: () => sequentialSymlog,
  scaleSqrt: () => sqrt2,
  scaleSymlog: () => symlog,
  scaleThreshold: () => threshold,
  scaleTime: () => time,
  scaleUtc: () => utcTime,
  scan: () => scan,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme23,
  schemeBrBG: () => scheme2,
  schemeBuGn: () => scheme11,
  schemeBuPu: () => scheme12,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme13,
  schemeGreens: () => scheme24,
  schemeGreys: () => scheme25,
  schemeOrRd: () => scheme14,
  schemeOranges: () => scheme28,
  schemePRGn: () => scheme3,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme4,
  schemePuBu: () => scheme16,
  schemePuBuGn: () => scheme15,
  schemePuOr: () => scheme5,
  schemePuRd: () => scheme17,
  schemePurples: () => scheme26,
  schemeRdBu: () => scheme6,
  schemeRdGy: () => scheme7,
  schemeRdPu: () => scheme18,
  schemeRdYlBu: () => scheme8,
  schemeRdYlGn: () => scheme9,
  schemeReds: () => scheme27,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme10,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme20,
  schemeYlGnBu: () => scheme19,
  schemeYlOrBr: () => scheme21,
  schemeYlOrRd: () => scheme22,
  select: () => select_default2,
  selectAll: () => selectAll_default2,
  selection: () => selection_default,
  selector: () => selector_default,
  selectorAll: () => selectorAll_default,
  shuffle: () => shuffle_default,
  shuffler: () => shuffler,
  some: () => some,
  sort: () => sort,
  stack: () => stack_default,
  stackOffsetDiverging: () => diverging_default,
  stackOffsetExpand: () => expand_default,
  stackOffsetNone: () => none_default,
  stackOffsetSilhouette: () => silhouette_default,
  stackOffsetWiggle: () => wiggle_default,
  stackOrderAppearance: () => appearance_default,
  stackOrderAscending: () => ascending_default2,
  stackOrderDescending: () => descending_default2,
  stackOrderInsideOut: () => insideOut_default,
  stackOrderNone: () => none_default2,
  stackOrderReverse: () => reverse_default,
  stratify: () => stratify_default,
  style: () => styleValue,
  subset: () => subset,
  sum: () => sum,
  superset: () => superset,
  svg: () => svg,
  symbol: () => symbol_default,
  symbolCircle: () => circle_default3,
  symbolCross: () => cross_default2,
  symbolDiamond: () => diamond_default,
  symbolSquare: () => square_default,
  symbolStar: () => star_default,
  symbolTriangle: () => triangle_default,
  symbolWye: () => wye_default,
  symbols: () => symbols,
  text: () => text_default3,
  thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis,
  thresholdScott: () => thresholdScott,
  thresholdSturges: () => thresholdSturges,
  tickFormat: () => tickFormat,
  tickIncrement: () => tickIncrement,
  tickStep: () => tickStep,
  ticks: () => ticks,
  timeDay: () => day_default,
  timeDays: () => days,
  timeFormat: () => timeFormat,
  timeFormatDefaultLocale: () => defaultLocale2,
  timeFormatLocale: () => formatLocale,
  timeFriday: () => friday,
  timeFridays: () => fridays,
  timeHour: () => hour_default,
  timeHours: () => hours,
  timeInterval: () => newInterval,
  timeMillisecond: () => millisecond_default,
  timeMilliseconds: () => milliseconds,
  timeMinute: () => minute_default,
  timeMinutes: () => minutes,
  timeMonday: () => monday,
  timeMondays: () => mondays,
  timeMonth: () => month_default,
  timeMonths: () => months,
  timeParse: () => timeParse,
  timeSaturday: () => saturday,
  timeSaturdays: () => saturdays,
  timeSecond: () => second_default,
  timeSeconds: () => seconds,
  timeSunday: () => sunday,
  timeSundays: () => sundays,
  timeThursday: () => thursday,
  timeThursdays: () => thursdays,
  timeTickInterval: () => timeTickInterval,
  timeTicks: () => timeTicks,
  timeTuesday: () => tuesday,
  timeTuesdays: () => tuesdays,
  timeWednesday: () => wednesday,
  timeWednesdays: () => wednesdays,
  timeWeek: () => sunday,
  timeWeeks: () => sundays,
  timeYear: () => year_default,
  timeYears: () => years,
  timeout: () => timeout_default,
  timer: () => timer,
  timerFlush: () => timerFlush,
  transition: () => transition,
  transpose: () => transpose,
  tree: () => tree_default,
  treemap: () => treemap_default,
  treemapBinary: () => binary_default,
  treemapDice: () => dice_default,
  treemapResquarify: () => resquarify_default,
  treemapSlice: () => slice_default,
  treemapSliceDice: () => sliceDice_default,
  treemapSquarify: () => squarify_default,
  tsv: () => tsv2,
  tsvFormat: () => tsvFormat,
  tsvFormatBody: () => tsvFormatBody,
  tsvFormatRow: () => tsvFormatRow,
  tsvFormatRows: () => tsvFormatRows,
  tsvFormatValue: () => tsvFormatValue,
  tsvParse: () => tsvParse,
  tsvParseRows: () => tsvParseRows,
  union: () => union,
  utcDay: () => utcDay_default,
  utcDays: () => utcDays,
  utcFormat: () => utcFormat,
  utcFriday: () => utcFriday,
  utcFridays: () => utcFridays,
  utcHour: () => utcHour_default,
  utcHours: () => utcHours,
  utcMillisecond: () => millisecond_default,
  utcMilliseconds: () => milliseconds,
  utcMinute: () => utcMinute_default,
  utcMinutes: () => utcMinutes,
  utcMonday: () => utcMonday,
  utcMondays: () => utcMondays,
  utcMonth: () => utcMonth_default,
  utcMonths: () => utcMonths,
  utcParse: () => utcParse,
  utcSaturday: () => utcSaturday,
  utcSaturdays: () => utcSaturdays,
  utcSecond: () => second_default,
  utcSeconds: () => seconds,
  utcSunday: () => utcSunday,
  utcSundays: () => utcSundays,
  utcThursday: () => utcThursday,
  utcThursdays: () => utcThursdays,
  utcTickInterval: () => utcTickInterval,
  utcTicks: () => utcTicks,
  utcTuesday: () => utcTuesday,
  utcTuesdays: () => utcTuesdays,
  utcWednesday: () => utcWednesday,
  utcWednesdays: () => utcWednesdays,
  utcWeek: () => utcSunday,
  utcWeeks: () => utcSundays,
  utcYear: () => utcYear_default,
  utcYears: () => utcYears,
  variance: () => variance,
  window: () => window_default,
  xml: () => xml_default,
  zip: () => zip,
  zoom: () => zoom_default2,
  zoomIdentity: () => identity5,
  zoomTransform: () => transform
});
var init_src32 = __esm({
  "node_modules/d3/src/index.js"() {
    init_shims();
    init_src2();
    init_src3();
    init_src12();
    init_src14();
    init_src7();
    init_src15();
    init_src16();
    init_src4();
    init_src6();
    init_src17();
    init_src10();
    init_src18();
    init_src20();
    init_src21();
    init_src22();
    init_src23();
    init_src8();
    init_src13();
    init_src24();
    init_src19();
    init_src25();
    init_src28();
    init_src29();
    init_src5();
    init_src30();
    init_src26();
    init_src27();
    init_src9();
    init_src11();
    init_src31();
  }
});

// .svelte-kit/output/server/chunks/motion-illusions-04bc024c.js
var motion_illusions_04bc024c_exports = {};
__export(motion_illusions_04bc024c_exports, {
  default: () => Motion_illusions,
  metadata: () => metadata4
});
function onInterval(callback, milliseconds2) {
  let interval2;
  const play = () => {
    interval2 = setInterval(callback, milliseconds2);
  };
  const pause = () => {
    clearInterval(interval2);
  };
  play();
  onDestroy(() => {
    pause();
  });
  return {
    interval: interval2,
    pause,
    play
  };
}
var css$a, Icon, css$9, Tweet, css$8, Number_1, InView, css$7, Scrubber, css$6, BucketedImage, css$5, PlayControls, css$4, DualScrubber, css$3, OrangutanScrubber, css$2, numberOfFrames, OrangutanFrames, css$1, MarioScrubber, css, BarScrubber, metadata4, Motion_illusions;
var init_motion_illusions_04bc024c = __esm({
  ".svelte-kit/output/server/chunks/motion-illusions-04bc024c.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_src32();
    init_ssr();
    css$a = {
      code: ".c.svelte-htwn2n{fill:currentColor;height:1em;overflow:visible;width:1em}",
      map: null
    };
    Icon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let paths;
      let rotation;
      let { name = "money" } = $$props;
      let { direction = "n" } = $$props;
      const pathsByName = {
        arrow: [
          "M11.9019 0.618561C11.7176 0.69481 11.545 0.807839 11.3951 0.957646L0.457646 11.8951C-0.152549 12.5053 -0.152549 13.4947 0.457646 14.1049C1.06784 14.715 2.05716 14.715 2.66735 14.1049L10.9375 5.83471V23.9375C10.9375 24.8004 11.6371 25.5 12.5 25.5C13.3629 25.5 14.0625 24.8004 14.0625 23.9375V5.83471L22.3326 14.1049C22.9428 14.715 23.9322 14.715 24.5424 14.1049C25.1525 13.4947 25.1525 12.5053 24.5424 11.8951L13.6057 0.958487C13.6031 0.955925 13.6006 0.953368 13.598 0.950823C13.3158 0.672076 12.928 0.5 12.5 0.5C12.2881 0.5 12.0861 0.542165 11.9019 0.618561Z"
        ],
        chart: [
          "M25.5726 0.234706C26.0182 0.598493 26.0846 1.25469 25.7208 1.70036L15.825 13.8236C15.6272 14.066 15.3309 14.2066 15.0181 14.2066C14.7052 14.2066 14.4089 14.066 14.2111 13.8236L9.80974 8.43154L2.80422 17.0139C2.44043 17.4596 1.78424 17.526 1.33857 17.1622C0.892895 16.7984 0.826515 16.1422 1.1903 15.6965L9.00278 6.12555C9.20061 5.8832 9.49689 5.74258 9.80974 5.74258C10.1226 5.74258 10.4189 5.8832 10.6167 6.12555L15.0181 11.5176L24.1069 0.38297C24.4707 -0.0627016 25.1269 -0.129082 25.5726 0.234706Z",
          "M17.6221 1.04166C17.6221 0.466369 18.0884 0 18.6637 0H24.9137C25.489 0 25.9554 0.466369 25.9554 1.04166V8.69838C25.9554 9.27367 25.489 9.74004 24.9137 9.74004C24.3384 9.74004 23.8721 9.27367 23.8721 8.69838V2.08333H18.6637C18.0884 2.08333 17.6221 1.61696 17.6221 1.04166Z"
        ],
        download: [
          "M2.21191 15.4277C2.90227 15.4277 3.46191 15.9874 3.46191 16.6777V21.6777C3.46191 22.0093 3.59361 22.3272 3.82803 22.5616C4.06245 22.796 4.38039 22.9277 4.71191 22.9277H22.2119C22.5434 22.9277 22.8614 22.796 23.0958 22.5616C23.3302 22.3272 23.4619 22.0093 23.4619 21.6777V16.6777C23.4619 15.9874 24.0216 15.4277 24.7119 15.4277C25.4023 15.4277 25.9619 15.9874 25.9619 16.6777V21.6777C25.9619 22.6723 25.5668 23.6261 24.8636 24.3294C24.1603 25.0326 23.2065 25.4277 22.2119 25.4277H4.71191C3.71735 25.4277 2.76352 25.0326 2.06026 24.3294C1.357 23.6261 0.961914 22.6723 0.961914 21.6777V16.6777C0.961914 15.9874 1.52156 15.4277 2.21191 15.4277Z",
          "M6.32803 9.54385C6.81619 9.0557 7.60764 9.0557 8.0958 9.54385L13.4619 14.91L18.828 9.54385C19.3162 9.0557 20.1076 9.0557 20.5958 9.54385C21.084 10.032 21.084 10.8235 20.5958 11.3116L14.3458 17.5616C13.8576 18.0498 13.0662 18.0498 12.578 17.5616L6.32803 11.3116C5.83988 10.8235 5.83988 10.032 6.32803 9.54385Z",
          "M13.4619 0.427734C14.1523 0.427734 14.7119 0.987378 14.7119 1.67773V16.6777C14.7119 17.3681 14.1523 17.9277 13.4619 17.9277C12.7716 17.9277 12.2119 17.3681 12.2119 16.6777V1.67773C12.2119 0.987378 12.7716 0.427734 13.4619 0.427734Z"
        ],
        "logo-mark": [
          "M14.3204 1.32465C14.3204 1.73991 14.6571 2.07655 15.0723 2.07655C15.4876 2.07655 15.8242 1.73991 15.8242 1.32465C15.8242 0.909389 15.4876 0.572754 15.0723 0.572754C14.6571 0.572754 14.3204 0.909389 14.3204 1.32465ZM13.7566 6.02414C13.7566 6.75084 14.3457 7.33995 15.0724 7.33995C15.7991 7.33995 16.3882 6.75084 16.3882 6.02414C16.3882 5.29743 15.7991 4.70832 15.0724 4.70832C14.3457 4.70832 13.7566 5.29743 13.7566 6.02414ZM13.1926 10.7234C13.1926 11.7615 14.0342 12.6031 15.0723 12.6031C16.1105 12.6031 16.952 11.7615 16.952 10.7234C16.952 9.6852 16.1105 8.84361 15.0723 8.84361C14.0342 8.84361 13.1926 9.6852 13.1926 10.7234ZM13.1926 15.4226C13.1926 16.4608 14.0342 17.3024 15.0723 17.3024C16.1105 17.3024 16.952 16.4608 16.952 15.4226C16.952 14.3845 16.1105 13.5429 15.0723 13.5429C14.0342 13.5429 13.1926 14.3845 13.1926 15.4226ZM10.3727 12.6031C9.33456 12.6031 8.49298 11.7615 8.49298 10.7234C8.49298 9.6852 9.33456 8.84361 10.3727 8.84361C11.4108 8.84361 12.2524 9.6852 12.2524 10.7234C12.2524 11.7615 11.4108 12.6031 10.3727 12.6031ZM8.49298 15.4226C8.49298 16.4608 9.33456 17.3024 10.3727 17.3024C11.4108 17.3024 12.2524 16.4608 12.2524 15.4226C12.2524 14.3845 11.4108 13.5429 10.3727 13.5429C9.33456 13.5429 8.49298 14.3845 8.49298 15.4226ZM24.471 11.4754C24.0558 11.4754 23.7191 11.1387 23.7191 10.7235C23.7191 10.3082 24.0558 9.97157 24.471 9.97157C24.8863 9.97157 25.2229 10.3082 25.2229 10.7235C25.2229 11.1387 24.8863 11.4754 24.471 11.4754ZM23.7191 15.4227C23.7191 15.838 24.0558 16.1746 24.471 16.1746C24.8863 16.1746 25.2229 15.838 25.2229 15.4227C25.2229 15.0075 24.8863 14.6708 24.471 14.6708C24.0558 14.6708 23.7191 15.0075 23.7191 15.4227ZM19.7713 12.039C19.0446 12.039 18.4554 11.4498 18.4554 10.7231C18.4554 9.99643 19.0446 9.40732 19.7713 9.40732C20.498 9.40732 21.0871 9.99643 21.0871 10.7231C21.0871 11.4498 20.498 12.039 19.7713 12.039ZM18.4554 15.4227C18.4554 16.1494 19.0446 16.7385 19.7713 16.7385C20.498 16.7385 21.0871 16.1494 21.0871 15.4227C21.0871 14.696 20.498 14.1069 19.7713 14.1069C19.0446 14.1069 18.4554 14.696 18.4554 15.4227ZM5.67371 12.039C4.94701 12.039 4.3579 11.4498 4.3579 10.7231C4.3579 9.99643 4.94701 9.40732 5.67371 9.40732C6.40041 9.40732 6.98952 9.99643 6.98952 10.7231C6.98952 11.4498 6.40041 12.039 5.67371 12.039ZM10.3726 7.33995C9.64587 7.33995 9.05677 6.75084 9.05677 6.02414C9.05677 5.29743 9.64587 4.70832 10.3726 4.70832C11.0993 4.70832 11.6884 5.29743 11.6884 6.02414C11.6884 6.75084 11.0993 7.33995 10.3726 7.33995ZM10.3726 2.07655C9.95739 2.07655 9.62076 1.73991 9.62076 1.32465C9.62076 0.909389 9.95739 0.572754 10.3726 0.572754C10.7879 0.572754 11.1245 0.909389 11.1245 1.32465C11.1245 1.73991 10.7879 2.07655 10.3726 2.07655ZM18.7376 6.0243C18.7376 6.59528 19.2005 7.05816 19.7715 7.05816C20.3425 7.05816 20.8053 6.59528 20.8053 6.0243C20.8053 5.45332 20.3425 4.99044 19.7715 4.99044C19.2005 4.99044 18.7376 5.45332 18.7376 6.0243ZM5.67314 7.05816C5.10216 7.05816 4.63928 6.59528 4.63928 6.0243C4.63928 5.45332 5.10216 4.99044 5.67314 4.99044C6.24412 4.99044 6.70699 5.45332 6.70699 6.0243C6.70699 6.59528 6.24412 7.05816 5.67314 7.05816ZM13.7566 20.122C13.7566 20.8487 14.3457 21.4378 15.0724 21.4378C15.7991 21.4378 16.3882 20.8487 16.3882 20.122C16.3882 19.3952 15.7991 18.8061 15.0724 18.8061C14.3457 18.8061 13.7566 19.3952 13.7566 20.122ZM10.3726 21.4378C9.64587 21.4378 9.05677 20.8487 9.05677 20.122C9.05677 19.3952 9.64587 18.8061 10.3726 18.8061C11.0993 18.8061 11.6884 19.3952 11.6884 20.122C11.6884 20.8487 11.0993 21.4378 10.3726 21.4378ZM14.3204 24.8216C14.3204 25.2368 14.6571 25.5735 15.0723 25.5735C15.4876 25.5735 15.8242 25.2368 15.8242 24.8216C15.8242 24.4063 15.4876 24.0697 15.0723 24.0697C14.6571 24.0697 14.3204 24.4063 14.3204 24.8216ZM10.3726 25.5735C9.95739 25.5735 9.62076 25.2368 9.62076 24.8216C9.62076 24.4063 9.95739 24.0697 10.3726 24.0697C10.7879 24.0697 11.1245 24.4063 11.1245 24.8216C11.1245 25.2368 10.7879 25.5735 10.3726 25.5735ZM18.7376 20.1218C18.7376 20.6928 19.2005 21.1557 19.7715 21.1557C20.3425 21.1557 20.8053 20.6928 20.8053 20.1218C20.8053 19.5509 20.3425 19.088 19.7715 19.088C19.2005 19.088 18.7376 19.5509 18.7376 20.1218ZM5.67314 21.1557C5.10216 21.1557 4.63928 20.6928 4.63928 20.1218C4.63928 19.5509 5.10216 19.088 5.67314 19.088C6.24412 19.088 6.70699 19.5509 6.70699 20.1218C6.70699 20.6928 6.24412 21.1557 5.67314 21.1557ZM4.3579 15.4227C4.3579 16.1494 4.94701 16.7385 5.67371 16.7385C6.40041 16.7385 6.98952 16.1494 6.98952 15.4227C6.98952 14.696 6.40041 14.1069 5.67371 14.1069C4.94701 14.1069 4.3579 14.696 4.3579 15.4227ZM0.974784 11.4754C0.559525 11.4754 0.222893 11.1387 0.222893 10.7235C0.222893 10.3082 0.559525 9.97157 0.974784 9.97157C1.39004 9.97157 1.72667 10.3082 1.72667 10.7235C1.72667 11.1387 1.39004 11.4754 0.974784 11.4754ZM0.222893 15.4227C0.222893 15.838 0.559525 16.1746 0.974784 16.1746C1.39004 16.1746 1.72667 15.838 1.72667 15.4227C1.72667 15.0075 1.39004 14.6708 0.974784 14.6708C0.559525 14.6708 0.222893 15.0075 0.222893 15.4227Z"
        ],
        menu: [
          "M0 21.6667H25V18.8889H0V21.6667ZM0 14.7222H25V11.9444H0V14.7222ZM0 5V7.77778H25V5H0Z"
        ],
        money: [
          "M13.2917 0C13.867 0 14.3333 0.46637 14.3333 1.04167V23.9583C14.3333 24.5336 13.867 25 13.2917 25C12.7164 25 12.25 24.5336 12.25 23.9583V1.04167C12.25 0.46637 12.7164 0 13.2917 0Z",
          "M7.37294 5.53956C8.25201 4.66049 9.4443 4.16663 10.6875 4.16663H18.5C19.0753 4.16663 19.5417 4.633 19.5417 5.20829C19.5417 5.78359 19.0753 6.24996 18.5 6.24996H10.6875C9.99683 6.24996 9.33445 6.52433 8.84608 7.0127C8.3577 7.50108 8.08333 8.16346 8.08333 8.85413C8.08333 9.54479 8.3577 10.2072 8.84608 10.6955C9.33445 11.1839 9.99683 11.4583 10.6875 11.4583H15.8958C17.139 11.4583 18.3313 11.9522 19.2104 12.8312C20.0895 13.7103 20.5833 14.9026 20.5833 16.1458C20.5833 17.389 20.0895 18.5813 19.2104 19.4604C18.3313 20.3394 17.139 20.8333 15.8958 20.8333H7.04167C6.46637 20.8333 6 20.3669 6 19.7916C6 19.2163 6.46637 18.75 7.04167 18.75H15.8958C16.5865 18.75 17.2489 18.4756 17.7373 17.9872C18.2256 17.4988 18.5 16.8365 18.5 16.1458C18.5 15.4551 18.2256 14.7927 17.7373 14.3044C17.2489 13.816 16.5865 13.5416 15.8958 13.5416H10.6875C9.4443 13.5416 8.25201 13.0478 7.37294 12.1687C6.49386 11.2896 6 10.0973 6 8.85413C6 7.61092 6.49386 6.41864 7.37294 5.53956Z"
        ],
        pencil: [
          "M0 20.7899V25.9975H5.20761L20.5666 10.6386L15.359 5.43094L0 20.7899ZM24.5938 6.61133C25.1354 6.06974 25.1354 5.19486 24.5938 4.65327L21.3443 1.40372C20.8027 0.86213 19.9278 0.86213 19.3862 1.40372L16.8449 3.94504L22.0525 9.15265L24.5938 6.61133V6.61133Z"
        ],
        play: [
          "M2.15039 4.29245C2.15039 1.59772 5.1315 -0.029815 7.39825 1.42738L21.5358 10.5158C23.6214 11.8565 23.6214 14.9052 21.5358 16.2459L7.39825 25.3343C5.1315 26.7915 2.15039 25.164 2.15039 22.4693V4.29245Z"
        ],
        pause: [
          "M9.5 21.9092V3.15918C9.5 1.43329 8.10089 0.0341797 6.375 0.0341797C4.64911 0.0341797 3.25 1.43329 3.25 3.15918V21.9092C3.25 23.6351 4.64911 25.0342 6.375 25.0342C8.10089 25.0342 9.5 23.6351 9.5 21.9092Z",
          "M22 21.9092V3.15918C22 1.43329 20.6009 0.0341797 18.875 0.0341797C17.1491 0.0341797 15.75 1.43329 15.75 3.15918V21.9092C15.75 23.6351 17.1491 25.0342 18.875 25.0342C20.6009 25.0342 22 23.6351 22 21.9092Z"
        ],
        search: [
          "M2.50001 11.2501C2.50001 6.41754 6.41754 2.50001 11.2501 2.50001C16.0826 2.50001 20.0001 6.41754 20.0001 11.2501C20.0001 13.6071 19.0681 15.7464 17.5526 17.3197C17.5095 17.3528 17.4681 17.3891 17.4286 17.4286C17.3891 17.4681 17.3528 17.5095 17.3197 17.5526C15.7464 19.0681 13.6071 20.0001 11.2501 20.0001C6.41754 20.0001 2.50001 16.0826 2.50001 11.2501ZM18.2722 20.04C16.3476 21.5795 13.9063 22.5001 11.2501 22.5001C5.03682 22.5001 0 17.4633 0 11.2501C0 5.03682 5.03682 0 11.2501 0C17.4633 0 22.5001 5.03682 22.5001 11.2501C22.5001 13.9063 21.5795 16.3476 20.04 18.2722L24.6339 22.8661C25.122 23.3543 25.122 24.1457 24.6339 24.6339C24.1457 25.122 23.3543 25.122 22.8661 24.6339L18.2722 20.04Z"
        ],
        swoop: [
          "M17.6488 0.406796C17.1064 -0.135599 16.227 -0.135599 15.6846 0.406796C15.1422 0.949191 15.1422 1.82859 15.6846 2.37098L20.258 6.94444H6.94444C5.10266 6.94444 3.33632 7.67609 2.03398 8.97843C0.731644 10.2808 0 12.0471 0 13.8889V23.6111C0 24.3782 0.621827 25 1.38889 25C2.15595 25 2.77778 24.3782 2.77778 23.6111V13.8889C2.77778 12.7838 3.21676 11.724 3.99817 10.9426C4.77957 10.1612 5.83938 9.72222 6.94444 9.72222H20.258L15.6846 14.2957C15.1422 14.8381 15.1422 15.7175 15.6846 16.2599C16.227 16.8023 17.1064 16.8023 17.6488 16.2599L24.5932 9.31543C24.8611 9.04749 24.9967 8.69732 24.9999 8.34616C25 8.34189 25 8.33761 25 8.33333C25 8.32906 25 8.32478 24.9999 8.32051C24.9983 8.13686 24.961 7.96173 24.8946 7.80169C24.8268 7.63788 24.7264 7.4844 24.5932 7.35124L17.6488 0.406796Z"
        ],
        x: [
          "M24.8898 4.05647C25.7034 3.24288 25.7034 1.92379 24.8898 1.11019C24.0762 0.296602 22.7571 0.296602 21.9435 1.11019L13 10.0537L4.05647 1.11019C3.24288 0.296602 1.92379 0.296602 1.11019 1.11019C0.296602 1.92379 0.296602 3.24288 1.11019 4.05647L10.0537 13L1.11019 21.9435C0.296602 22.7571 0.296602 24.0762 1.11019 24.8898C1.92379 25.7034 3.24288 25.7034 4.05647 24.8898L13 15.9463L21.9435 24.8898C22.7571 25.7034 24.0762 25.7034 24.8898 24.8898C25.7034 24.0762 25.7034 22.7571 24.8898 21.9435L15.9463 13L24.8898 4.05647Z"
        ],
        facebook: [
          "M20.2949 0.110107H16.5449C14.8873 0.110107 13.2976 0.768588 12.1255 1.94069C10.9534 3.11279 10.2949 4.7025 10.2949 6.36011V10.1101H6.54492V15.1101H10.2949V25.1101H15.2949V15.1101H19.0449L20.2949 10.1101H15.2949V6.36011C15.2949 6.02859 15.4266 5.71064 15.661 5.47622C15.8955 5.2418 16.2134 5.11011 16.5449 5.11011H20.2949V0.110107Z"
        ],
        twitter: [
          "M25.7065 3.01887C24.6183 3.78646 23.4135 4.37354 22.1384 4.75751C21.454 3.97059 20.5444 3.41284 19.5327 3.1597C18.521 2.90656 17.456 2.97023 16.4816 3.34212C15.5073 3.714 14.6707 4.37615 14.0849 5.23901C13.4992 6.10186 13.1926 7.1238 13.2065 8.1666V9.30296C11.2095 9.35475 9.23072 8.91184 7.44633 8.0137C5.66193 7.11555 4.12736 5.79005 2.97927 4.15524C2.97927 4.15524 -1.56618 14.3825 8.66109 18.928C6.32078 20.5166 3.53286 21.3131 0.706543 21.2007C10.9338 26.8825 23.4338 21.2007 23.4338 8.13251C23.4328 7.81598 23.4023 7.50023 23.3429 7.18933C24.5027 6.04557 25.3211 4.6015 25.7065 3.01887V3.01887Z"
        ],
        instagram: [
          "M7.10138 3.17876C4.591 3.17876 2.55593 5.21383 2.55593 7.72422V19.0879C2.55593 21.5982 4.591 23.6333 7.10138 23.6333H18.465C20.9754 23.6333 23.0105 21.5982 23.0105 19.0879V7.72422C23.0105 5.21383 20.9754 3.17876 18.465 3.17876H7.10138ZM0.283203 7.72422C0.283203 3.95864 3.33581 0.906036 7.10138 0.906036H18.465C22.2306 0.906036 25.2832 3.95864 25.2832 7.72422V19.0879C25.2832 22.8534 22.2306 25.906 18.465 25.906H7.10138C3.33581 25.906 0.283203 22.8534 0.283203 19.0879V7.72422Z",
          "M13.3328 9.98466C12.6235 9.87948 11.8991 10.0006 11.2626 10.3309C10.6261 10.6611 10.11 11.1837 9.78758 11.8242C9.4652 12.4647 9.35299 13.1905 9.46691 13.8985C9.58083 14.6064 9.91508 15.2604 10.4221 15.7675C10.9291 16.2745 11.5832 16.6087 12.2911 16.7227C12.9991 16.8366 13.7249 16.7244 14.3654 16.402C15.0059 16.0796 15.5284 15.5635 15.8587 14.927C16.1889 14.2905 16.3101 13.5661 16.2049 12.8568C16.0976 12.1333 15.7605 11.4635 15.2433 10.9463C14.7261 10.4291 14.0563 10.0919 13.3328 9.98466ZM10.2158 8.31356C11.2766 7.76313 12.484 7.56121 13.6661 7.73651C14.872 7.91533 15.9884 8.47723 16.8504 9.33922C17.7123 10.2012 18.2743 11.3176 18.4531 12.5234C18.6284 13.7056 18.4264 14.913 17.876 15.9737C17.3256 17.0345 16.4547 17.8948 15.3872 18.4321C14.3197 18.9694 13.1099 19.1564 11.93 18.9665C10.7501 18.7767 9.66011 18.2196 8.81505 17.3745C7.96999 16.5295 7.41291 15.4395 7.22305 14.2595C7.03318 13.0796 7.2202 11.8699 7.7575 10.8024C8.29481 9.73488 9.15503 8.86398 10.2158 8.31356Z"
        ],
        email: [
          "M23.3457 3.40601H3.3457C1.9707 3.40601 0.858203 4.53101 0.858203 5.90601L0.845703 20.906C0.845703 22.281 1.9707 23.406 3.3457 23.406H23.3457C24.7207 23.406 25.8457 22.281 25.8457 20.906V5.90601C25.8457 4.53101 24.7207 3.40601 23.3457 3.40601ZM23.3457 8.40601L13.3457 14.656L3.3457 8.40601V5.90601L13.3457 12.156L23.3457 5.90601V8.40601Z"
        ],
        link: [
          "M3.29785 13.1093C3.29785 10.9718 5.03535 9.23425 7.17285 9.23425H12.1729V6.85925H7.17285C3.72285 6.85925 0.922852 9.65925 0.922852 13.1093C0.922852 16.5593 3.72285 19.3593 7.17285 19.3593H12.1729V16.9843H7.17285C5.03535 16.9843 3.29785 15.2468 3.29785 13.1093ZM8.42285 14.3593H18.4229V11.8593H8.42285V14.3593ZM19.6729 6.85925H14.6729V9.23425H19.6729C21.8104 9.23425 23.5479 10.9718 23.5479 13.1093C23.5479 15.2468 21.8104 16.9843 19.6729 16.9843H14.6729V19.3593H19.6729C23.1229 19.3593 25.9229 16.5593 25.9229 13.1093C25.9229 9.65925 23.1229 6.85925 19.6729 6.85925Z"
        ]
      };
      const directions = ["n", "ne", "e", "se", "s", "sw", "w", "nw"];
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.direction === void 0 && $$bindings.direction && direction !== void 0)
        $$bindings.direction(direction);
      $$result.css.add(css$a);
      paths = pathsByName[name] || [];
      rotation = directions.indexOf(direction) * 45;
      return `<svg class="${"c svelte-htwn2n"}" viewBox="${"0 0 25 25"}"${add_attribute("style", `transform: rotate(${rotation}deg)`, 0)}>${each(paths, (path2) => `<path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}"${add_attribute("d", path2, 0)}></path>`)}</svg>`;
    });
    css$9 = {
      code: ".tweet.svelte-r1b5fo{align-items:center;display:flex;justify-content:center;margin:-1em 0 0;min-height:15em;transform:scale(.9)}",
      map: null
    };
    Tweet = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { id: id2 = "" } = $$props;
      let { options: options2 = {} } = $$props;
      let tweetElement;
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
        $$bindings.options(options2);
      $$result.css.add(css$9);
      return `<div class="${"tweet svelte-r1b5fo"}"${add_attribute("this", tweetElement, 0)}></div>`;
    });
    css$8 = {
      code: '.c.svelte-kq0dj9{font-feature-settings:"tnum" 1}',
      map: null
    };
    Number_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let cachedNumber;
      let formatFunction;
      const { format: d3Format, interpolate, timer: d3Timer } = src_exports;
      let { number: number5 = null } = $$props;
      let { format: format3 = ",.2f" } = $$props;
      let { duration = 300 } = $$props;
      let displayNumber = 0;
      const startInterpolate = () => {
        const interpolationFunction = interpolate(cachedNumber, number5);
        const timer2 = d3Timer((timeElapsed) => {
          const t4 = timeElapsed / duration;
          displayNumber = interpolationFunction(t4);
          if (t4 >= 1) {
            if (timer2)
              timer2.stop();
            displayNumber = number5;
            cachedNumber = number5;
          }
        });
      };
      if ($$props.number === void 0 && $$bindings.number && number5 !== void 0)
        $$bindings.number(number5);
      if ($$props.format === void 0 && $$bindings.format && format3 !== void 0)
        $$bindings.format(format3);
      if ($$props.duration === void 0 && $$bindings.duration && duration !== void 0)
        $$bindings.duration(duration);
      $$result.css.add(css$8);
      cachedNumber = 0;
      formatFunction = (d) => {
        try {
          return typeof format3 == "string" ? d3Format(format3)(d) : format3(d);
        } catch (e3) {
          console.log(e3);
          return "-";
        }
      };
      {
        startInterpolate();
      }
      return `<span class="${"c svelte-kq0dj9"}">${escape2(Number.isFinite && Number.isFinite(+displayNumber) ? formatFunction(displayNumber) : "-")}
</span>`;
    });
    InView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { root: root3 = void 0 } = $$props;
      let { isInViewProp = false } = $$props;
      let isInView = false;
      let element;
      if ($$props.root === void 0 && $$bindings.root && root3 !== void 0)
        $$bindings.root(root3);
      if ($$props.isInViewProp === void 0 && $$bindings.isInViewProp && isInViewProp !== void 0)
        $$bindings.isInViewProp(isInViewProp);
      {
        isInViewProp = isInView;
      }
      return `<div class="${"c"}"${add_attribute("this", element, 0)}>${slots.default ? slots.default({ isInView }) : ``}</div>`;
    });
    css$7 = {
      code: ".scrubber.svelte-15uj77a{position:relative}.line.svelte-15uj77a{background:var(--a1);position:absolute}.line--x.svelte-15uj77a{bottom:0;left:-.5px;top:0;width:1px}.line--y.svelte-15uj77a{height:1px;left:0;right:0;top:-.5px}",
      map: null
    };
    Scrubber = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { dimension = "x" } = $$props;
      let { progress = 0 } = $$props;
      let { doShowLine = false } = $$props;
      let height = 100;
      let scrubberElement;
      if ($$props.dimension === void 0 && $$bindings.dimension && dimension !== void 0)
        $$bindings.dimension(dimension);
      if ($$props.progress === void 0 && $$bindings.progress && progress !== void 0)
        $$bindings.progress(progress);
      if ($$props.doShowLine === void 0 && $$bindings.doShowLine && doShowLine !== void 0)
        $$bindings.doShowLine(doShowLine);
      $$result.css.add(css$7);
      return `<div class="${"scrubber svelte-15uj77a"}"${add_attribute("this", scrubberElement, 0)}>${slots.default ? slots.default({}) : ``}
  ${doShowLine ? `<div class="${"line line--" + escape2(dimension) + " svelte-15uj77a"}" style="${"transform: translate" + escape2(dimension.toUpperCase()) + "(" + escape2(height * progress) + "px)"}"></div>` : ``}
</div>`;
    });
    css$6 = {
      code: ".c.svelte-1adimej{overflow:hidden;position:relative}img.svelte-1adimej{left:0;position:absolute;top:0}",
      map: null
    };
    BucketedImage = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let xOffset;
      let yOffset;
      let scaleStatement;
      let { image = "" } = $$props;
      let { aspectRatio = 2 } = $$props;
      let { index: index3 = 0 } = $$props;
      let { dimension = "y" } = $$props;
      let { alt = "" } = $$props;
      let { numberOfFrames: numberOfFrames2 = 10 } = $$props;
      let { doFlip = false } = $$props;
      if ($$props.image === void 0 && $$bindings.image && image !== void 0)
        $$bindings.image(image);
      if ($$props.aspectRatio === void 0 && $$bindings.aspectRatio && aspectRatio !== void 0)
        $$bindings.aspectRatio(aspectRatio);
      if ($$props.index === void 0 && $$bindings.index && index3 !== void 0)
        $$bindings.index(index3);
      if ($$props.dimension === void 0 && $$bindings.dimension && dimension !== void 0)
        $$bindings.dimension(dimension);
      if ($$props.alt === void 0 && $$bindings.alt && alt !== void 0)
        $$bindings.alt(alt);
      if ($$props.numberOfFrames === void 0 && $$bindings.numberOfFrames && numberOfFrames2 !== void 0)
        $$bindings.numberOfFrames(numberOfFrames2);
      if ($$props.doFlip === void 0 && $$bindings.doFlip && doFlip !== void 0)
        $$bindings.doFlip(doFlip);
      $$result.css.add(css$6);
      xOffset = dimension == "x" ? index3 * 100 / numberOfFrames2 : 0;
      yOffset = dimension == "y" ? index3 * 100 / numberOfFrames2 : 0;
      scaleStatement = doFlip ? dimension == "x" ? `scaleX(-1)` : `scaleY(-1)` : "";
      return `<div class="${"c svelte-1adimej"}" style="${"width: 100%; padding: " + escape2(1 / aspectRatio / 2 * 100) + "%"}"><img${add_attribute("src", image, 0)}${add_attribute("alt", alt, 0)} style="${"width: 100%; height: " + escape2(numberOfFrames2 * 100) + "%; transform: translate(" + escape2(-xOffset) + "%, " + escape2(-yOffset) + "%) " + escape2(scaleStatement)}" class="${"svelte-1adimej"}">
</div>`;
    });
    css$5 = {
      code: ".bar.svelte-1bwk42v{align-items:center;display:flex}button.svelte-1bwk42v{margin-right:1em}",
      map: null
    };
    PlayControls = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { time: time2 = 0 } = $$props;
      let { rate = 0.05 } = $$props;
      let { frameRate = 60 } = $$props;
      let { isPlaying = true } = $$props;
      let { isHidden = false } = $$props;
      const tick = () => {
        time2 += rate;
        if (time2 > 1)
          time2 = 0;
        if (time2 < 0)
          time2 = 0;
      };
      const { interval: interval2, pause, play } = onInterval(tick, frameRate);
      const onIsPlayingChange = () => {
        if (isPlaying) {
          play();
        } else {
          pause();
        }
      };
      if ($$props.time === void 0 && $$bindings.time && time2 !== void 0)
        $$bindings.time(time2);
      if ($$props.rate === void 0 && $$bindings.rate && rate !== void 0)
        $$bindings.rate(rate);
      if ($$props.frameRate === void 0 && $$bindings.frameRate && frameRate !== void 0)
        $$bindings.frameRate(frameRate);
      if ($$props.isPlaying === void 0 && $$bindings.isPlaying && isPlaying !== void 0)
        $$bindings.isPlaying(isPlaying);
      if ($$props.isHidden === void 0 && $$bindings.isHidden && isHidden !== void 0)
        $$bindings.isHidden(isHidden);
      $$result.css.add(css$5);
      {
        onIsPlayingChange();
      }
      return `${!isHidden ? `<div class="${"bar svelte-1bwk42v"}">${!isPlaying ? `<button class="${"svelte-1bwk42v"}">${validate_component(Icon, "Icon").$$render($$result, { name: "play" }, {}, {})}</button>` : `<button class="${"svelte-1bwk42v"}">${validate_component(Icon, "Icon").$$render($$result, { name: "pause" }, {}, {})}</button>`}
    ${slots.default ? slots.default({}) : ``}</div>` : `${slots.default ? slots.default({}) : ``}`}`;
    });
    css$4 = {
      code: ".c.svelte-10dqs2y.svelte-10dqs2y{display:flex}.left.svelte-10dqs2y.svelte-10dqs2y{flex:1;margin-right:1em}.right.svelte-10dqs2y.svelte-10dqs2y{flex:1;position:relative}.top.svelte-10dqs2y.svelte-10dqs2y{align-items:center;display:flex;height:3em;line-height:1.3em;margin-bottom:.3em}.top.svelte-10dqs2y span.svelte-10dqs2y span{font-weight:800}.slice.svelte-10dqs2y span.svelte-10dqs2y span{padding-left:.2em}.annotation.svelte-10dqs2y.svelte-10dqs2y{bottom:.5em;color:var(--a3);font-size:.9em;font-weight:700;letter-spacing:.06em;position:absolute;right:1em;text-transform:uppercase;z-index:10}@media(max-width:500px){.c.svelte-10dqs2y.svelte-10dqs2y{flex-direction:column}.right.svelte-10dqs2y.svelte-10dqs2y{margin-top:.6em}}",
      map: null
    };
    DualScrubber = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let leftFrameIndex;
      let rightFrameIndex;
      let isInView = false;
      let { leftImage = "/motionillusionblog/orangGifAsImg.jpeg" } = $$props;
      let { rightImage = "/motionillusionblog/buckets.jpg" } = $$props;
      let { playRate = 0.05 } = $$props;
      let { playFrameRate = 60 } = $$props;
      let { numberOfFrames: numberOfFrames2 = 24 - 1 } = $$props;
      let { numberOfBuckets = 270 / 5 - 1 } = $$props;
      let { leftAspectRatio = 480 / 270 } = $$props;
      let { rightAspectRatio = 480 / 24 / 11.25 } = $$props;
      let leftProgress = 0.5;
      let rightProgress = 0;
      let isPlaying = false;
      const onIsInViewChange = () => {
        setTimeout(() => {
          isPlaying = isInView;
        });
      };
      if ($$props.leftImage === void 0 && $$bindings.leftImage && leftImage !== void 0)
        $$bindings.leftImage(leftImage);
      if ($$props.rightImage === void 0 && $$bindings.rightImage && rightImage !== void 0)
        $$bindings.rightImage(rightImage);
      if ($$props.playRate === void 0 && $$bindings.playRate && playRate !== void 0)
        $$bindings.playRate(playRate);
      if ($$props.playFrameRate === void 0 && $$bindings.playFrameRate && playFrameRate !== void 0)
        $$bindings.playFrameRate(playFrameRate);
      if ($$props.numberOfFrames === void 0 && $$bindings.numberOfFrames && numberOfFrames2 !== void 0)
        $$bindings.numberOfFrames(numberOfFrames2);
      if ($$props.numberOfBuckets === void 0 && $$bindings.numberOfBuckets && numberOfBuckets !== void 0)
        $$bindings.numberOfBuckets(numberOfBuckets);
      if ($$props.leftAspectRatio === void 0 && $$bindings.leftAspectRatio && leftAspectRatio !== void 0)
        $$bindings.leftAspectRatio(leftAspectRatio);
      if ($$props.rightAspectRatio === void 0 && $$bindings.rightAspectRatio && rightAspectRatio !== void 0)
        $$bindings.rightAspectRatio(rightAspectRatio);
      $$result.css.add(css$4);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          onIsInViewChange();
        }
        leftFrameIndex = Math.floor(numberOfFrames2 * rightProgress);
        rightFrameIndex = Math.floor(numberOfBuckets * leftProgress);
        $$rendered = `${validate_component(InView, "InView").$$render($$result, { isInViewProp: isInView }, {
          isInViewProp: ($$value) => {
            isInView = $$value;
            $$settled = false;
          }
        }, {
          default: () => `<div class="${"c svelte-10dqs2y"}"><div class="${"left svelte-10dqs2y"}"><div class="${"top svelte-10dqs2y"}">${validate_component(PlayControls, "PlayControls").$$render($$result, {
            rate: playRate,
            frameRate: playFrameRate,
            time: rightProgress,
            isPlaying
          }, {
            time: ($$value) => {
              rightProgress = $$value;
              $$settled = false;
            },
            isPlaying: ($$value) => {
              isPlaying = $$value;
              $$settled = false;
            }
          }, {
            default: () => `<div class="${"frame"}"><span class="${"svelte-10dqs2y"}"><strong>Video</strong>
              at frame
              ${validate_component(Number_1, "Number").$$render($$result, {
              number: leftFrameIndex + 1,
              format: ".0f"
            }, {}, {})}</span></div>`
          })}</div>
      ${validate_component(Scrubber, "Scrubber").$$render($$result, {
            dimension: "y",
            doShowLine: true,
            progress: leftProgress
          }, {
            progress: ($$value) => {
              leftProgress = $$value;
              $$settled = false;
            }
          }, {
            default: () => `${validate_component(BucketedImage, "BucketedImage").$$render($$result, {
              image: leftImage,
              aspectRatio: leftAspectRatio,
              numberOfFrames: numberOfFrames2,
              index: leftFrameIndex,
              alt: "The video"
            }, {}, {})}`
          })}</div>
    <div class="${"right svelte-10dqs2y"}"><div class="${"top slice svelte-10dqs2y"}"><span class="${"svelte-10dqs2y"}"><strong>Slices through time</strong>
          at vertical position
          ${validate_component(Number_1, "Number").$$render($$result, {
            number: rightFrameIndex + 1,
            format: ".0f"
          }, {}, {})}</span></div>
      <div>${validate_component(Scrubber, "Scrubber").$$render($$result, {
            dimension: "y",
            doShowLine: true,
            progress: rightProgress
          }, {
            progress: ($$value) => {
              rightProgress = $$value;
              $$settled = false;
            }
          }, {
            default: () => `${validate_component(BucketedImage, "BucketedImage").$$render($$result, {
              image: rightImage,
              aspectRatio: rightAspectRatio,
              numberOfFrames: numberOfBuckets,
              index: rightFrameIndex,
              alt: "Slices of the video"
            }, {}, {})}`
          })}
        <div class="${"annotation svelte-10dqs2y"}">Time
          ${validate_component(Icon, "Icon").$$render($$result, { name: "arrow", direction: "s" }, {}, {})}</div></div></div></div>`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    css$3 = {
      code: ".c.svelte-c0f3sq{margin:2em 0}",
      map: null
    };
    OrangutanScrubber = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css$3);
      return `<div class="${"c svelte-c0f3sq"}">${validate_component(DualScrubber, "DualScrubber").$$render($$result, {
        leftImage: "/motionillusionblog/orangGifAsImg.jpeg",
        rightImage: "/motionillusionblog/buckets.jpg",
        numberOfFrames: 24,
        numberOfBuckets: 270 / 5,
        leftAspectRatio: 480 / 270,
        rightAspectRatio: 480 / 24 / 11.25
      }, {}, {})}
</div>`;
    });
    css$2 = {
      code: '.c.svelte-1ut4e6s{margin:2em auto;max-width:30em}strong.svelte-1ut4e6s{font-feature-settings:"tnum" 1;font-weight:700}',
      map: null
    };
    numberOfFrames = 24;
    OrangutanFrames = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let frameIndex;
      let time2 = 0;
      let isInView = true;
      let isPlaying = false;
      const onIsInViewChange = () => {
        setTimeout(() => {
          isPlaying = isInView;
        });
      };
      $$result.css.add(css$2);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          onIsInViewChange();
        }
        frameIndex = Math.floor(time2 * numberOfFrames / (numberOfFrames / 4)) * (numberOfFrames / 4);
        $$rendered = `${validate_component(InView, "InView").$$render($$result, { isInViewProp: isInView }, {
          isInViewProp: ($$value) => {
            isInView = $$value;
            $$settled = false;
          }
        }, {
          default: () => `<div class="${"c svelte-1ut4e6s"}">${validate_component(PlayControls, "PlayControls").$$render($$result, {
            rate: 0.1,
            frameRate: 500,
            isHidden: true,
            time: time2,
            isPlaying
          }, {
            time: ($$value) => {
              time2 = $$value;
              $$settled = false;
            },
            isPlaying: ($$value) => {
              isPlaying = $$value;
              $$settled = false;
            }
          }, {
            default: () => `<div class="${"frame"}"><span><strong class="${"svelte-1ut4e6s"}">Video</strong>
          at frame
          <strong class="${"svelte-1ut4e6s"}">${escape2(frameIndex + 1)}</strong></span></div>`
          })}
    ${validate_component(BucketedImage, "BucketedImage").$$render($$result, {
            image: "/motionillusionblog/orangGifAsImg.jpeg",
            aspectRatio: 480 / 270,
            numberOfFrames,
            index: frameIndex,
            alt: "Orangutan swinging"
          }, {}, {})}</div>`
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    css$1 = {
      code: ".c.svelte-hm2hf0{margin:2em auto;max-width:30em}",
      map: null
    };
    MarioScrubber = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css$1);
      return `<div class="${"c svelte-hm2hf0"}">${validate_component(DualScrubber, "DualScrubber").$$render($$result, {
        leftImage: "/motionillusionblog/mariocrop_GifAsImg.jpeg",
        rightImage: "/motionillusionblog/mariocrop_buckets.jpeg",
        numberOfFrames: 60,
        numberOfBuckets: 244 / 5,
        leftAspectRatio: 244 / 244,
        rightAspectRatio: 244 / 244,
        playRate: 0.016,
        playFrameRate: 100
      }, {}, {})}
</div>`;
    });
    css = {
      code: ".c.svelte-hm2hf0{margin:2em auto;max-width:30em}",
      map: null
    };
    BarScrubber = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css);
      return `<div class="${"c svelte-hm2hf0"}">${validate_component(DualScrubber, "DualScrubber").$$render($$result, {
        leftImage: "/motionillusionblog/1Dbars_GifAsImg.jpeg",
        rightImage: "/motionillusionblog/1Dbars_buckets.jpeg",
        numberOfFrames: 60,
        numberOfBuckets: 240 / 5,
        leftAspectRatio: 240 / 240,
        rightAspectRatio: 240 / 240,
        playRate: 0.016,
        playFrameRate: 100
      }, {}, {})}
</div>`;
    });
    metadata4 = {
      "title": "Motion Illusions",
      "date": "2020-12-6",
      "description": "The one in which we talk about motion"
    };
    Motion_illusions = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<p>There have been a lot of visual motion illusions going around Twitter recently. I think it is super cool that people find these motion demos so compelling. However, I\u2019ve been surprised to see lots of claims that there is \u201Cno motion\u201D in the illusions and most people seem to think there\u2019s some perceptual magic going on.</p>
<p>What is this magic?</p>
<h2 id="${"for-example-this-crazy-mario-illusion"}">For example, this crazy mario illusion</h2>
<p>The marios look like they\u2019re moving throughout the level, but each mario never gets anywhere. It\u2019s really quite upsetting.</p>
<video src="${"/motionillusionblog/marioReversePhi.mp4"}" autoplay loop muted style="${"max-width: min(100%, 30em)"}"></video>
<p>A number of people have expressed wonder at this example, pointing out that \u201Cnothing is actually moving\u201D.</p>
${validate_component(Tweet, "Tweet").$$render($$result, { id: "1335266992228626432" }, {}, {})}
<p>And it follows in a whole series of really clever illusions that use the same effect, but are often designed to mislead the observer.</p>
${validate_component(Tweet, "Tweet").$$render($$result, { id: "1331674290937327617" }, {}, {})}
<h2 id="${"how-do-these-illusions-work"}">How do these illusions work?</h2>
<p>I thought this was a good opportunity to write up a little blog post about
visual motion. Let\u2019s take this Mario example here and look at what\u2019s actually
going on.</p>
<h3 id="${"but-first-what-is-motion"}">But first, what is motion?</h3>
<p>Motion is <strong>change in position over time</strong>.</p>
<p>Something that does not move is static because it has the same position as time
progresses. We often think of motion in the real world: furniture does not
change position over time (does not move). You, your dog, all animals, your
limbs, all change position over time. So, they move in the world.</p>
<p>However, from the perspective from your visual system (or a video camera), motion isn\u2019t so
straightforward. For example, if I were to pan a camera across a room, the room
would be moving with respect to the reference frame of the camera. That is
motion as well. In other words, <strong>visual motion is not just a result of things
moving in the world, but can also result from the sensor moving</strong>.</p>
<p>So, what is
visual motion and how do we see it? Let\u2019s take the idea of something changing
position over time in the real world and apply it to the pixels of a movie. You\u2019ll see this makes
sense in a minute. Here\u2019s a video of a real moving thing swinging.</p>
<video src="${"/motionillusionblog/orangutanVid.mp4"}" autoplay loop muted style="${"max-width: min(100%, 30em)"}"></video>

<p style="${"text-align: center; margin: -1.4em 0 2em"}">from <a href="${"https://giphy.com/search/monkey-swing"}">Giphy</a></p>
<p>What makes this a video of a moving thing?
Well, if we look at different frames, we can see the position of the orangutan
has moved over time.</p>
${validate_component(OrangutanFrames, "OrangutanFrames").$$render($$result, {}, {}, {})}
<p>That tells us that the orangutan has moved, even with a fixed reference frame (the camera has not moved). Therefore the orangutan has moved in the real world.</p>
<p>One way to visualize this would be to <strong>plot the pixel values over time to see how they change</strong>. Since we cannot
plot every frame at all time points, let\u2019s take a slice through space and look
how that slice changes over time. You can move your mouse (scrub) over the 2D
image frame to see different space-time slices.</p>
<p>Scrub over the space-time slice to play through time in the movie. It won\u2019t be intuitive at first, but there is
a mapping from the motion of objects in the images to the patterns in the space
x time slices. Specifically, motion is orientation\u2026</p>

${validate_component(OrangutanScrubber, "OrangutanScrubber").$$render($$result, {}, {}, {})}
<p>Track the body of the orangutan and the branch. You can see that the movement of the orangutan and the branch form slanted structure in
the space-time plots, whereas the background looks like vertical streaks.</p>
<img src="${"/motionillusionblog/orangannotated.png"}" alt="${"Orangutan Space-time Annotations"}">
<p>It\u2019s a little tricky to see at first, but it\u2019s clear which things are moving and which are not. All of the slanted (or \u201Coriented\u201D) stuff in the space-time slice is stuff that\u2019s moving. In other words, we can define \u201CVisual Motion\u201D as orientation in space-time.</p>
<ul><li><p><strong>Vertical structure</strong> in space-time does not move.</p></li>
<li><p><strong>Horizontal structure</strong> in space-time, such as the edge of the leaves here, are appearances and disappearances.</p></li></ul>
<p>The TLDR of this whole post is: <strong>Our visual system detects orientation in space-time to see motion using little local detectors.</strong></p>
<p>But before we get into that, what\u2019s happening with the Marios? Is there orientation there as well?</p>
<h2 id="${"whats-happening-with-the-marios"}">What\u2019s happening with the marios?</h2>
<p>Above, we built a quick intuition for how visual motion is really just orientation in space-time. Let\u2019s zoom in on a single Mario
to see what happens if we use the same trick. Here is a single mario. It appears
to be moving to the right, but it never leaves the frame. This is the essential
component of the illusion.</p>
<video src="${"/motionillusionblog/MarioCropped.mp4"}" autoplay loop muted style="${"max-width: min(100%, 60em)"}"></video>
<p>If we take a slice through this mario, we can use the intuitions we learned above to see what\u2019s going on. In this figure, time is running up.</p>

${validate_component(MarioScrubber, "MarioScrubber").$$render($$result, {}, {}, {})}
<p>First, the mario is flashing different colors. That appears as horizontal
rainbow-colored lines. Horizontal structure in space-time plots (where time runs
up or down) is something appearing or disappearing (or, flashing!).</p>
<p>Second, in this view, we can clearly see where the motion comes from. There is oriented structure on the edges of the marios. Although there is a hard edge between the
colors and the gray that is vertical (and therefore does not move), the colors
are oriented at the edge.</p>
<img src="${"/motionillusionblog/coloredgeannotated.png"}" alt="${"Annotated Space-time slice"}" style="${"max-width: min(100%, 10em); display: block;"}">
<p><strong>The color has nothing to do with the illusion</strong> - let\u2019s rid of it for now because it\u2019s just a distraction. Here you\u2019ll see the same Mario in grayscale
(I\u2019ve just averaged across the color channels) and you can still see the effect.</p>
<video src="${"/motionillusionblog/MarioGray.mp4"}" autoplay loop muted style="${"width: 10em; max-width: min(100%, 60em)"}"></video>
<p>From here, we can construct a really simple illusion
that follows the same principles. We\u2019ll build an image that represents space-time
and then play it back as a 2D movie.</p>
<p>The image I\u2019ll make here is constructed using the same principle as the Mario\u2019s edge. The center is modulated in brightness, just like
the Mario\u2019s color was modulated. The edges drift to the right for 5 frames and
then jump back to the start. At each jump, the sign inverts and the cycle starts
again. Before scrolling down, <strong>try to imagine what this looks like if we played it as a movie</strong>.</p>
<img src="${"/motionillusionblog/constructedspacetime.png"}" alt="${"Constructed Space Time Slice"}" style="${"max-width: min(100%, 20em); display: block;"}">
<p>Since there is only 1D space in our
image from above, we don\u2019t have a 2D image at each time point. But, we can
visualize that 1D info as vertical bars.</p>
<p>Here\u2019s a single frame of our new
illusion.</p>
<img src="${"/motionillusionblog/constructedframe.png"}" alt="${"Constructed Space Time Frame"}" style="${"max-width: min(100%, 20em); display: block;"}">
<p>And here\u2019s the full movie of our space-time constructed object.</p>
${validate_component(BarScrubber, "BarScrubber").$$render($$result, {}, {}, {})}

<p>If we look back at the space-time construction again, we can see something interesting. There is an
edge moving to the right, but it keeps jumping back and changing sign (white is
on ones side and black on the other and then it flips).</p>
<img src="${"/motionillusionblog/grayannotated.png"}" alt="${"Orangutan Space-time Annotations"}" style="${"max-width: min(100%, 40em); display: block;"}">
<p>But we keep seeing motion to the right. <strong>This tells us something: our visual motion system doesn\u2019t
care about the sign of that edge.</strong> The lingo that vision scientists use to talk about
this is <em>motion perception doesn\u2019t care about phase</em> (for the purposes of this
blog post, phase is just the exact sign and position of that edge).</p>
<p>In other words, <strong>motion perception only cares about the orientation</strong>, not the stuff it\u2019s
made of. And that\u2019s pretty neat.</p>
<p>Next, let\u2019s look at an old model of visual motion processing with this property.</p>
<h2 id="${"the-motion-energy-model"}">The motion energy model</h2>
<p>Let\u2019s look at the state-of-the-art in human motion perception (in the mid 1980s),
also known as the \u201D<a href="${"http://persci.mit.edu/pub_pdfs/spatio85.pdf"}" rel="${"nofollow"}">motion energy model</a>\u201D. This is really a beautiful
paper, so I recommend anyone interest click in and take the time to read it.
Also, not all that much has changed in our understanding of the fundamentals in
the last 35 years.</p>
<p>So, how does human motion detectors work? Adelson and Bergen
start by making the same point that was demonstrated above: visual motion is
orientation in space-time. Panel <strong>a</strong> shows a frame of a movie with a bar
moving to the right (like our orangutan, above). <strong>b</strong> shows the full
spatiotemporal volume of the bar moving through space and time as if it were
continuously moving. But, of course, movies have frames and a frame rate. Panel
<strong>c</strong> shows the same volume, but now it reflects the frame rate of a movie.</p>
<img src="${"/motionillusionblog/AdelsonBergenMotionOrientation.png"}" alt="${"Motion as edge orientation"}" style="${"max-width: min(100%, 40em); margin: 2em auto; display: block;"}">
<p>From here, it makes sense to think about how to build detectors for motion. The
picture below shows that if you had an oriented filter in space time, you could
detect the edge. For the non-scientists reading this, you can think of these filters like little \u201Cedge detectors\u201D. These types of oriented filters are decent enough descriptions of the responses of neurons in visual cortex. For example, here\u2019s a <a href="${"https://www.youtube.com/watch?v=Cw5PKV9Rj3o&feature=emb_title"}" rel="${"nofollow"}">link to a video</a> of what
Hubel and Wiesel found in their classic experiments on primary visual cortex, which they concluded looks like a little line (or edge) detector.</p>
<img src="${"/motionillusionblog/AdelsonBergenEdgeDetector.png"}" alt="${"Motion as edge detectors"}" style="${"max-width: min(100%, 40em); margin: 2em auto; display: block;"}">
Importantly, these edge detectors still care about the sign of the edge. This,
as we noted above, is unlike our percept. To build detectors that do not care
about phase (don&#39;t care about the polarity of the edge). We can combine two oriented filters that care about opposite signs. In technical terms, these filters are 90\xB0 out of phase, forming a &quot;Quadrature Pair&quot;. Really don&#39;t worry about that jargon. This just means that where one filter _likes_ white, the other _likes_ black (and vice versa).
<img src="${"/motionillusionblog/AdelsonBergenQpair.png"}" alt="${"Phase-invariant filters"}" style="${"max-width: min(100%, 20em); margin: 2em auto; display: block;"}">
<blockquote><p>Note: A very <a href="${"https://www.osapublishing.org/DirectPDFAccess/4E69228F-07D1-9374-DF04DF81D3560F3A_1949/josaa-2-2-322.pdf?da=1&id=1949&seq=0&mobile=no"}" rel="${"nofollow"}">related paper</a>
from Watson and Ahumada came out in the same year and covers many of the same
points.</p></blockquote>
<p>Using the equations from Adelson and Bergen, 1985, we can make the same
little motion energy filters. Note: in my visualization below, time runs up.</p>
<p>The two filters on the right are selective to and edge moving to the right and are 90\xB0 out of phase with eachother.
The two filters on the left are selective to a leftward moving edge and are 90\xB0 out of phase with each other.</p>
<img src="${"/motionillusionblog/adelsonOrientedFilters.png"}" alt="${"Phase-invariant filters for left and right"}" style="${"max-width: min(100%, 30em); margin: 2em auto; display: block;"}">
<p>Here\u2019s a movie of what these look like:</p>
<video src="${"/motionillusionblog/motEfilters.mp4"}" autoplay loop muted style="${"max-width: min(100%, 30em)"}"></video>
<p>Let\u2019s pause for a second here and take note of two things:</p>
<ol><li>These little movies look a lot like what the edges of the marios do. So, <strong>contrary to the claim that the marios are \u201Cnot moving\u201D they are, in fact, made up of the fundamental elements of motion</strong>.</li>
<li>Derivatives</li></ol>
<h3 id="${"what-derivatives"}">What? Derivatives?</h3>
<p>How did Adelson and Bergen make these little moving edge detectors? Well, the key underlying component is the concept of a derivative. The spatial selectivity of these filters was created by taking the 1st and 2nd derivatives of a Gaussian.</p>
<p>The first idea to get across is that derivatives detect change (that\u2019s basically the definition). The derivative of a function <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1.2251079999999999em;vertical-align:-0.345em;"}"></span><span class="${"mord"}"><span class="${"mopen nulldelimiter"}"></span><span class="${"mfrac"}"><span class="${"vlist-t vlist-t2"}"><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.8801079999999999em;"}"><span style="${"top:-2.6550000000000002em;"}"><span class="${"pstrut"}" style="${"height:3em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mtight"}" style="${"margin-right:0.05556em;"}">\u2202</span><span class="${"mord mathnormal mtight"}">x</span></span></span></span><span style="${"top:-3.23em;"}"><span class="${"pstrut"}" style="${"height:3em;"}"></span><span class="${"frac-line"}" style="${"border-bottom-width:0.04em;"}"></span></span><span style="${"top:-3.394em;"}"><span class="${"pstrut"}" style="${"height:3em;"}"></span><span class="${"sizing reset-size6 size3 mtight"}"><span class="${"mord mtight"}"><span class="${"mord mtight"}" style="${"margin-right:0.05556em;"}">\u2202</span></span></span></span></span><span class="${"vlist-s"}">\u200B</span></span><span class="${"vlist-r"}"><span class="${"vlist"}" style="${"height:0.345em;"}"><span></span></span></span></span></span><span class="${"mclose nulldelimiter"}"></span></span><span class="${"mord mathnormal"}" style="${"margin-right:0.10764em;"}">f</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span></span></span></span></span> is how much the function value (<span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:1em;vertical-align:-0.25em;"}"></span><span class="${"mord mathnormal"}" style="${"margin-right:0.10764em;"}">f</span><span class="${"mopen"}">(</span><span class="${"mord mathnormal"}">x</span><span class="${"mclose"}">)</span></span></span></span></span>) changes for really small changes in <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.43056em;vertical-align:0em;"}"></span><span class="${"mord mathnormal"}">x</span></span></span></span></span>. That <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord"}" style="${"margin-right:0.05556em;"}">\u2202</span><span class="${"mord mathnormal"}">x</span></span></span></span></span> just means \u201Ctiny changes in x\u201D.</p>
<p>Intuitively then, something that moves will have to change as a function of changes in space, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord"}" style="${"margin-right:0.05556em;"}">\u2202</span><span class="${"mord mathnormal"}">x</span></span></span></span></span>, and time, <span class="${"math math-inline"}"><span class="${"katex"}"><span class="${"katex-html"}" aria-hidden="${"true"}"><span class="${"base"}"><span class="${"strut"}" style="${"height:0.69444em;vertical-align:0em;"}"></span><span class="${"mord"}" style="${"margin-right:0.05556em;"}">\u2202</span><span class="${"mord mathnormal"}">t</span></span></span></span></span>. A derivative filter is designed to detect those changes. And we can make a smooth one by starting with a smooth,localized, function and taking its derivative.</p>
<p>A Gaussian is a smooth bump spatially and taking the derivative can create the type of edge detector that Adelson and Bergen wanted to make. Here\u2019s what that looks like. Note: I\u2019ve normalized both curves to have the same amplitude.</p>
<img src="${"/motionillusionblog/gaussianderivative.png"}" alt="${"Gaussian Derivative"}" style="${"max-width: min(100%, 20em); margin: 2em auto; display: block;"}">
<p>So, one way to make a little \u201Cedge detector\u201D is a derivative filter. Thinking of early vision in terms of little derivatives is <a href="${"http://persci.mit.edu/pub_pdfs/elements91.pdf"}" rel="${"nofollow"}">really useful</a>.</p>
<h2 id="${"motion-energy-model-on-the-marios"}">Motion Energy Model on \u201Cthe Marios\u201D</h2>
<p><strong>So, is there motion in \u201Cthe Marios\u201D illusion?</strong> Let\u2019s use the motion energy model to find out. Below, I\u2019m going to play a movie of the cropped mario with the output of the motion energy model colored by the cardinal directions (using the following colors)</p>
<img src="${"/motionillusionblog/motionlegendtitle.png"}" alt="${"Motion Energy Legend"}" style="${"max-width: min(100%, 10em); margin: 2em auto; display: block;"}">
<p>Remember, the Mario we cropped looked like it was moving to the right.</p>
<video src="${"/motionillusionblog/MarioGray.mp4"}" autoplay loop muted style="${"width: 10em; max-width: min(100%, 60em)"}"></video>
<p>And the motion energy model agrees: Mario is moving to the right.</p>
<video src="${"/motionillusionblog/MarioCropped_motE_1.mp4"}" autoplay loop muted style="${"max-width: min(100%, 20em)"}"></video>
<p>We can see a couple cool things from this movie:</p>
<ol><li><strong>Rightward motion is only detected along the vertical edges</strong>. This is consistent with a principle that motion can only be encoded in the direction perpendicular to the orientation of an edge.</li>
<li><strong>There is some detected motion upwards and downwards at the top and bottom of the marios</strong>. This is also consistent with the point about edges made above.</li></ol>
<p>Our local motion detectors can\u2019t integrate motion over large parts of space, so they only \u201Csee\u201D the local signals at edges.</p>
<p>Let\u2019s look at what happens with the full Mario illusion:</p>
<video src="${"/motionillusionblog/MarioReversePhi_motE_1.mp4"}" autoplay loop muted style="${"max-width: min(100%, 40em)"}"></video>
<p>The motion energy model agrees (mostly) with our percept of the Marios. One issue visualizing it this way is that the colors mask the edges which kills the illusion. So, let\u2019s just look at the average motion energy over time:</p>
<img src="${"/motionillusionblog/MarioReversePhi_Adelson1.png"}" alt="${"Motion Energy Marios"}" style="${"max-width: min(100%, 40em); margin: 2em auto; display: block;"}">
<h2 id="${"conclusions"}">Conclusions</h2>
<p>Alright, so now that we took this whirlwind tour of visual motion perception applied to motion illusions. What did we learn?</p>
<h3 id="${"1-visual-motion-can-be-thought-of-as-orientation-in-space-time"}">1. Visual Motion can be thought of as orientation in space-time</h3>
<p>Because motion is defined by changes in space over time, it will appear as oriented structure when looking at space-time slices of a movie.</p>
<h3 id="${"2-human-motion-perception-works-by-integrating-across-little-motion-detectors-that-do-not-care-about-phase"}">2. Human motion perception works by integrating across little motion detectors that do not care about phase</h3>
<p>We see the marios as \u201Cmoving\u201D because they are. They are made of little space-time oriented elements at the edges. Our visual system detects those little local motion elements elements and does not care about the polarity of the edge as it moves (which is why the flashing of the marios doesn\u2019t disrupt the perception of constant motion).</p>
<h3 id="${"3-we-can-make-simple-motion-detectors-that-have-the-properties-of-human-vision"}">3. We can make simple motion detectors that have the properties of human vision</h3>
<p>The Adelson Bergen <strong>\u201CMotion Energy Model\u201D</strong> showed us a simple way to construct motion detectors that don\u2019t care about the polarity of an edge.</p>
<h3 id="${"4-the-motion-energy-model-sees-motion-in-the-marios-just-like-we-do"}">4. The motion energy model \u201Csees\u201D motion in the marios just like we do</h3>
<p>When we ran the motion energy model on the mario stimulus, those filters from the 1980s predict the same motion that we see. I\u2019d say this a different way. The marios are constructed using these fundamental elements of motion. So, yea, they\u2019re totally moving. They just aren\u2019t going anywhere. And, yes, I know what people mean when they say \u201Cnothing is moving\u201D.</p>
<h3 id="${"5-human-vision-relies-on-change"}">5. Human vision relies on change</h3>
<p>The motion energy filters we made were constructed using derivative filters. Derivatives are all about change. A large change in space is an edge. A large change in time is an appearance or disappearance. A change in both space and time is motion. Early vision mostly measures changes. That means your perception is going to be dependent on signals that are reflecting changes.</p>
<h3 id="${"finally-some-interesting-perspectives-on-twitter"}">Finally, some interesting perspectives on Twitter\u2026</h3>
<p>Some other people have pointed out the strong effect of the edges for seeing object motion.</p>
${validate_component(Tweet, "Tweet").$$render($$result, { id: "1331678121976684544" }, {}, {})}
<p>I think another way of saying this is that early vision works with <a href="${"http://persci.mit.edu/pub_pdfs/elements91.pdf"}" rel="${"nofollow"}">derivatives</a>, and high-level vision can only integrate those signals. So it kinda makes sense that high-level percepts would depend so much on edges.</p>
<p>Additionally, some people report being able to modulate whether they see the motion or not.</p>
${validate_component(Tweet, "Tweet").$$render($$result, { id: "1335302102957006848" }, {}, {})}
<p>I\u2019m not quite sure about the interpretation regarding \u201Csense of self\u201D, but I can also modulate how big the effect is. One trivial way to do this is to move my eyes to different locations. If I look well off the marios, there is no perceived motion. But that\u2019s not what this Tweet was about.</p>
<p>If I try hard enough (and I\u2019m not sure exactly what I\u2019m doing), I can get the effect to go away. I have two ideas about this. The first is that maybe I\u2019m doing something weird with my fixational eye movements or accommodation. The second option is that I\u2019m playing with my attentional readout of the low-level sensory signals. There\u2019s no getting around what\u2019s in the video (there is motion energy), so to be able to modulate this has something to do with how it\u2019s integrated.</p>
<h2 id="${"update-does-flownet2-match-our-perception"}">Update: Does Flownet2 match our perception?</h2>
<p>Flownet2 is the latest version of Deep Learning\u2019s answer to optic flow. For our intents and purposes here <em>optic flow</em> just means <em>visual motion</em>. The paper describing the model is <a href="${"https://arxiv.org/abs/1612.01925"}" rel="${"nofollow"}">here</a> and NVIDIA have kindly provided a <a href="${"https://github.com/NVIDIA/flownet2-pytorch"}" rel="${"nofollow"}">pytorch implementation</a>. I haven\u2019t had much time to play with the full model, and I\u2019m currently limited to frame width that cropped my original video, but it\u2019s already producing interesting and VERY different output than Adelson Bergen.</p>
<p>Here\u2019s a video visualizing the optic flow produced by FlowNet2 in the mario illusion and comparing that to Adelson Bergen:</p>
<video src="${"/motionillusionblog/marioreversephi_flownetcomp.mp4"}" autoplay loop muted style="${"max-width: min(100%, 40em)"}"></video>
<p>First off, flownet looks beautiful, but it totally fails to capture the illusion. I haven\u2019t had a chance to try other versions of the model, but this is not a win for modern machine learning. Adelson Bergen, on the other hand, captures the perceptual effect well. I think I\u2019ll do a deep dive into flownet in the future and see whether there is evidence for phase invariance, or why it is so blobby and full of flicker. Anyway, for now, it\u2019s nice to see that such a simple model from the 1980s performs so well on this \u201Ctask\u201D. Makes you wonder whether building in some of these principled constraints would make flownet match human perception more closely.</p>`;
    });
  }
});

// .svelte-kit/output/server/chunks/noisy-better-58314b05.js
var noisy_better_58314b05_exports = {};
__export(noisy_better_58314b05_exports, {
  default: () => Noisy_better,
  metadata: () => metadata5
});
var metadata5, Noisy_better;
var init_noisy_better_58314b05 = __esm({
  ".svelte-kit/output/server/chunks/noisy-better-58314b05.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    metadata5 = {
      "title": "The noisier model is better?",
      "date": "2021-3-3",
      "description": "A perplexing situation where a worse model is better",
      "draft": true
    };
    Noisy_better = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<p>I recently understood a figure from a paper or the first time the other day and the implications have been bugging me since. I\u2019ll talk more about the specific figure below, but the broad implications for neural modeling bother me: it turns out there are lots of ways that a <strong>more accurate model of neural responses can perform worse than a noisy model during statistical model comparison even though it\u2019s a better model</strong>.</p>
<h2 id="${"how-do-neuroscientists-decide-which-model-is-best"}">How do neuroscientists decide which model is best?</h2>
<p>The basic idea of most statistical models is that you have some mathematical equations that can generate fake data. In the case of neuroscience, it might be math that you think <a href>real neurons are doing</a> or it might be an equation that provides a nice <a href>functional description of a neuron\u2019s response</a>, but at the end of the day, you can make fake data that looks like real data once you\u2019ve set the <strong>parameters</strong> of the model correclty. There are many ways to learn the correct parameters, but one of the most common is to pick a <strong>loss function</strong> that specifies some</p>`;
    });
  }
});

// .svelte-kit/output/server/chunks/index.json-0f0405c8.js
var index_json_0f0405c8_exports = {};
__export(index_json_0f0405c8_exports, {
  get: () => get3
});
async function get3() {
  const pages = await Promise.all(Object.entries({ "/src/routes/blog/foodservice-academia.svx": () => Promise.resolve().then(() => (init_foodservice_academia_299db3c9(), foodservice_academia_299db3c9_exports)), "/src/routes/blog/lurz-paper.svx": () => Promise.resolve().then(() => (init_lurz_paper_8ed14628(), lurz_paper_8ed14628_exports)), "/src/routes/blog/matlab-arduino.svx": () => Promise.resolve().then(() => (init_matlab_arduino_e4388c2a(), matlab_arduino_e4388c2a_exports)), "/src/routes/blog/motion-illusions.svx": () => Promise.resolve().then(() => (init_motion_illusions_04bc024c(), motion_illusions_04bc024c_exports)), "/src/routes/blog/noisy-better.svx": () => Promise.resolve().then(() => (init_noisy_better_58314b05(), noisy_better_58314b05_exports)) }).map(async ([path2, page]) => {
    const filename = path2.split("/").pop();
    const slug = filename.replace(/\.svx$/, "");
    try {
      const { metadata: metadata6 } = await page();
      return { ...metadata6, filename, slug };
    } catch (e3) {
      console.log("issue loading blog post", filename, e3.loc);
      return { filename };
    }
  }));
  return {
    body: pages.sort((a3, b) => new Date(b.date) - new Date(a3.date))
  };
}
var init_index_json_0f0405c8 = __esm({
  ".svelte-kit/output/server/chunks/index.json-0f0405c8.js"() {
    init_shims();
  }
});

// .svelte-kit/output/server/chunks/__layout-fb37d90b.js
var layout_fb37d90b_exports = {};
__export(layout_fb37d90b_exports, {
  default: () => _layout
});
var css$12, Nav, Footer, css2, _layout;
var init_layout_fb37d90b = __esm({
  ".svelte-kit/output/server/chunks/__layout-fb37d90b.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    css$12 = {
      code: "nav.svelte-1yg3xhu{align-items:center;display:flex;flex-wrap:wrap;justify-content:space-between;margin:0 -.6em;padding:.9em 0;white-space:nowrap}.link.svelte-1yg3xhu{--tw-text-opacity:1;background:none;color:rgb(75 85 99/var(--tw-text-opacity));padding:.3em .6em}.links.svelte-1yg3xhu{align-items:center;display:flex}",
      map: null
    };
    Nav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css$12);
      return `<nav class="${" svelte-1yg3xhu"}"><a class="${"link font-semibold !text-gray-900 svelte-1yg3xhu"}" href="${"/"}">Jacob Yates</a>

  <div class="${"links text-base space-x-3 svelte-1yg3xhu"}"><a class="${"link svelte-1yg3xhu"}" href="${"/publications"}">Publications</a>
    <a class="${"link svelte-1yg3xhu"}" href="${"/cv"}">CV</a>
    <a class="${"link svelte-1yg3xhu"}" href="${"/blog"}">Thoughts</a></div>
</nav>`;
    });
    Footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<footer class="${"w-full h-3 mt-36 bg-gradient-to-r from-sky-500 to-teal-500"}"></footer>`;
    });
    css2 = {
      code: "main.svelte-1thd6wv{position:relative}",
      map: null
    };
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { segment } = $$props;
      if ($$props.segment === void 0 && $$bindings.segment && segment !== void 0)
        $$bindings.segment(segment);
      $$result.css.add(css2);
      return `<div class="${"h-5 bg-black w-full"}"></div>
<div class="${"container"}"><div class="${"main"}">${validate_component(Nav, "Nav").$$render($$result, { segment }, {}, {})}

    <main class="${"svelte-1thd6wv"}">${slots.default ? slots.default({}) : ``}</main></div></div>
${validate_component(Footer, "Footer").$$render($$result, {}, {}, {})}`;
    });
  }
});

// .svelte-kit/output/server/chunks/error-4b96ad91.js
var error_4b96ad91_exports = {};
__export(error_4b96ad91_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_4b96ad91 = __esm({
  ".svelte-kit/output/server/chunks/error-4b96ad91.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape2(status)}</h1>

<pre>${escape2(error2.message)}</pre>



${error2.frame ? `<pre>${escape2(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape2(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/chunks/Publication-73e3b84b.js
var publications, css3, Publication;
var init_Publication_73e3b84b = __esm({
  ".svelte-kit/output/server/chunks/Publication-73e3b84b.js"() {
    init_shims();
    init_app_bb3e34d2();
    publications = [
      {
        authors: "SL Cloherty*, JL Yates*, D Graf, GC DeAngelis, JF Mitchell",
        year: 2020,
        title: "Motion perception in the common marmoset",
        journal: "Cerebral Cortex",
        link: "https://marmolab.bcs.rochester.edu/pubs/2019_cloherty-etal_CC.pdf",
        highlights: [
          {
            title: "Faculty of 1000 (F1000Prime) entry",
            authors: "Marcello Rosa",
            link: "https://facultyopinions.com/prime/737076579"
          }
        ]
      },
      {
        authors: "DM Zoltowski, KW Latimer, JL Yates, AC Huk, JW Pillow",
        year: 2019,
        title: "Discrete stepping and nonlinear ramping dynamics underlie spiking responses of LIP neurons during decision-making",
        journal: "Neuron",
        page: "1249-1258",
        link: "https://pillowlab.princeton.edu/pubs/Zoltowski19_Neuron_StepRampLIP.pdf"
      },
      {
        authors: "JS Matthis, JL Yates, MM Hayhoe",
        year: 2018,
        title: "Gaze and the control of foot placement when walking in natural terrain",
        journal: "Current Biology",
        page: "1224-1233",
        link: "https://d1wqtxts1xzle7.cloudfront.net/56342614/1-s2.0-S0960982218303099-main.pdf?1523985307=&response-content-disposition=inline%3B+filename%3DGaze_and_the_Control_of_Foot_Placement_W.pdf&Expires=1605545857&Signature=IXmcSJW0Tm4rhuOnGqnNdYEv9nyJhsoM5-sfmWO8yhaMA0Z6ordEQkpRz5MKqaKPX5U2dLIsjCMSLKEbrT8pH~Y8Bn-DNT1wQaIt1Q6SUH5qqZjxU1qJCcoX~8azSDMekmA-eQzgVJDvcZdIbKvajp3KfYiNvwxxtuQuxDzgllRzD4FtKDRx7edsZvMfm-94lHi1JWCxA2IwbY8r01YcxPwN77v24KmGbMAYhel5fENzOGCKiL8zsRxAUs02DlPRkFGw7Dte8egzCRYWHWb3ani9lP9wds75NvbU~wvkTbK6kmLfbXI9WNYcx1D6fZ8bl6r5pBk9C0I8NeoFZ7UNyQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA"
      },
      {
        authors: "JL Yates, IM Park, LN Katz, JW Pillow, AC Huk",
        year: 2017,
        title: "Functional dissection of signal and noise in MT and LIP during decision-making",
        journal: "Nature Neuroscience",
        page: "1285-",
        link: "https://www.nature.com/articles/nn.4611.pdf?origin=ppub"
      },
      {
        authors: "AC Huk, LN Katz, JL Yates",
        year: 2017,
        title: "The role of the lateral intraparietal area in (the study of) decision making",
        journal: "Annual review of neuroscience",
        page: "40-",
        link: "https://www.annualreviews.org/doi/full/10.1146/annurev-neuro-072116-031508"
      },
      {
        authors: "LN Katz*, JL Yates*, JW Pillow, & AC Huk",
        year: 2016,
        title: "Dissociated functional significance of decision-related activity in the primate\ndorsal stream",
        journal: "Nature",
        page: "535: 285\u2013288",
        link: "http://www.nature.com/nature/journal/v535/n7611/full/nature18617.html",
        highlights: [
          {
            title: "Spotlight",
            where: "Trends in Neurosciences",
            authors: "Bijan Pesaran & David Freedman",
            link: "http://www.cell.com/trends/neurosciences/fulltext/S0166-2236(16)30099-6"
          },
          {
            title: "Spotlight",
            where: "Trends in Cognitive Sciences",
            authors: "Sashank Pisupati, Lital Chartarifsky, & Anne K. Churchland",
            link: "http://www.cell.com/trends/cognitive-sciences/fulltext/S1364-6613(16)30148-6"
          },
          {
            title: "Faculty of 1000 (F1000Prime) entry",
            authors: "Daeyeol Lee",
            link: "http://f1000.com/prime/726482747"
          },
          {
            title: "Research Highlight",
            where: "Nature Reviews Neuroscience",
            link: "http://www.nature.com/nrn/journal/vaop/ncurrent/full/nrn.2016.108.html"
          },
          {
            title: "Relevant review article",
            where: "Current Opinion in Neurobiology",
            authors: "Carlos Brody & Tim Hanks",
            link: "http://www.sciencedirect.com/science/article/pii/S0959438816000040"
          }
        ]
      },
      {
        authors: "KW Latimer, JL Yates, MM Meister, AC Huk, and JW Pillow",
        year: 2016,
        title: "Response to comment on \u201Csingle-trial spike trains in parietal cortex reveal\ndiscrete steps during decision-making\u201D",
        journal: "Science",
        page: "351(6280):1406",
        link: "http://science.sciencemag.org/content/351/6280/1406.3.long"
      },
      {
        authors: "KW Latimer, JL Yates, MM Meister, AC Huk, and JW Pillow",
        year: 2015,
        title: "Single-trial spike trains in parietal cortex reveal discrete steps during\ndecision-making",
        journal: "Science",
        page: "349(6244), 184-187",
        link: "http://www.sciencemag.org/content/349/6244/184.abstract"
      },
      {
        authors: "K Bonnen, J Burge, JL Yates, JW Pillow, LK Cormack",
        year: 2015,
        title: "Continuous Psychophysics: Target-tracking to Measure Visual Sensitivity",
        journal: "Journal of Vision",
        page: "15(3), 14",
        link: "bonnen15JOVKalmantracking",
        pdf: true
      },
      {
        authors: "JM Ales, JL Yates, AM Norcia",
        year: 2010,
        title: "V1 is not uniquely identified by polarity reversals of responses to upper\nand lower visual field stimuli",
        journal: "Neuroimage",
        page: "52(4), 1401-1409",
        link: "ales2010NeuroImage",
        pdf: true
      }
    ];
    css3 = {
      code: ".header.svelte-5hc0i5.svelte-5hc0i5{color:var(--tc);font-weight:700;text-decoration:none}a.svelte-5hc0i5.svelte-5hc0i5:visited{color:inherit}.link-out.svelte-5hc0i5.svelte-5hc0i5{color:var(--grey1);display:inline-block;vertical-align:top}.link-out.svelte-5hc0i5 svg.svelte-5hc0i5{margin-bottom:-.18em;width:1em}",
      map: null
    };
    Publication = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { link: link3 } = $$props;
      let { title } = $$props;
      let { authors } = $$props;
      let { journal } = $$props;
      let { year: year2 = "" } = $$props;
      let { page = "" } = $$props;
      let { highlights } = $$props;
      if ($$props.link === void 0 && $$bindings.link && link3 !== void 0)
        $$bindings.link(link3);
      if ($$props.title === void 0 && $$bindings.title && title !== void 0)
        $$bindings.title(title);
      if ($$props.authors === void 0 && $$bindings.authors && authors !== void 0)
        $$bindings.authors(authors);
      if ($$props.journal === void 0 && $$bindings.journal && journal !== void 0)
        $$bindings.journal(journal);
      if ($$props.year === void 0 && $$bindings.year && year2 !== void 0)
        $$bindings.year(year2);
      if ($$props.page === void 0 && $$bindings.page && page !== void 0)
        $$bindings.page(page);
      if ($$props.highlights === void 0 && $$bindings.highlights && highlights !== void 0)
        $$bindings.highlights(highlights);
      $$result.css.add(css3);
      return `<div class="${"publication bg-white py-10 px-14 shadow-lg shadow-blue-50 hover:shadow-blue-100 transition-all transform hover:-translate-y-1"}"><header><a${add_attribute("href", link3, 0)} class="${"header block svelte-5hc0i5"}"><h3 class="${"mt-0 mb-0"}">${escape2(title)}
        <div class="${"link-out svelte-5hc0i5"}"><svg xmlns="${"http://www.w3.org/2000/svg"}" width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" stroke="${"currentColor"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-5hc0i5"}"><line x1="${"7"}" y1="${"17"}" x2="${"17"}" y2="${"7"}"></line><polyline points="${"7 7 17 7 17 17"}"></polyline></svg></div></h3></a></header>
  <div class="${"mt-6 space-x-2 flex flex-wrap items-center"}">${each(authors.split(",").map((d) => d.trim()), (author) => `<div class="${[
        "py-1 px-3 bg-slate-50 text-slate-500 font-mono text-sm rounded-full mt-3",
        (["JL Yates", "JL Yates*"].includes(author) ? "text-sky-500" : "") + " " + (["JL Yates", "JL Yates*"].includes(author) ? "bg-sky-50" : "")
      ].join(" ").trim()}">${escape2(author)}
      </div>`)}</div>
  <div class="${"flex flex-col md:flex-row md:justify-between md:items-center mt-4 md:mt-5 flex-wrap text-gray-500"}"><div><span class="${"font-bold text-gray-500"}">${escape2(journal)}</span>
      <span class="${"font-thin font-mono text-sm ml-2"}">${escape2(year2)}</span></div>
    <div class="${"ml-auto font-thin font-mono text-sm mt-1 md:mt-0"}">${escape2(page)}</div></div>
  ${highlights ? `<div class="${""}">${each(highlights, ({ title: title2, where, authors: authors2, link: link22 }) => `<div class="${"flex flex-col md:flex-row md:justify-between md:items-center mt-6 md:mt-3"}"><a${add_attribute("href", link22, 0)} class="${"text-gray-500 hover:underline leading-5 svelte-5hc0i5"}">${escape2(title2)}
            ${where ? `in
              <i>${escape2(where)}</i>` : ``}</a>
          <div class="${"text-gray-500 text-sm md:text-left mt-2 md:mt-0"}">${escape2(authors2 || "")}</div>
        </div>`)}</div>` : ``}
</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/index-beec00e3.js
var index_beec00e3_exports = {};
__export(index_beec00e3_exports, {
  default: () => Routes
});
function writable2(value, start2 = noop5) {
  let stop;
  const subscribers = new Set();
  function set4(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
            subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set4(fn(value));
  }
  function subscribe2(run2, invalidate = noop5) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set4) || noop5;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set4, update, subscribe: subscribe2 };
}
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function get_interpolator(a3, b) {
  if (a3 === b || a3 !== a3)
    return () => a3;
  const type2 = typeof a3;
  if (type2 !== typeof b || Array.isArray(a3) !== Array.isArray(b)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a3)) {
    const arr = b.map((bi, i2) => {
      return get_interpolator(a3[i2], bi);
    });
    return (t4) => arr.map((fn) => fn(t4));
  }
  if (type2 === "object") {
    if (!a3 || !b)
      throw new Error("Object cannot be null");
    if (is_date(a3) && is_date(b)) {
      a3 = a3.getTime();
      b = b.getTime();
      const delta = b - a3;
      return (t4) => new Date(a3 + t4 * delta);
    }
    const keys = Object.keys(b);
    const interpolators = {};
    keys.forEach((key) => {
      interpolators[key] = get_interpolator(a3[key], b[key]);
    });
    return (t4) => {
      const result = {};
      keys.forEach((key) => {
        result[key] = interpolators[key](t4);
      });
      return result;
    };
  }
  if (type2 === "number") {
    const delta = b - a3;
    return (t4) => a3 + t4 * delta;
  }
  throw new Error(`Cannot interpolate ${type2} values`);
}
function tweened(value, defaults = {}) {
  const store = writable2(value);
  let task;
  let target_value = value;
  function set4(new_value, opts) {
    if (value == null) {
      store.set(value = new_value);
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let { delay = 0, duration = 400, easing = identity6, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set(value = target_value);
      return Promise.resolve();
    }
    const start2 = now2() + delay;
    let fn;
    task = loop((now22) => {
      if (now22 < start2)
        return true;
      if (!started) {
        fn = interpolate(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now22 - start2;
      if (elapsed > duration) {
        store.set(value = new_value);
        return false;
      }
      store.set(value = fn(easing(elapsed / duration)));
      return true;
    });
    return task.promise;
  }
  return {
    set: set4,
    update: (fn, opts) => set4(fn(target_value, value), opts),
    subscribe: store.subscribe
  };
}
var subscriber_queue2, lineW, maxItems, LinesHr, LatestPublications, Home, Routes;
var init_index_beec00e3 = __esm({
  ".svelte-kit/output/server/chunks/index-beec00e3.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_src32();
    init_Publication_73e3b84b();
    init_ssr();
    subscriber_queue2 = [];
    lineW = 50;
    maxItems = 1e3;
    LinesHr = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let numX;
      let numY;
      let xPadding;
      let yPadding;
      let rotations;
      let distances;
      let items;
      let getAngle;
      let getDistance;
      let $distances, $$unsubscribe_distances = noop5, $$subscribe_distances = () => ($$unsubscribe_distances(), $$unsubscribe_distances = subscribe(distances, ($$value) => $distances = $$value), distances);
      let $rotations, $$unsubscribe_rotations = noop5, $$subscribe_rotations = () => ($$unsubscribe_rotations(), $$unsubscribe_rotations = subscribe(rotations, ($$value) => $rotations = $$value), rotations);
      let width = 2200;
      let height = 500;
      let x5 = 0;
      let y4 = 0;
      const padding = lineW * 0.3;
      const flatten3 = (arr) => arr.reduce((a3, b) => a3.concat(b), []);
      const updateRotations = () => {
        set_store_value(rotations, $rotations = [...items.map(getAngle), ...$rotations].slice(0, maxItems), $rotations);
      };
      const colorScale = sqrt2().domain([0, 600]).range(["#0ea5e9", "#e2e8f0"]).clamp(true);
      const updateDistances = () => {
        set_store_value(distances, $distances = [...items.map(getDistance), ...$distances].slice(0, maxItems), $distances);
      };
      numX = Math.floor(width / lineW);
      numY = Math.floor(height / lineW);
      xPadding = (width - numX * lineW) / 2;
      yPadding = (height - numY * lineW) / 2;
      $$subscribe_rotations(rotations = tweened(range(0, maxItems).map(() => Math.random() * Math.PI * 2)));
      $$subscribe_distances(distances = tweened(range(0, maxItems).map(() => 1)));
      items = flatten3(range(0, numX).map((i2) => {
        return range(0, numY).map((j) => {
          return [i2 * lineW, j * lineW];
        });
      }));
      getAngle = (pos) => {
        const angle2 = Math.atan2(pos[1] + lineW / 2 + yPadding - y4, pos[0] + lineW / 2 + xPadding - x5);
        return angle2;
      };
      getDistance = (pos) => {
        const distance = Math.sqrt(Math.pow(pos[0] - x5, 2) + Math.pow(pos[1] - y4, 2));
        return distance;
      };
      {
        updateRotations();
      }
      {
        updateDistances();
      }
      $$unsubscribe_distances();
      $$unsubscribe_rotations();
      return `<div class="${"w-full h-[500px] mt-28 breakout"}"><svg class="${"w-full h-full pointer-events-none"}"><defs><path id="${"line"}" d="${"M " + escape2(padding) + " " + escape2(padding) + " L " + escape2(lineW - padding) + " " + escape2(lineW - padding)}" stroke="${"currentColor"}" stroke-width="${"9"}" stroke-linecap="${"round"}"></path></defs><g style="${"transform: translate(" + escape2(xPadding) + "px," + escape2(yPadding) + "px)"}">${each(items, ([x22, y22], i2) => `<use href="${"#line"}"${add_attribute("x", x22, 0)}${add_attribute("y", y22, 0)} style="${"color: " + escape2(colorScale($distances[i2])) + "; transform-origin: " + escape2(x22 + lineW * 0.5) + "px " + escape2(y22 + lineW * 0.5) + "px; transform: rotate(" + escape2($rotations[i2] - Math.PI * 0.25) + "rad)"}"></use>`)}</g></svg></div>`;
    });
    LatestPublications = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const publications$1 = publications.sort((a3, b) => {
        return new Date(b.date) - new Date(a3.date);
      }).slice(0, 3);
      return `<div class="${"-mx-14 space-y-12"}">${each(publications$1, (publication, i2) => `<div>${validate_component(Publication, "Publication").$$render($$result, Object.assign(publication), {}, {})}
    </div>`)}</div>`;
    });
    Home = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h1 id="${"hi-im-jacob-yates"}">Hi, I\u2019m Jacob Yates</h1>
<p>I\u2019m an <a href="${"https://www.openphilanthropy.org/"}" rel="${"nofollow"}">Open Philanthropy</a> Fellow of the <a href="${"http://www.lsrf.org/"}" rel="${"nofollow"}">Life Sciences Research Foundation</a>. I\u2019m currently a postdoc in the Department of Biology at the University of Maryland under the supervision of Dr. <a href="${"http://www.neurotheory.umd.edu/people/dbutts"}" rel="${"nofollow"}">Daniel Butts</a>. I collaborate closely with Drs. <a href="${"http://marmolab.bcs.rochester.edu/index.html"}" rel="${"nofollow"}">Jude Mitchell</a> and <a href="${"http://aplab.bcs.rochester.edu/"}" rel="${"nofollow"}">Michele Rucci</a> at the University of Rochester.</p>
<p>My research is broadly focused on how mammalian brains extract information about the world using vision. This is an active process and is highly specialized in humans and other primates. My specific research questions are related to general principles of active vision and primate-specific specializations for high-resolution spatial vision.</p>
<p>You can find my full publication list <a href="${"https://scholar.google.com/citations?user=UJm-TkYAAAAJ&hl=en"}" rel="${"nofollow"}">here</a> and I am sometimes active on Twitter <a href="${"https://twitter.com/jcbyts"}" rel="${"nofollow"}">@jcbyts</a>.</p>
<p>This website is an overview of my work, but it is (very much) under construction.</p>
${validate_component(LinesHr, "LinesHr").$$render($$result, {}, {}, {})}
<h2 id="${"active-vision"}">Active Vision</h2>
<p>Most animals with complex spatial vision use image-forming eyes and a \u201Csaccade and fixate\u201D pattern of eye movements to see the world. However, their eyes are never still, counter-rotating relative to body and/or head movements, and drifting during \u201Cfixations\u201D, such that the input to the retina is better thought of as a spatiotemporal movie instead of a stable (or unstable) image. My research aims to understand the algorithms the brain uses (in cortical visual areas) to utilize information that is generated by the motion of the eyes. To approach this, I use a combination of high-resolution eye-tracking and statistical models of both the visual input and neural activity in visual cortex.</p>
<h2 id="${"foveal-processing"}">Foveal Processing</h2>
<p>Humans see best at the very center center of their visual field. This \u201Chigh-resolution\u201D region is called the fovea and, among mammals, only primates have one. The primate fovea is a highly-specialized anatomical adaptation for high-resolution spatial vision and it differs substantially from the peripheral retina and the retinas of other mammals.</p>
<hr>
<h2 id="${"latest-publications"}">Latest Publications</h2>
${validate_component(LatestPublications, "LatestPublications").$$render($$result, { title: "HI" }, {}, {})}`;
    });
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${$$result.head += `${$$result.title = `<title>Jacob Yates</title>`, ""}`, ""}

<div class="${"c"}">${validate_component(Home, "Content").$$render($$result, {}, {}, {})}
</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/example-markdown-1d29d56c.js
var example_markdown_1d29d56c_exports = {};
__export(example_markdown_1d29d56c_exports, {
  default: () => Example_markdown
});
var Example_markdown;
var init_example_markdown_1d29d56c = __esm({
  ".svelte-kit/output/server/chunks/example-markdown-1d29d56c.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_ssr();
    Example_markdown = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<p><strong>Note that despite this file having an md extension, it can support all Svelte language features (like scripting). Do not import untrusted or user-created markdown files.</strong></p>
<p><em>This markdown sample was taken from <a href="${"https://gist.github.com/rt2zz/e0a1d6ab2682d2c47746950b84c0b6ee"}" rel="${"nofollow"}">here</a>.</em></p>
<h1 id="${"an-h1-header"}">An h1 header</h1>
<p>Paragraphs are separated by a blank line.</p>
<p>2nd paragraph. <em>Italic</em>, <strong>bold</strong>, and <code>monospace</code>. Itemized lists
look like:</p>
<ul><li>this one</li>
<li>that one</li>
<li>the other one</li></ul>
<p>Note that \u2014 not considering the asterisk \u2014 the actual text
content starts at 4-columns in.</p>
<blockquote><p>Block quotes are
written like so.</p>
<p>They can span multiple paragraphs,
if you like.</p></blockquote>
<p>Use 3 dashes for an em-dash. Use 2 dashes for ranges (ex., \u201Cit\u2019s all
in chapters 12\u201314\u201D). Three dots \u2026 will be converted to an ellipsis.
Unicode is supported. \u263A</p>
<h2 id="${"an-h2-header"}">An h2 header</h2>
<p>Here\u2019s a numbered list:</p>
<ol><li>first item</li>
<li>second item</li>
<li>third item</li></ol>
<p>By the way, you can write code in delimited blocks:</p>
<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">define foobar() &#123;
    print &quot;Welcome to flavor country!&quot;;
&#125;</code>`}<!-- HTML_TAG_END --></pre>
<p>(which makes copying &amp; pasting easier). You can optionally mark the
delimited block for syntax highlighting when you include the CSS for a Prism theme:</p>
<pre class="${"language-python"}"><!-- HTML_TAG_START -->${`<code class="language-python"><span class="token keyword">import</span> time
<span class="token comment"># Quick, count to ten!</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># (but not *too* quick)</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span> i</code>`}<!-- HTML_TAG_END --></pre>
<h3 id="${"an-h3-header"}">An h3 header</h3>
<p>Now, a nested list:</p>
<ol><li>First, get these ingredients:<ul><li>carrots</li>
<li>celery</li>
<li>lentils</li></ul></li>
<li>Boil some water.</li>
<li>Dump everything in the pot and follow
this algorithm:<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">find wooden spoon
uncover pot
stir
cover pot
balance wooden spoon precariously on pot handle
wait 10 minutes
goto first step (or shut off burner when done)</code>`}<!-- HTML_TAG_END --></pre>Do not bump wooden spoon or it will fall.</li></ol>
<p>Notice again how text always lines up on 4-space indents (including
that last line which continues item 3 above).</p>
<p>Here\u2019s a link to <a href="${"http://foo.bar"}" rel="${"nofollow"}">a website</a> and one to this site\u2019s <a href="${"/"}">home page</a>. Because the <code>rehype-slug</code> and <code>rehype-autolink-headings</code> plugins have been set up for you, <a href="${"#an-h2-header"}">this will link to a section heading in the current
doc</a>.</p>
<p>A horizontal rule follows.</p>
<hr>
<p>And note that you can backslash-escape any punctuation characters
which you wish to be displayed literally, ex.: \`foo\`, *bar*, etc.</p>
<p>This mention \u2014 <a href="${"https://github.com/svelte-add"}"><strong>@svelte-add</strong></a> \u2014 will turn into a link to the <code>svelte-add</code> GitHub page because the <code>remark-github</code> plugin is setup.</p>`;
    });
  }
});

// .svelte-kit/output/server/chunks/publications-60147713.js
var publications_60147713_exports = {};
__export(publications_60147713_exports, {
  default: () => Publications
});
var Publications;
var init_publications_60147713 = __esm({
  ".svelte-kit/output/server/chunks/publications-60147713.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_Publication_73e3b84b();
    init_ssr();
    Publications = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${$$result.head += `${$$result.title = `<title>Jacob Yates: Publications</title>`, ""}`, ""}

<div class="${""}"><h1>Selected Publications</h1>
  <p>Find a complete list of publications${escape2(" ")}
    <a href="${"https://scholar.google.com/citations?user=UJm-TkYAAAAJ&hl=en"}">here
    </a></p>
  <div class="${"-ml-14 space-y-12"}">${each(publications, (publication, i2) => `<div>${validate_component(Publication, "Publication").$$render($$result, Object.assign(publication), {}, {})}
      </div>`)}</div></div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/__layout-7372316c.js
var layout_7372316c_exports = {};
__export(layout_7372316c_exports, {
  default: () => _layout2,
  load: () => load2
});
async function load2({ page, fetch: fetch2, session, context }) {
  const url = "/blog.json";
  const { path: path2 } = page;
  const res = await fetch2(url);
  if (res.ok) {
    const posts = await res.json();
    const metadata6 = posts.find((d) => d["slug"] === path2.split("/")[2]);
    return { props: { metadata: metadata6 } };
  }
  return {
    status: res.status,
    error: new Error(`Could not load ${url}`)
  };
}
var _layout2;
var init_layout_7372316c = __esm({
  ".svelte-kit/output/server/chunks/__layout-7372316c.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_src32();
    init_ssr();
    _layout2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let title;
      let slug;
      let isDraft;
      let { metadata: metadata6 = {} } = $$props;
      const formatDate2 = timeFormat("%b %e, %Y");
      if ($$props.metadata === void 0 && $$bindings.metadata && metadata6 !== void 0)
        $$bindings.metadata(metadata6);
      title = metadata6?.title;
      slug = metadata6?.slug;
      isDraft = metadata6?.draft;
      return `${$$result.head += `${$$result.title = `<title>${escape2(title)}</title>`, ""}<meta property="${"og:type"}" content="${"article"}" data-svelte="svelte-1ddvq1z"><meta property="${"og:url"}" content="${"https://jake.vision/blog/" + escape2(slug ? slug : "")}" data-svelte="svelte-1ddvq1z">`, ""}

<h1 class="${"mb-0"}">${escape2(title)}</h1>
<div class="${"mt-2 font-mono text-gray-500"}">${escape2(formatDate2(new Date(metadata6?.date)))}</div>

<div class="${"content bg-white mt-10 -mx-14 py-16 px-14 shadow-2xl shadow-blue-50"}">${isDraft ? `${`This post is in progress!`}` : `${slots.default ? slots.default({}) : ``}`}</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/blog-281eb610.js
var blog_281eb610_exports = {};
__export(blog_281eb610_exports, {
  default: () => Blog,
  load: () => load3
});
async function load3({ page, fetch: fetch2, session, context }) {
  const url = "/blog.json";
  const res = await fetch2(url);
  if (res.ok) {
    const posts = await res.json();
    return { props: { posts } };
  }
  return {
    status: res.status,
    error: new Error(`Could not load ${url}`)
  };
}
var Blog;
var init_blog_281eb610 = __esm({
  ".svelte-kit/output/server/chunks/blog-281eb610.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_src32();
    init_ssr();
    Blog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { posts = [] } = $$props;
      const formatDate2 = timeFormat("%b %e, %Y");
      if ($$props.posts === void 0 && $$bindings.posts && posts !== void 0)
        $$bindings.posts(posts);
      return `<h1>Thoughts</h1>

<div class="${"space-y-12 -mx-14"}">${each(posts.filter((d) => !d.draft && d.slug), ({ slug, title, date: date2, description }) => `<article class="${"bg-white py-6 md:py-10 px-5 md:px-14 shadow-lg shadow-blue-50 hover:shadow-blue-100 transition-all transform hover:-translate-y-1"}"><header><a href="${"/blog/" + escape2(slug)}"><h3 class="${"mt-0 text-gray-900"}">${escape2(title)}
          </h3></a>
        <small class="${"font-mono text-gray-500 text-sm"}">${escape2(formatDate2(new Date(date2)))}</small></header>
      ${description ? `<section class="${"mt-3"}"><p>${escape2(description)}</p>
        </section>` : ``}
    </article>`)}</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/cv-cbda05fe.js
var cv_cbda05fe_exports = {};
__export(cv_cbda05fe_exports, {
  default: () => Cv
});
var cv, Cv;
var init_cv_cbda05fe = __esm({
  ".svelte-kit/output/server/chunks/cv-cbda05fe.js"() {
    init_shims();
    init_app_bb3e34d2();
    init_Publication_73e3b84b();
    init_ssr();
    cv = [
      {
        title: "Education",
        items: [
          {
            title: "The University of Texas at Austin",
            when: "2010 - 2016",
            footnote: "Ph.D., Neuroscience"
          },
          {
            title: "University of California, Berkeley",
            when: "2004 - 2007",
            footnote: "B.A., Major: Psychology"
          }
        ]
      },
      {
        title: "Research Experience",
        items: [
          {
            title: "Post-Doctoral Fellow",
            where: "The University of Rochester",
            when: "2016 - present"
          },
          {
            title: "Graduate Research Assistant",
            where: "The University of Texas at Austin",
            when: "2010 - 2016"
          },
          {
            title: "Research Assistant",
            where: "The Smith-Kettlewell Eye Research Institute",
            when: "2009 - 2010"
          }
        ]
      },
      {
        title: "Publications"
      },
      {
        title: "Talks",
        items: [
          {
            title: "Choice probabilities and correlations in simultaneously recorded MT and\nLIP neurons",
            when: "2014",
            where: "SFN",
            who: "Yates, J.L, Katz, L. N., Park, I. M., Pillow, J. W., & Huk, A. C."
          },
          {
            title: "Dissociated functional signi\uFB01cance of choice-related activity across the\nprimate dorsal stream",
            when: "2014",
            where: "Cosyne",
            who: "Yates, J. L., Katz L. K., Park, I. M., Pillow J. W., Huk A."
          },
          {
            title: "Decision-related activity in neurons does not imply a causal effect on\nbehavior",
            when: "2014",
            where: "Institute for Neuroscience Symposium",
            who: "Yates, J. L., Katz L. K., Park, I. M., Pillow J. W., Huk A.",
            tag: "invited"
          }
        ]
      },
      {
        title: "Posters",
        items: [
          {
            title: "A behavioral tracking paradigm for estimating visual sensitivity with dynamic\ninternal models",
            authors: "Bonnen K., Burge J., Yates J. L., Pillow J. W., Cormack L. K.",
            where: "Cosyne",
            when: "2014"
          },
          {
            title: "Precise characterization of dorsal stream neural activity during decision\nmaking",
            authors: "Yates J. L., Park I. M., Cormack L. K., Pillow J. W., Huk, A. C.",
            where: "SFN",
            when: "2013"
          },
          {
            title: " A. C. Neuromuscular recruitment during oculomotor decision-making in\nhuman",
            authors: "Katz. L. N., Yates J. L., Cormack L. K., Huk",
            where: "SFN",
            when: "2013"
          },
          {
            title: " A. C. Precise characterization of multiple LIP neurons in relation to\nstimulus and behavior",
            authors: "Yates J. L., Park I. M., Cormack L. K., Pillow J. W., Huk",
            where: "Cosyne",
            when: "2013"
          },
          {
            title: "Psychophysical reverse correlation of motion perception",
            authors: "Yates, J. L., Huk A. C., Cormack L. K., Pillow J. W.",
            where: "VSS",
            when: "2012"
          },
          {
            title: "Probing motion perception with spatiotemporal reverse correlation",
            authors: "Yates J. L., Cormack L. K., Huk A. C., Pillow J. W.",
            where: "Cosyne",
            when: "2012"
          },
          {
            title: "An evoked-response polarity reversal from upper and lower visual field\nstimuli is insufficient to uniquely identify V1",
            authors: "Ales J. M., Yates J. L., Norcia A. M.",
            where: "SFN",
            when: "2009"
          }
        ]
      },
      {
        title: "Service",
        items: [
          {
            title: "Graduate Student Outreach Program",
            where: "UT Neuroscience and Psychology",
            when: "2010 - 2014"
          },
          {
            title: "Symposium Organizing Committee",
            where: "UT Institute for Neuroscience",
            when: "2011 - 2013"
          },
          {
            title: "Symposium Chair",
            where: "UT Institute for Neuroscience",
            when: "2012"
          },
          {
            title: "Graduate Student Assembly representative",
            where: "UT Austin College of Natural Sciences",
            when: "2010 - 2011"
          }
        ]
      },
      {
        title: "Honors & Awards",
        items: [
          {
            title: "Professional Development Award",
            where: "UT Austin College of Natural Sciences",
            when: "2015"
          },
          {
            title: "Cold Spring Harbor Labs course attendee",
            where: "Neuroscience: Computational Vision",
            when: "2014"
          },
          {
            title: "Training Grant recipient",
            where: "Center for Perceptual Neuroscience",
            when: "2012 - 2014"
          },
          {
            title: "Training Grant recipient",
            where: "Institute for Neuroscience",
            when: "2010 - 2012"
          },
          {
            title: "Deans\u2019s Excellence Award",
            where: "UT Austin College of Natural Science",
            when: "2010"
          },
          {
            title: "Graduate School Recruitment Fellowship",
            where: "UT Austin College of Natural Science",
            when: "2010"
          }
        ]
      }
    ];
    Cv = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${$$result.head += `${$$result.title = `<title>Jacob Yates: CV</title>`, ""}`, ""}

<div class="${"cv"}"><h1>CV</h1>

  <div class="${"list"}">${each(cv, ({ title, items }, i2) => `<div class="${"section"}"><h3>${escape2(title)}</h3>

        <div class="${[
        "space-y-12",
        (title.toLowerCase() === "publications" ? "-ml-14" : "") + " " + (title.toLowerCase() !== "publications" ? "-ml-8" : "") + " " + (title.toLowerCase() === "publications" ? "space-y-12" : "") + " " + (title.toLowerCase() !== "publications" ? "space-y-6" : "")
      ].join(" ").trim()}">${title.toLowerCase() === "publications" ? `${each(publications, (publication) => `${validate_component(Publication, "Publication").$$render($$result, Object.assign(publication), {}, {})}`)}` : ``}
          ${each(items || [], ({ title: title2, when, who, authors, where, tag, footnote }) => `<div class="${"px-8 py-5 flex justify-between"}"${add_attribute("key", title2, 0)}><div class="${""}"><h3 class="${"mt-0"}">${escape2(title2)}</h3>
                ${each([who, authors].filter((d) => d), (d) => `<div class="${"text-gray-500"}">${escape2(d)}</div>`)}
                ${each([where, tag, footnote].filter((d) => d), (d) => `<div class="${"text-gray-500"}">${escape2(d)}</div>`)}</div>
              <div class="${"font-mono text-gray-500 mt-3"}">${escape2(when)}</div>
            </div>`)}</div>
      </div>`)}</div>
</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/app-bb3e34d2.js
function noop5() {
}
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal2(a3, b) {
  return a3 != a3 ? b == b : a3 !== b || (a3 && typeof a3 === "object" || typeof a3 === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop5;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function run_tasks(now22) {
  tasks.forEach((task) => {
    if (!task.c(now22)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function escape2(html2) {
  return String(html2).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    str += fn(items[i2], i2);
  }
  return str;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html2 = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html2;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html2 = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html: html2,
        css: {
          code: Array.from(result.css).map((css22) => css22.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
function init2(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-2565e3a0.js",
      css: [assets + "/_app/assets/start-464e9d0a.css"],
      js: [assets + "/_app/start-2565e3a0.js", assets + "/_app/chunks/vendor-0fd8ff1a.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id2) => assets + "/_app/" + entry_lookup[id2],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
async function load_component(file) {
  const { entry, css: css22, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css22.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var identity6, is_client, now2, raf, tasks, current_component, escaped2, missing_component, on_destroy, css4, Root, base, assets, user_hooks, template, options, default_settings, empty4, manifest, get_hooks, module_lookup, metadata_lookup;
var init_app_bb3e34d2 = __esm({
  ".svelte-kit/output/server/chunks/app-bb3e34d2.js"() {
    init_shims();
    init_ssr();
    identity6 = (x5) => x5;
    is_client = typeof window !== "undefined";
    now2 = is_client ? () => window.performance.now() : () => Date.now();
    raf = is_client ? (cb) => requestAnimationFrame(cb) : noop5;
    tasks = new Set();
    Promise.resolve();
    escaped2 = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
    css4 = {
      code: "#svelte-announcer.svelte-1pdgbjn{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}",
      map: null
    };
    Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page } = $$props;
      let { components } = $$props;
      let { props_0 = null } = $$props;
      let { props_1 = null } = $$props;
      let { props_2 = null } = $$props;
      let { props_3 = null } = $$props;
      setContext("__svelte__", stores);
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page !== void 0)
        $$bindings.page(page);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
        $$bindings.props_0(props_0);
      if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
        $$bindings.props_1(props_1);
      if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
        $$bindings.props_2(props_2);
      if ($$props.props_3 === void 0 && $$bindings.props_3 && props_3 !== void 0)
        $$bindings.props_3(props_3);
      $$result.css.add(css4);
      {
        stores.page.set(page);
      }
      return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
        default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
          default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {
            default: () => `${components[3] ? `${validate_component(components[3] || missing_component, "svelte:component").$$render($$result, Object.assign(props_3 || {}), {}, {})}` : ``}`
          })}` : ``}`
        })}` : ``}`
      })}

${``}`;
    });
    base = "";
    assets = "";
    user_hooks = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module"
    });
    template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n\n<head>\n	<meta charset="utf-8" />\n	<link rel="icon" href="/favicon.ico" />\n	<meta name="viewport" content="width=device-width, initial-scale=1" />\n	<meta charset="utf-8" />\n	<meta name="viewport" content="width=device-width,initial-scale=1.0" />\n	<meta name="theme-color" content="#245242" />\n\n	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />\n	<meta name="description"\n		content="Jacob Yates is a post-doc interested in how sensory signals are encoded into neural activity and how that activity is decoded to form perceptions and actions" />\n	<meta name="news_keywords" content="tk" />\n\n	<meta property="og:title" content="Jacob Yates" />\n	<meta property="og:site_name" content="Jacob Yates" />\n	<meta property="og:url" content="https://jake.vision" />\n	<meta property="og:image" content="/share-image.png" />\n\n	<meta property="og:description"\n		content="Jacob Yates is a post-doc interested in how sensory signals are encoded into neural activity and how that activity is decoded to form perceptions and actions" />\n	<meta property="og:type" content="article" />\n	<meta property="og:locale" content="en_US" />\n\n	<meta name="twitter:card" content="summary_large_image" />\n	<meta name="twitter:site" content="https://jake.vision" />\n	<meta name="twitter:creator" content="@jcbyts" />\n	<meta name="twitter:title" content="Jacob Yates" />\n	<meta name="twitter:description"\n		content="Jacob Yates is a post-doc interested in how sensory signals are encoded into neural activity and how that activity is decoded to form perceptions and actions" />\n\n	<title>Jacob Yates</title>\n\n	<link rel="stylesheet" href="/reset.css" />\n	<link rel="stylesheet" href="/colors.css" />\n	<link rel="stylesheet" href="/global.css" />\n	<link rel="manifest" href="/manifest.json" crossorigin="use-credentials" />\n	<link rel="icon" type="image/svg+xml" href="/favicon.svg" />\n	<link rel="alternate icon" href="/favicon.ico" />\n\n	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"\n		integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous" />\n\n	<link rel="preconnect" href="https://fonts.googleapis.com">\n	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>\n	<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&display=swap" rel="stylesheet">\n\n	' + head + '\n</head>\n\n<body>\n	<div id="svelte">' + body + '</div>\n\n	<!-- Global site tag (gtag.js) - Google Analytics -->\n	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-96837436-1"><\/script>\n\n	<script>\n		window.dataLayer = window.dataLayer || [];\n		function gtag() {\n			dataLayer.push(arguments);\n		}\n		gtag("js", new Date());\n\n		gtag("config", "UA-96837436-1");\n	<\/script>\n\n	<script>\n		window.twttr = (function (d, s, id) {\n			var js,\n				fjs = d.getElementsByTagName(s)[0],\n				t = window.twttr || {};\n			if (d.getElementById(id)) return t;\n			js = d.createElement(s);\n			js.id = id;\n			js.src = "https://platform.twitter.com/widgets.js";\n			fjs.parentNode.insertBefore(js, fjs);\n\n			t._e = [];\n			t.ready = function (f) {\n				t._e.push(f);\n			};\n\n			return t;\n		})(document, "script", "twitter-wjs");\n	<\/script>\n</body>\n\n</html>';
    options = null;
    default_settings = { paths: { "base": "", "assets": "" } };
    empty4 = () => ({});
    manifest = {
      assets: [{ "file": "FiraCode-VF.woff", "size": 138576, "type": "font/woff" }, { "file": "FiraCode-VF.woff2", "size": 113088, "type": "font/woff2" }, { "file": "_redirects", "size": 24, "type": null }, { "file": "arduinoblog/fig01_Setup.png", "size": 41590, "type": "image/png" }, { "file": "arduinoblog/fig02_open.png", "size": 41614, "type": "image/png" }, { "file": "arduinoblog/fig03_loop.png", "size": 110109, "type": "image/png" }, { "file": "arduinoblog/fig04_summary.png", "size": 48268, "type": "image/png" }, { "file": "arduinoblog/fig05_libvar.png", "size": 157858, "type": "image/png" }, { "file": "arduinoblog/fig06_setup.png", "size": 112326, "type": "image/png" }, { "file": "arduinoblog/fig07_loop.png", "size": 185446, "type": "image/png" }, { "file": "arduinoblog/fig08_encoder.png", "size": 132219, "type": "image/png" }, { "file": "arduinoblog/fig09_outpu.png", "size": 219326, "type": "image/png" }, { "file": "arduinoblog/fig10_summary.png", "size": 44434, "type": "image/png" }, { "file": "arduinoblog/fig11_approach2mat.png", "size": 41737, "type": "image/png" }, { "file": "arduinoblog/fig12_approach2matloop.png", "size": 251171, "type": "image/png" }, { "file": "colors.css", "size": 1153, "type": "text/css" }, { "file": "favicon.ico", "size": 2929, "type": "image/vnd.microsoft.icon" }, { "file": "favicon.png", "size": 2929, "type": "image/png" }, { "file": "global.css", "size": 1889, "type": "text/css" }, { "file": "labmeetinglurz/battymultitaskln.png", "size": 319809, "type": "image/png" }, { "file": "labmeetinglurz/buttsdatadriven.png", "size": 751411, "type": "image/png" }, { "file": "labmeetinglurz/buttstransfer.png", "size": 665654, "type": "image/png" }, { "file": "labmeetinglurz/elu.png", "size": 138885, "type": "image/png" }, { "file": "labmeetinglurz/kingmavaelearning.png", "size": 122556, "type": "image/png" }, { "file": "labmeetinglurz/kingmavaereparameterization.png", "size": 177378, "type": "image/png" }, { "file": "labmeetinglurz/lurzfig2.png", "size": 486156, "type": "image/png" }, { "file": "labmeetinglurz/lurzfig3.png", "size": 233728, "type": "image/png" }, { "file": "labmeetinglurz/lurzfig4.png", "size": 181205, "type": "image/png" }, { "file": "labmeetinglurz/lurzfig5.png", "size": 234912, "type": "image/png" }, { "file": "labmeetinglurz/pointreadout.png", "size": 93170, "type": "image/png" }, { "file": "labmeetinglurz/sinz2018.png", "size": 185976, "type": "image/png" }, { "file": "labmeetinglurz/spatialtransformer.png", "size": 73576, "type": "image/png" }, { "file": "labmeetinglurz/wrtphi.png", "size": 46370, "type": "image/png" }, { "file": "labmeetinglurz/wrttheta.png", "size": 74355, "type": "image/png" }, { "file": "manifest.json", "size": 369, "type": "application/json" }, { "file": "motionillusionblog/1Dbars_GifAsImg.jpeg", "size": 734763, "type": "image/jpeg" }, { "file": "motionillusionblog/1Dbars_buckets.jpeg", "size": 332890, "type": "image/jpeg" }, { "file": "motionillusionblog/1Dflicker.mp4", "size": 157422, "type": "video/mp4" }, { "file": "motionillusionblog/AdelsonBergenEdgeDetector.png", "size": 81728, "type": "image/png" }, { "file": "motionillusionblog/AdelsonBergenMotionOrientation.png", "size": 206624, "type": "image/png" }, { "file": "motionillusionblog/AdelsonBergenQpair.png", "size": 160635, "type": "image/png" }, { "file": "motionillusionblog/MarioCropped.mp4", "size": 117055, "type": "video/mp4" }, { "file": "motionillusionblog/MarioCropped_motE.mp4", "size": 1383301, "type": "video/mp4" }, { "file": "motionillusionblog/MarioCropped_motE_0.mp4", "size": 688217, "type": "video/mp4" }, { "file": "motionillusionblog/MarioCropped_motE_1.mp4", "size": 1315309, "type": "video/mp4" }, { "file": "motionillusionblog/MarioFrame1.png", "size": 31353, "type": "image/png" }, { "file": "motionillusionblog/MarioGray.mp4", "size": 33376, "type": "video/mp4" }, { "file": "motionillusionblog/MarioReversePhi_Adelson0.png", "size": 18678, "type": "image/png" }, { "file": "motionillusionblog/MarioReversePhi_Adelson1.png", "size": 77977, "type": "image/png" }, { "file": "motionillusionblog/MarioReversePhi_motE.mp4", "size": 3371248, "type": "video/mp4" }, { "file": "motionillusionblog/MarioReversePhi_motE_0.mp4", "size": 1817979, "type": "video/mp4" }, { "file": "motionillusionblog/MarioReversePhi_motE_1.mp4", "size": 2075026, "type": "video/mp4" }, { "file": "motionillusionblog/MarioReversePhi_motE_1fnetvis.mp4", "size": 1117308, "type": "video/mp4" }, { "file": "motionillusionblog/MarioSpaceTime.png", "size": 31186, "type": "image/png" }, { "file": "motionillusionblog/adelsonComponents.png", "size": 27804, "type": "image/png" }, { "file": "motionillusionblog/adelsonOrientedFilters.png", "size": 23606, "type": "image/png" }, { "file": "motionillusionblog/buckets.jpeg", "size": 717165, "type": "image/jpeg" }, { "file": "motionillusionblog/buckets.jpg", "size": 716949, "type": "image/jpeg" }, { "file": "motionillusionblog/buckets.jpg:Zone.Identifier", "size": 0, "type": null }, { "file": "motionillusionblog/coloredgeannotated.png", "size": 124866, "type": "image/png" }, { "file": "motionillusionblog/constructedframe.png", "size": 8500, "type": "image/png" }, { "file": "motionillusionblog/constructedspacetime.png", "size": 13603, "type": "image/png" }, { "file": "motionillusionblog/exampleFrames.png", "size": 321403, "type": "image/png" }, { "file": "motionillusionblog/gaussianderivative.png", "size": 42579, "type": "image/png" }, { "file": "motionillusionblog/grayannotate.png", "size": 408753, "type": "image/png" }, { "file": "motionillusionblog/grayannotated.png", "size": 29398, "type": "image/png" }, { "file": "motionillusionblog/grayedgeannotated.png", "size": 41464, "type": "image/png" }, { "file": "motionillusionblog/grayedgeannotated.psd", "size": 720135, "type": "image/vnd.adobe.photoshop" }, { "file": "motionillusionblog/grayedgeannotated2.jpg", "size": 58984, "type": "image/jpeg" }, { "file": "motionillusionblog/grayedgesannotated.png", "size": 448460, "type": "image/png" }, { "file": "motionillusionblog/marioReversePhi.mp4", "size": 628741, "type": "video/mp4" }, { "file": "motionillusionblog/marioReversePhi_Adelson.png", "size": 96934, "type": "image/png" }, { "file": "motionillusionblog/mariocrop_GifAsImg.jpeg", "size": 2749512, "type": "image/jpeg" }, { "file": "motionillusionblog/mariocrop_buckets.jpeg", "size": 796468, "type": "image/jpeg" }, { "file": "motionillusionblog/marioreversephi_flownet.avi", "size": 609524, "type": "video/x-msvideo" }, { "file": "motionillusionblog/marioreversephi_flownetcomp.mp4", "size": 2361268, "type": "video/mp4" }, { "file": "motionillusionblog/motEfilters.mp4", "size": 63670, "type": "video/mp4" }, { "file": "motionillusionblog/motionlegend.png", "size": 26630, "type": "image/png" }, { "file": "motionillusionblog/motionlegendtitle.png", "size": 34055, "type": "image/png" }, { "file": "motionillusionblog/orangGifAsImg.jpeg", "size": 3926985, "type": "image/jpeg" }, { "file": "motionillusionblog/orangannotated.png", "size": 1297617, "type": "image/png" }, { "file": "motionillusionblog/orangframannotated.png", "size": 702273, "type": "image/png" }, { "file": "motionillusionblog/orangutanVid.mp4", "size": 427197, "type": "video/mp4" }, { "file": "reset.css", "size": 1056, "type": "text/css" }, { "file": "robots.txt", "size": 54, "type": "text/plain" }],
      layout: "src/routes/__layout.svelte",
      error: ".svelte-kit/build/components/error.svelte",
      routes: [
        {
          type: "page",
          pattern: /^\/$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/example-markdown\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/example-markdown.md"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/publications\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/publications.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "endpoint",
          pattern: /^\/sitemap\.xml$/,
          params: empty4,
          load: () => Promise.resolve().then(() => (init_sitemap_xml_0197c0cd(), sitemap_xml_0197c0cd_exports))
        },
        {
          type: "endpoint",
          pattern: /^\/blog\.json$/,
          params: empty4,
          load: () => Promise.resolve().then(() => (init_index_json_0f0405c8(), index_json_0f0405c8_exports))
        },
        {
          type: "page",
          pattern: /^\/blog\/foodservice-academia\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/blog/__layout.svelte", "src/routes/blog/foodservice-academia.svx"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/blog\/motion-illusions\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/blog/__layout.svelte", "src/routes/blog/motion-illusions.svx"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/blog\/matlab-arduino\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/blog/__layout.svelte", "src/routes/blog/matlab-arduino.svx"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/blog\/noisy-better\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/blog/__layout.svelte", "src/routes/blog/noisy-better.svx"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/blog\/lurz-paper\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/blog/__layout.svelte", "src/routes/blog/lurz-paper.svx"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/blog\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/blog.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        },
        {
          type: "page",
          pattern: /^\/cv\/?$/,
          params: empty4,
          a: ["src/routes/__layout.svelte", "src/routes/cv.svelte"],
          b: [".svelte-kit/build/components/error.svelte"]
        }
      ]
    };
    get_hooks = (hooks) => ({
      getSession: hooks.getSession || (() => ({})),
      handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
      handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
      externalFetch: hooks.externalFetch || fetch
    });
    module_lookup = {
      "src/routes/__layout.svelte": () => Promise.resolve().then(() => (init_layout_fb37d90b(), layout_fb37d90b_exports)),
      ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(() => (init_error_4b96ad91(), error_4b96ad91_exports)),
      "src/routes/index.svelte": () => Promise.resolve().then(() => (init_index_beec00e3(), index_beec00e3_exports)),
      "src/routes/example-markdown.md": () => Promise.resolve().then(() => (init_example_markdown_1d29d56c(), example_markdown_1d29d56c_exports)),
      "src/routes/publications.svelte": () => Promise.resolve().then(() => (init_publications_60147713(), publications_60147713_exports)),
      "src/routes/blog/__layout.svelte": () => Promise.resolve().then(() => (init_layout_7372316c(), layout_7372316c_exports)),
      "src/routes/blog/foodservice-academia.svx": () => Promise.resolve().then(() => (init_foodservice_academia_299db3c9(), foodservice_academia_299db3c9_exports)),
      "src/routes/blog/motion-illusions.svx": () => Promise.resolve().then(() => (init_motion_illusions_04bc024c(), motion_illusions_04bc024c_exports)),
      "src/routes/blog/matlab-arduino.svx": () => Promise.resolve().then(() => (init_matlab_arduino_e4388c2a(), matlab_arduino_e4388c2a_exports)),
      "src/routes/blog/noisy-better.svx": () => Promise.resolve().then(() => (init_noisy_better_58314b05(), noisy_better_58314b05_exports)),
      "src/routes/blog/lurz-paper.svx": () => Promise.resolve().then(() => (init_lurz_paper_8ed14628(), lurz_paper_8ed14628_exports)),
      "src/routes/blog.svelte": () => Promise.resolve().then(() => (init_blog_281eb610(), blog_281eb610_exports)),
      "src/routes/cv.svelte": () => Promise.resolve().then(() => (init_cv_cbda05fe(), cv_cbda05fe_exports))
    };
    metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-342a02c5.js", "css": ["assets/pages/__layout.svelte-243c153a.css"], "js": ["pages/__layout.svelte-342a02c5.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-5aa7872b.js", "css": [], "js": ["error.svelte-5aa7872b.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-e25d433e.js", "css": ["assets/Publication-8993e706.css"], "js": ["pages/index.svelte-e25d433e.js", "chunks/vendor-0fd8ff1a.js", "chunks/Publication-b9f7b53f.js"], "styles": [] }, "src/routes/example-markdown.md": { "entry": "pages/example-markdown.md-3e1103c1.js", "css": [], "js": ["pages/example-markdown.md-3e1103c1.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/publications.svelte": { "entry": "pages/publications.svelte-949e0a42.js", "css": ["assets/Publication-8993e706.css"], "js": ["pages/publications.svelte-949e0a42.js", "chunks/vendor-0fd8ff1a.js", "chunks/Publication-b9f7b53f.js"], "styles": [] }, "src/routes/blog/__layout.svelte": { "entry": "pages/blog/__layout.svelte-de78c67d.js", "css": [], "js": ["pages/blog/__layout.svelte-de78c67d.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/blog/foodservice-academia.svx": { "entry": "pages/blog/foodservice-academia.svx-f0c0d871.js", "css": [], "js": ["pages/blog/foodservice-academia.svx-f0c0d871.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/blog/motion-illusions.svx": { "entry": "pages/blog/motion-illusions.svx-b3795550.js", "css": ["assets/pages/blog/motion-illusions.svx-9ea925e9.css"], "js": ["pages/blog/motion-illusions.svx-b3795550.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/blog/matlab-arduino.svx": { "entry": "pages/blog/matlab-arduino.svx-0a39f38f.js", "css": [], "js": ["pages/blog/matlab-arduino.svx-0a39f38f.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/blog/noisy-better.svx": { "entry": "pages/blog/noisy-better.svx-8f16cd30.js", "css": [], "js": ["pages/blog/noisy-better.svx-8f16cd30.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/blog/lurz-paper.svx": { "entry": "pages/blog/lurz-paper.svx-2cc25f62.js", "css": [], "js": ["pages/blog/lurz-paper.svx-2cc25f62.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/blog.svelte": { "entry": "pages/blog.svelte-3f984cd7.js", "css": [], "js": ["pages/blog.svelte-3f984cd7.js", "chunks/vendor-0fd8ff1a.js"], "styles": [] }, "src/routes/cv.svelte": { "entry": "pages/cv.svelte-7b1e980c.js", "css": ["assets/Publication-8993e706.css"], "js": ["pages/cv.svelte-7b1e980c.js", "chunks/vendor-0fd8ff1a.js", "chunks/Publication-b9f7b53f.js"], "styles": [] } };
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
init_ssr();
init_app_bb3e34d2();

// .svelte-kit/netlify/entry.js
init2();
async function handler(event) {
  const { path: path2, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const encoding = isBase64Encoded ? "base64" : headers["content-encoding"] || "utf-8";
  const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path: path2,
    query,
    rawBody
  });
  if (!rendered) {
    return {
      statusCode: 404,
      body: "Not found"
    };
  }
  const partial_response = {
    statusCode: rendered.status,
    ...split_headers(rendered.headers)
  };
  if (rendered.body instanceof Uint8Array) {
    return {
      ...partial_response,
      isBase64Encoded: true,
      body: Buffer.from(rendered.body).toString("base64")
    };
  }
  return {
    ...partial_response,
    body: rendered.body
  };
}
function split_headers(headers) {
  const h2 = {};
  const m3 = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m3 : h2;
    target[key] = value;
  }
  return {
    headers: h2,
    multiValueHeaders: m3
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
